<!--

GRAMMAR PRODUCTION SYNTAX
'abc' - Terminal (token) with name "abc"
"abc" - Non-terminal with name "abc"
  |   - Alternation
 ( )  - Grouping
 [ ]  - Optional
 { }  - Iteration (zero or more)
<% %> - User code
<@ @> - Parameter code
<? ?> - Conditional code (can be used after a "[", "{", or "|")
<- -> - Failure match code
<+ +> - Successful match code

VALID IN CUSTOM CODE ONLY
IsNonTerminal("abc") - Returns a boolean as to whether the LookAheadToken can start the non-terminal "abc" 
IsNonTerminal("abc", "this.PeekToken") - Returns a boolean as to whether the specified token can start the non-terminal "abc" 

-->
<Grammar 
	LanguageName="C#" 
	TypeName="CSharpSemanticParser"
	Namespace="ActiproSoftware.SyntaxEditor.Addons.CSharp"
	RootNonTerminal="CompilationUnit"
	LexicalStateIDTypeName="CSharpLexicalStateID"
	TokenIDTypeName="CSharpTokenID">
	<ImportedNamespaces>
		<ImportedNamespace>System.Collections</ImportedNamespace>
		<ImportedNamespace>System.Diagnostics</ImportedNamespace>
		<ImportedNamespace>System.Text</ImportedNamespace>
		<ImportedNamespace>ActiproSoftware.Products.SyntaxEditor.Addons.DotNet</ImportedNamespace>
		<ImportedNamespace>ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast</ImportedNamespace>
	</ImportedNamespaces>
	<LexicalStates>
		<LexicalState>Default</LexicalState>
		<LexicalState>DocumentationComment</LexicalState>
		<LexicalState>PreProcessorDirective</LexicalState>
	</LexicalStates>
	<Tokens>
		<!-- NOTE: Any changes here need to be made to CSharpSyntaxLanguage.GetTokenString -->
		<Token>Invalid</Token>
		<Token>DocumentEnd</Token>
		<Token>LanguageTransitionStart</Token>
		<Token>LanguageTransitionEnd</Token>

		<Token IsSignificant="false">Whitespace</Token>
		<Token IsSignificant="false">LineTerminator</Token>

		<Token IsSignificant="false">SingleLineComment</Token>
		<Token IsSignificant="false">MultiLineComment</Token>
		
		<Token IsSignificant="false">DocumentationCommentDelimiter</Token>
		<Token IsSignificant="false">DocumentationCommentText</Token>
		<Token IsSignificant="false">DocumentationCommentTag</Token>
				
		<Token>DecimalIntegerLiteral</Token>
		<Token>HexadecimalIntegerLiteral</Token>
		<Token>RealLiteral</Token>

		<Token>CharacterLiteral</Token>
		<Token>StringLiteral</Token>
		<Token>VerbatimStringLiteral</Token>

		<Token>Identifier</Token>
		
		<Token IsSignificant="false">ContextualKeywordStart</Token>
		<Token>Ascending</Token>
		<Token>By</Token>
		<Token>Descending</Token>
		<Token>Equals</Token> 
		<Token>From</Token>
		<Token>Group</Token>
		<Token>Into</Token>
		<Token>Join</Token>
		<Token>Let</Token>
		<Token>On</Token>
		<Token>OrderBy</Token>
		<Token>Select</Token>
		<Token>Where</Token>
		<Token>Var</Token>
		<Token IsSignificant="false">ContextualKeywordEnd</Token>

		<Token IsSignificant="false">KeywordStart</Token>
		<Token>Abstract</Token>
		<Token>Add</Token>
		<Token>As</Token>
		<Token>Base</Token>
		<Token>Bool</Token>
		<Token>Break</Token>
		<Token>Byte</Token>
		<Token>Case</Token>
		<Token>Catch</Token>
		<Token>Char</Token>
		<Token>Checked</Token>
		<Token>Class</Token>
		<Token>Const</Token>
		<Token>Continue</Token>
		<Token>Decimal</Token>
		<Token>Default</Token>
		<Token>Delegate</Token>
		<Token>Do</Token>
		<Token>Double</Token>
		<Token>Dynamic</Token>
		<Token>Else</Token>
		<Token>Enum</Token> 
		<Token>Event</Token>
		<Token>Explicit</Token>
		<Token>Extern</Token>
		<Token>False</Token>
		<Token>Finally</Token>
		<Token>Fixed</Token>
		<Token>Float</Token>
		<Token>For</Token>
		<Token>ForEach</Token>
		<Token>Get</Token>
		<Token>Goto</Token>
		<Token>If</Token>
		<Token>Implicit</Token>
		<Token>In</Token>
		<Token>Int</Token>
		<Token>Interface</Token>
		<Token>Internal</Token>
		<Token>Is</Token>
		<Token>Lock</Token>
		<Token>Long</Token>
		<Token>Namespace</Token>
		<Token>New</Token>
		<Token>Null</Token>
		<Token>Object</Token>
		<Token>Operator</Token>
		<Token>Out</Token>
		<Token>Override</Token>
		<Token>Params</Token>
		<Token>Partial</Token>
		<Token>Private</Token>
		<Token>Protected</Token>
		<Token>Public</Token>
		<Token>ReadOnly</Token>
		<Token>Ref</Token>
		<Token>Remove</Token>
		<Token>Return</Token>
		<Token>SByte</Token>
		<Token>Sealed</Token>
		<Token>Set</Token>
		<Token>Short</Token>
		<Token>SizeOf</Token>
		<Token>StackAlloc</Token>
		<Token>Static</Token>
		<Token>String</Token>
		<Token>Struct</Token>
		<Token>Switch</Token>
		<Token>This</Token>
		<Token>Throw</Token>
		<Token>True</Token>
		<Token>Try</Token>
		<Token>TypeOf</Token>
		<Token>UInt</Token>
		<Token>ULong</Token>
		<Token>Unchecked</Token>
		<Token>Unsafe</Token>
		<Token>UShort</Token>
		<Token>Using</Token>
		<Token>Virtual</Token>
		<Token>Void</Token>
		<Token>Volatile</Token>
		<Token>While</Token>
		<Token>Yield</Token>
		<Token IsSignificant="false">KeywordEnd</Token>

		<Token IsSignificant="false">OperatorOrPunctuatorStart</Token>
		<Token>OpenCurlyBrace</Token>
		<Token>CloseCurlyBrace</Token>
		<Token>OpenSquareBrace</Token>
		<Token>CloseSquareBrace</Token>
		<Token>OpenParenthesis</Token>
		<Token>CloseParenthesis</Token>
		<Token>Dot</Token>
		<Token>Comma</Token>
		<Token>Colon</Token>
		<Token>NamespaceAliasQualifier</Token>
		<Token>SemiColon</Token>
		<Token>Addition</Token>
		<Token>Subtraction</Token>
		<Token>Multiplication</Token>
		<Token>Division</Token>
		<Token>Modulus</Token>
		<Token>BitwiseAnd</Token>
		<Token>BitwiseOr</Token>
		<Token>ExclusiveOr</Token>
		<Token>Negation</Token>
		<Token>OnesComplement</Token>
		<Token>Assignment</Token>
		<Token>LessThan</Token>
		<Token>GreaterThan</Token>
		<Token>QuestionMark</Token>
		<Token>Increment</Token>
		<Token>Decrement</Token>
		<Token>ConditionalAnd</Token>
		<Token>ConditionalOr</Token>
		<Token>LeftShift</Token>
		<Token>Equality</Token>
		<Token>Inequality</Token>
		<Token>LessThanOrEqual</Token>
		<Token>GreaterThanOrEqual</Token>
		<Token>AdditionAssignment</Token>
		<Token>SubtractionAssignment</Token>
		<Token>MultiplicationAssignment</Token>
		<Token>DivisionAssignment</Token>
		<Token>ModulusAssignment</Token>
		<Token>BitwiseAndAssignment</Token>
		<Token>BitwiseOrAssignment</Token>
		<Token>ExclusiveOrAssignment</Token>
		<Token>LeftShiftAssignment</Token>
		<Token>PointerDereference</Token>
		<Token>NullCoalescing</Token>
		<Token>Lambda</Token>
		<Token IsSignificant="false">OperatorOrPunctuatorEnd</Token>

		<Token IsSignificant="false">PreProcessorDirectiveKeywordStart</Token>
		<Token IsSignificant="false">IfPreProcessorDirective</Token>
		<Token IsSignificant="false">ElsePreProcessorDirective</Token>
		<Token IsSignificant="false">ElIfPreProcessorDirective</Token>
		<Token IsSignificant="false">EndIfPreProcessorDirective</Token>
		<Token IsSignificant="false">DefinePreProcessorDirective</Token>
		<Token IsSignificant="false">UndefPreProcessorDirective</Token>
		<Token IsSignificant="false">WarningPreProcessorDirective</Token>
		<Token IsSignificant="false">ErrorPreProcessorDirective</Token>
		<Token IsSignificant="false">LinePreProcessorDirective</Token>
		<Token IsSignificant="false">RegionPreProcessorDirective</Token>
		<Token IsSignificant="false">EndRegionPreProcessorDirective</Token>
		<Token IsSignificant="false">PragmaPreProcessorDirective</Token>
		<Token IsSignificant="false">PreProcessorDirectiveKeywordEnd</Token>
		
		<Token IsSignificant="false">PreProcessorDirectiveText</Token>

		<Token>MaxTokenID</Token>		
	</Tokens>
	<Declarations><![CDATA[
		
		private Stack			blockStack;
		private CompilationUnit	compilationUnit;
		private int				curlyBraceLevel;
		private StringBuilder	identifierStringBuilder = new StringBuilder();

		/// <summary>
		/// Initializes a new instance of the <c>CSharpSemanticParser</c> class.
		/// </summary>
		/// <param name="lexicalParser">The <see cref="ActiproSoftware.SyntaxEditor.ParserGenerator.IRecursiveDescentLexicalParser"/> to use for lexical parsing.</param>
		public CSharpSemanticParser(ActiproSoftware.SyntaxEditor.ParserGenerator.IRecursiveDescentLexicalParser lexicalParser) : base(lexicalParser) {}
	
		/// <summary>
		/// Advances to the next <see cref="IToken"/>.
		/// </summary>
		/// <returns>
		/// The <see cref="IToken"/> that was read.
		/// </returns>
		protected override IToken AdvanceToNext() {
			IToken token = base.AdvanceToNext();
			if (!this.TokenIsLanguageChange(token)) {
				switch (token.ID) {
					case CSharpTokenID.OpenCurlyBrace:
						curlyBraceLevel++;
						break;
					case CSharpTokenID.CloseCurlyBrace:
						curlyBraceLevel--;
						break;
				}
			}
			return token;
		}

		/// <summary>
		/// Advances to (or past) the next matching close curly brace.
		/// </summary>
		/// <param name="openCurlyBraceLevel">The level of the open curly brace.</param>	
		/// <param name="movePast">Whether to move past the close curly brace.</param>
		private void AdvanceToNextCloseCurlyBrace(int openCurlyBraceLevel, bool movePast) {
			while (!this.IsAtEnd) {
				this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace, CSharpTokenID.CloseCurlyBrace); 
				if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel <= openCurlyBraceLevel + 1))
					break;
				this.AdvanceToNext();
			}			
			if ((movePast) && (this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)))
				this.AdvanceToNext();
		}
	
		/// <summary>
		/// Returns whether the next two <see cref="IToken"/> objects match the specified IDs.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the next two <see cref="IToken"/> objects match the specified IDs; otherwise, <c>false</c>.
		/// </returns>
		private bool AreNextTwo(int firstTokenID, int secondTokenID) {
			return (this.TokenIs(this.LookAheadToken, firstTokenID)) && (this.TokenIs(this.GetLookAheadToken(2), secondTokenID));
		}
		
		/// <summary>
		/// Returns whether the next two <see cref="IToken"/> objects match an identifier and the specified ID.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the next two <see cref="IToken"/> objects match an identifier and the specified ID; otherwise, <c>false</c>.
		/// </returns>
		private bool AreNextTwoIdentifierAnd(int secondTokenID) {
			return (this.IsIdentifier(this.LookAheadToken)) && 
				this.TokenIs(this.GetLookAheadToken(2), secondTokenID);
		}
		
		/// <summary>
		/// Adds a child node to the current block.
		/// </summary>
		/// <param name="node">The <see cref="AstNode"/> to add to the current block.</param>
		private void BlockAddChild(AstNode node) {
			// If the node is a type declaration, add it to the Types list
			if (node is TypeDeclaration) 
				compilationUnit.Types.Add(node);
		
			if (blockStack.Count == 0) {
				// Compilation unit
				if ((node is NamespaceDeclaration) || (node is TypeDeclaration)) {
					compilationUnit.NamespaceMembers.Add(node);
					return;
				}
			}
			else {
				AstNode currentBlock = (AstNode)blockStack.Peek();
				if (currentBlock is NamespaceDeclaration) {
					if ((node is NamespaceDeclaration) || (node is TypeDeclaration)) {
						((NamespaceDeclaration)currentBlock).NamespaceMembers.Add(node);
						return;
					}
				}
				else if (currentBlock is TypeDeclaration) {
					if (node is TypeMemberDeclaration) {
						((TypeDeclaration)currentBlock).Members.Add(node);
						return;
					}
				}
			}
			
			// 12/29/2009 (14A-12CCDF57-DE29) - throw new NotSupportedException();
		}

		/// <summary>
		/// Starts a block and pushes it on the block stack.
		/// </summary>
		/// <param name="node">The <see cref="AstNode"/> that is starting a block.</param>
		private void BlockStart(AstNode node) {
			blockStack.Push(node);
		}

		/// <summary>
		/// Ends the current block and pops it from the block stack.
		/// </summary>
		private void BlockEnd() {
			blockStack.Pop();
		}
		
		/// <summary>
		/// Gets the <see cref="CompilationUnit"/> that was parsed.
		/// </summary>
		/// <value>The <see cref="CompilationUnit"/> that was parsed.</value>
		public CompilationUnit CompilationUnit {
			get {
				return compilationUnit;
			}
		}
		
		/// <summary>
		/// Returns an inferred <see cref="TypeReference"/> for the return type of the specified <see cref="Expression"/> initializer.
		/// </summary>
		/// <param name="initializer">The <see cref="Expression"/> to examine.</param>
		/// <param name="allowNull">Whether to allow a null initializer.</param>
		/// <returns>An inferred <see cref="TypeReference"/> for the return type of the specified <see cref="Expression"/> initializer.</returns>
		private TypeReference GetImplicitType(Expression initializer, bool allowNull) {
			if (initializer == null) {
				this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ImplicitlyTypedVariableDeclarationNoInitializer"));
				return null;
			}
			
			// NOTE: GetReturnType is not currently looking backwards to resolve SimpleName references, thus foreach use of var will
			//		 reflect System.Object most of the time
			
			// Try and determine what the type reference is from the initializer
			TypeReference typeReference = this.GetReturnType(initializer);
			
			// Clone the type reference
			if (typeReference != null)
				typeReference = typeReference.Clone();
			
			// TODO: Need to ensure that a collection initializer is not passed.
			
			if ((!allowNull) && (typeReference == null))
				this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ImplicitlyTypedVariableDeclarationNullInitializer"));
				
			return typeReference;
		}
		
		/// <summary>
		/// Returns an inferred <see cref="TypeReference"/> for the return type of the specified <see cref="Expression"/>.
		/// </summary>
		/// <param name="expression">The <see cref="Expression"/> to examine.</param>
		/// <returns>An inferred <see cref="TypeReference"/> for the return type of the specified <see cref="Expression"/>.</returns>
		private TypeReference GetReturnType(Expression expression) {
			if (expression is LiteralExpression) {
				switch (((LiteralExpression)expression).LiteralType) {
					case LiteralType.True:
					case LiteralType.False:
						return new TypeReference("System.Boolean", expression.TextRange);
					case LiteralType.DecimalInteger:
					case LiteralType.HexadecimalInteger:
					case LiteralType.OctalInteger:
						return new TypeReference("System.Int32", expression.TextRange);
					case LiteralType.Real:
						return new TypeReference("System.Double", expression.TextRange);
					case LiteralType.Character:
						return new TypeReference("System.Char", expression.TextRange);
					case LiteralType.String:
					case LiteralType.VerbatimString:
						return new TypeReference("System.String", expression.TextRange);
					case LiteralType.Date:
						return new TypeReference("System.DateTime", expression.TextRange);
					case LiteralType.Null:
						return null;
				}
			}
			else if (expression is CastExpression)
				return ((CastExpression)expression).ReturnType;
			else if (expression is DefaultValueExpression)
				return ((DefaultValueExpression)expression).ReturnType;
			else if (expression is ObjectCreationExpression)
				return ((ObjectCreationExpression)expression).ObjectType;
			else if (expression is ParenthesizedExpression)
				return this.GetReturnType(((ParenthesizedExpression)expression).Expression);
			else if (expression is SizeOfExpression)
				return new TypeReference("System.Int32", expression.TextRange);
			else if (expression is TryCastExpression)
				return ((TryCastExpression)expression).ReturnType;
			else if (expression is TypeOfExpression)
				return new TypeReference("System.Type", expression.TextRange);
			else if (expression is TypeReferenceExpression)
				return ((TypeReferenceExpression)expression).TypeReference;
				
			// No type could be found within the initializer
			return new TypeReference("System.Object", expression.TextRange);
		}
	
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is an array with rank specifiers.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is an array with rank specifiers; otherwise, <c>false</c>.
		/// </returns>
		private bool IsArrayRankSpecifiers() {
			if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.OpenSquareBrace))
				return false;
			IToken token = this.GetLookAheadToken(2);
			if (!this.TokenIsLanguageChange(token)) {
				switch (token.ID) {
					case CSharpTokenID.Comma:
					case CSharpTokenID.CloseSquareBrace:
						return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is a comma followed by an identifier.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is a comma followed by an identifier; otherwise, <c>false</c>.
		/// </returns>
		private bool IsCommaAndIdentifier() {
			return (this.TokenIs(this.LookAheadToken, CSharpTokenID.Comma)) && (this.IsIdentifier(this.GetLookAheadToken(2)));
		}

		/// <summary>
		/// Returns whether the specified <see cref="IToken"/> is a contextual keyword.
		/// </summary>
		/// <param name="token">The <see cref="IToken"/> to examine.</param>
		/// <returns>
		/// <c>true</c> if the specified <see cref="IToken"/> is a Contextual keyword; otherwise, <c>false</c>.
		/// </returns>
		private bool IsContextualKeyword(IToken token) {
			if ((token.ID > CSharpTokenID.ContextualKeywordStart) && (token.ID < CSharpTokenID.ContextualKeywordEnd)) {
				// Double check for language change
				if (this.TokenIs(token, token.ID))
					return true;					
			}
			return false;
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a default value expression.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a default value expression; otherwise, <c>false</c>.
		/// </returns>
		private bool IsDefaultValueExpression() {
			return (this.TokenIs(this.LookAheadToken, CSharpTokenID.Default)) && (this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.OpenParenthesis));
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is a qualifier identifier continuation.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is a qualifier identifier continuation; otherwise, <c>false</c>.
		/// </returns>
		private bool IsGlobalAttributeSection() {
			if (this.TokenIs(this.LookAheadToken, CSharpTokenID.OpenSquareBrace)) {
				IToken targetToken = this.GetLookAheadToken(2);
				return ((this.TokenIs(targetToken, CSharpTokenID.Identifier)) && (this.IsValidGlobalAttributeSectionTarget(this.GetTokenText(targetToken))));
			}
			else
				return false;
		}
		
		/// <summary>
		/// Returns whether the specified <see cref="IToken"/> is an identifier (or contextual keyword).
		/// </summary>
		/// <param name="token">The <see cref="IToken"/> to examine.</param>
		/// <returns>
		/// <c>true</c> if the specified <see cref="IToken"/> is an identifier (or contextual keyword); otherwise, <c>false</c>.
		/// </returns>
		private bool IsIdentifier(IToken token) {
			return (this.TokenIs(token, CSharpTokenID.Identifier)) ||
				(this.IsContextualKeyword(token));
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is an implicitly typed lambda parameter list.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is an implicitly typed lambda parameter list; otherwise, <c>false</c>.
		/// </returns>
		private bool IsImplicitlyTypedLambdaParameterList() {
			if (this.IsIdentifier(this.LookAheadToken)) {
				IToken targetToken = this.GetLookAheadToken(2);
				return ((this.TokenIs(targetToken, CSharpTokenID.Comma)) || (this.TokenIs(targetToken, CSharpTokenID.CloseParenthesis)));
			}
			else
				return false;
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a lambda expression.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a lambda expression; otherwise, <c>false</c>.
		/// </returns>
		private bool IsLambdaExpression() {
			if (this.IsIdentifier(this.LookAheadToken)) {
				// Simple case... check the next token for a Lambda
				return this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.Lambda);
			}
			else if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.OpenParenthesis))
				return false;
			
			// More difficult case... look for a Lambda after a parenthesis set
			this.StartPeek();
			try {
				this.Peek();  // Skip the open parenthesis
				while (!this.IsAtEnd) {						
					if (this.TokenIsLanguageChange(this.PeekToken))
						return false;
					switch (this.PeekToken.ID) {
						// Parameter modifiers
						case CSharpTokenID.Out:
						case CSharpTokenID.Ref:
						// Native types
						case CSharpTokenID.Bool:
						case CSharpTokenID.Decimal:
						case CSharpTokenID.SByte:
						case CSharpTokenID.Byte:
						case CSharpTokenID.Short:
						case CSharpTokenID.UShort:
						case CSharpTokenID.Int:
						case CSharpTokenID.UInt:
						case CSharpTokenID.Long:
						case CSharpTokenID.ULong:
						case CSharpTokenID.Char:
						case CSharpTokenID.Float:
						case CSharpTokenID.Double:
						case CSharpTokenID.Object:
						case CSharpTokenID.String:
						case CSharpTokenID.Dynamic:
						// Other
						case CSharpTokenID.Comma:
						case CSharpTokenID.Dot:
						case CSharpTokenID.LessThan:
						case CSharpTokenID.GreaterThan:
						case CSharpTokenID.OpenSquareBrace:
						case CSharpTokenID.CloseSquareBrace:
						case CSharpTokenID.QuestionMark:
						case CSharpTokenID.Multiplication:
							// Allowed token... continue on
							this.Peek();
							break;
						case CSharpTokenID.CloseParenthesis:
							// Return whether the next token is a Lambda
							this.Peek();
							return this.TokenIs(this.PeekToken, CSharpTokenID.Lambda);							
						default:
							if (this.IsIdentifier(this.PeekToken)) {
								// Allowed token... continue on
								this.Peek();
								break;
							}						
							return false;
					}
				}
				return false;
			}
			finally {
				this.StopPeek();
			}
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is a keyword.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is a keyword; otherwise, <c>false</c>.
		/// </returns>
		private bool IsKeyword() {
			return this.IsKeyword(this.LookAheadToken);
		}
		
		/// <summary>
		/// Returns whether the specified <see cref="IToken"/> is a keyword.
		/// </summary>
		/// <param name="token">The <see cref="IToken"/> to examine.</param>
		/// <returns>
		/// <c>true</c> if the specified <see cref="IToken"/> is a keyword; otherwise, <c>false</c>.
		/// </returns>
		private bool IsKeyword(IToken token) {
			if ((token.ID > CSharpTokenID.KeywordStart) && (token.ID < CSharpTokenID.KeywordEnd)) {
				// Double check for language change
				if (this.TokenIs(token, token.ID))
					return true;					
			}
			return false;
		}
	
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is a keyword or an identifier followed by a colon.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is a keyword or an identifier followed by a colon; otherwise, <c>false</c>.
		/// </returns>
		private bool IsKeywordOrIdentifierAndColon() {
			return ((this.IsIdentifier(this.LookAheadToken)) || (this.IsKeyword())) && 
				(this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.Colon));
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of an object initializer.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of an object initializer; otherwise, <c>false</c>.
		/// </returns>
		private bool IsObjectInitializer() {
			if (this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace))  // Empty object initializer
				return true;
			else if ((this.IsIdentifier(this.LookAheadToken)) && (this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.Assignment)))
				return true;
			else
				return false;
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a parameter array.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a parameter array; otherwise, <c>false</c>.
		/// </returns>
		private bool IsParameterArray() {
			return (this.TokenIs(this.LookAheadToken, CSharpTokenID.Comma)) && (this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.Params));
		}
	
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a query expression.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a query expression; otherwise, <c>false</c>.
		/// </returns>
		private bool IsQueryExpression() {
			if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.From))
				return false;
				
			this.StartPeek();
			try {
				this.Peek();  // Skip the From
				return this.IsType();
			}
			finally {
				this.StopPeek();
			}
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is a qualifier identifier continuation.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is a qualifier identifier continuation; otherwise, <c>false</c>.
		/// </returns>
		private bool IsQualifierIdentifierContinuation() {
			return (this.TokenIs(this.LookAheadToken, CSharpTokenID.Dot)) && (this.IsIdentifier(this.GetLookAheadToken(2)));
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a right shift.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a right shift; otherwise, <c>false</c>.
		/// </returns>
		private bool IsRightShift() {
			return (this.TokenIs(this.LookAheadToken, CSharpTokenID.GreaterThan)) && (this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.GreaterThan));
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a right shift.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a right shift; otherwise, <c>false</c>.
		/// </returns>
		private bool IsRightShiftAssignment() {
			return (this.TokenIs(this.LookAheadToken, CSharpTokenID.GreaterThan)) && (this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.GreaterThanOrEqual));
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a type.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a type; otherwise, <c>false</c>.
		/// </returns>
		/// <remarks>
		/// This method can only be called after a peek operation has started.
		/// Types have this syntax: (Identifier "::")? (Identifier ("." Identifier)* | NativeType) ("&lt;" Type "&gt;")? ("?")? ("[" "]")?
		/// </remarks>
		private bool IsType() {
			if (!this.IsTypeCore())
				return false;
		
			// Skip over a type argument list
			while (this.IsTypeArgumentList()) {
				int level = 0;
				while (!this.IsAtEnd) {
					if (this.TokenIsLanguageChange(this.PeekToken))
						return false;
					switch (this.PeekToken.ID) {
						case CSharpTokenID.LessThan:
							level++;
							break;
						case CSharpTokenID.GreaterThan:
							level--;
							break;
					}
					this.Peek();				
					if (level <= 0)
						break;
				}
				
				if (this.TokenIs(this.PeekToken, CSharpTokenID.Dot)) {
					this.Peek();  // Skip over dot
					if (!this.IsTypeCore())
						return false;
				}
				else 
					break;
			}
			
			// Skip over a nullable type
			if (this.TokenIs(this.PeekToken, CSharpTokenID.QuestionMark))
				this.Peek();
			
			// Skip over the array ranks if any
			while (this.TokenIs(this.PeekToken, CSharpTokenID.OpenSquareBrace)) {
				this.Peek();
				bool exitLoop = false;
				while (!this.IsAtEnd) {						
					if (this.TokenIsLanguageChange(this.PeekToken))
						return false;
					switch (this.PeekToken.ID) {
						case CSharpTokenID.Comma:
							this.Peek();
							break;
						case CSharpTokenID.CloseSquareBrace:
							this.Peek();
							exitLoop = true;
							break;
						default:
							return false;
					}
					if (exitLoop)
						break;
				}
			}
			
			// Skip over pointers if any
			while (this.TokenIs(this.PeekToken, CSharpTokenID.Multiplication))
				this.Peek();
			
			return true;
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a type.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a type; otherwise, <c>false</c>.
		/// </returns>
		/// <remarks>
		/// This method can only be called from <see cref="IsType"/>.
		/// </remarks>
		private bool IsTypeCore() {
			IToken token = this.Peek();
			if (this.TokenIsLanguageChange(token))
				return false;			
			switch (token.ID) {
				case CSharpTokenID.Bool:
				case CSharpTokenID.Decimal:
				case CSharpTokenID.SByte:
				case CSharpTokenID.Byte:
				case CSharpTokenID.Short:
				case CSharpTokenID.UShort:
				case CSharpTokenID.Int:
				case CSharpTokenID.UInt:
				case CSharpTokenID.Long:
				case CSharpTokenID.ULong:
				case CSharpTokenID.Char:
				case CSharpTokenID.Float:
				case CSharpTokenID.Double:
				case CSharpTokenID.Object:
				case CSharpTokenID.String:
				case CSharpTokenID.Dynamic:
					break;
				case CSharpTokenID.Void:
					if (this.TokenIs(this.PeekToken, CSharpTokenID.Multiplication)) {
						this.Peek();
						return true;
					}
					else
						return false;
				default:
					if (this.IsIdentifier(token)) {
						// Skip over the qualified identifier
						bool exitLoop = false;
						bool nextIsDot = true;
						while (!this.IsAtEnd) {						
							if (this.TokenIsLanguageChange(this.PeekToken))
								return false;
							switch (this.PeekToken.ID) {
								case CSharpTokenID.Dot:
									if (!nextIsDot) {
										exitLoop = true;
										break;
									}
									this.Peek();
									nextIsDot = false;
									break;
								case CSharpTokenID.NamespaceAliasQualifier:
									this.Peek();
									if (!this.IsIdentifier(this.PeekToken))
										return false;
									nextIsDot = false;
									break;
								case CSharpTokenID.LessThan:
								case CSharpTokenID.QuestionMark:
								case CSharpTokenID.OpenSquareBrace:
								case CSharpTokenID.CloseParenthesis:
								case CSharpTokenID.Multiplication:
									exitLoop = true;
									break;
								default:
									if (this.IsIdentifier(this.PeekToken)) {
										if (nextIsDot) {
											exitLoop = true;
											break;
										}
										this.Peek();
										nextIsDot = true;
										break;
									}
									exitLoop = true;
									break;
							}
							if (exitLoop)
								break;
						}
						break;
					}
					return false;
			}

			return true;
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a type argument list.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a type argument list; otherwise, <c>false</c>.
		/// </returns>
		private bool IsTypeArgumentList() {
			if (!this.TokenIs((this.PeekToken != null ? this.PeekToken : this.LookAheadToken), CSharpTokenID.LessThan))
				return false;
				
			this.StartPeek();
			try {
				int level = 0;
				while (!this.IsAtEnd) {
					if (this.TokenIsLanguageChange(this.PeekToken))
						return false;
					switch (this.PeekToken.ID) {
						case CSharpTokenID.LessThan:
							level++;
							break;
						case CSharpTokenID.GreaterThan:
							level--;
							break;
						case CSharpTokenID.Comma:
						case CSharpTokenID.Dot:
						case CSharpTokenID.OpenSquareBrace:
						case CSharpTokenID.CloseSquareBrace:
						case CSharpTokenID.QuestionMark:
							// Continue
							break;
						default:
							if (CSharpToken.IsNativeType(this.PeekToken.ID)) {
								// Continue
								break;
							}
							else if (this.IsIdentifier(this.PeekToken)) {
								// Continue
								break;
							}
							return false;
					}
					if (level <= 0)
						break;
					this.Peek();				
				}
				this.Peek();				
				if (this.TokenIsLanguageChange(this.PeekToken))
					return false;
				switch (this.PeekToken.ID) {
					case CSharpTokenID.OpenParenthesis:
					case CSharpTokenID.CloseParenthesis:
					case CSharpTokenID.OpenSquareBrace:
					case CSharpTokenID.CloseSquareBrace:
					case CSharpTokenID.OpenCurlyBrace:
					case CSharpTokenID.GreaterThan:
					case CSharpTokenID.Colon:
					case CSharpTokenID.SemiColon:
					case CSharpTokenID.Comma:
					case CSharpTokenID.QuestionMark:
					case CSharpTokenID.Equality:
					case CSharpTokenID.Inequality:
					case CSharpTokenID.Operator:
					case CSharpTokenID.This:
						return true;
					case CSharpTokenID.Dot:
						this.Peek();
						return true;
					default:
						return this.IsIdentifier(this.PeekToken) || ((this.PeekToken.ID > CSharpTokenID.Addition) && (this.PeekToken.ID < CSharpTokenID.OperatorOrPunctuatorEnd));
				}
			}
			finally {
				this.StopPeek();
			}
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a type cast.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a type cast; otherwise, <c>false</c>.
		/// </returns>
		private bool IsTypeCast() {
			if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.OpenParenthesis))
				return false;
				
			this.StartPeek();
			try {
				this.Peek();  // Skip the open parenthesis
				if (!this.IsType())
					return false;
				if (!this.TokenIs(this.Peek(), CSharpTokenID.CloseParenthesis))
					return false;
				return (IsNonTerminal("UnaryExpression", "this.PeekToken"));
			}
			finally {
				this.StopPeek();
			}
		}

		/// <summary>
		/// Returns whether the target specification is a valid global attribute section target.
		/// </summary>
		/// <param name="target">The target specification to examine.</param>
		/// <returns>
		/// <c>true</c> if the target specification is a valid global attribute section target; otherwise, <c>false</c>.
		/// </returns>
		private bool IsValidGlobalAttributeSectionTarget(string target) {
			switch (target) {
				case "assembly":
				case "module":
					return true;
				default:
					return false;
			}
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a variable declaration.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a variable declaration; otherwise, <c>false</c>.
		/// </returns>
		private bool IsVariableDeclaration() {
			this.StartPeek();
			try {
				if (this.TokenIs(this.PeekToken, CSharpTokenID.Var)) {
					// Skip over 'var'
					this.Peek();
				}
				else if (!this.IsType())
					return false;

				return (this.IsIdentifier(this.PeekToken));
			}
			finally {
				this.StopPeek();
			}
		}

		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a variable declarator.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a variable declarator; otherwise, <c>false</c>.
		/// </returns>
		private bool IsVariableDeclarator() {
			if (this.IsIdentifier(this.LookAheadToken)) {
				IToken token = this.GetLookAheadToken(2);
				if (!this.TokenIsLanguageChange(token)) {
					switch (token.ID) {
						case CSharpTokenID.Assignment:
						case CSharpTokenID.Comma:
						case CSharpTokenID.SemiColon:
							return true;
					}
				}
			}
			return false;
		}
		
		/// <summary>
		/// Flags any generic parameters that are located.
		/// </summary>
		/// <param name="typeParameterList">The list of type parameters that are defined.</param>
		/// <param name="typeReference">The <see cref="TypeReference"/> to examine.</param>
		/// <param name="allowTopLevelMark">Whether to allow the type reference to be marked.</param>
		private void MarkGenericParameters(IAstNodeList typeParameterList, TypeReference typeReference, bool allowTopLevelMark) {
			if ((typeParameterList == null) || (typeReference == null))
				return;

			if (allowTopLevelMark) {
				// Look for a match on the specified type reference
				foreach (TypeReference declaredTypeParameter in typeParameterList) {
					if (declaredTypeParameter.Name == typeReference.Name) {
						typeReference.IsGenericParameter = true;
						return;
					}
				}
			}

			// Recurse
			if (typeReference.GenericTypeArguments != null) {
				foreach (TypeReference genericTypeArgument in typeReference.GenericTypeArguments)
					this.MarkGenericParameters(typeParameterList, genericTypeArgument, true);
			}
		}
		
		/// <summary>
		/// Parses the code and returns the list of arguments that were parsed.
		/// </summary>
		/// <returns>
		/// An <see cref="IAstNodeList" /> containing the list of arguments that were parsed.
		/// </returns>
		internal IAstNodeList ParseArgumentList() {
			// Initialize
			blockStack = new Stack();
			compilationUnit = new CompilationUnit();
			compilationUnit.SourceLanguage = DotNetLanguage.CSharp;
			compilationUnit.StartOffset = this.LookAheadToken.StartOffset;

			// Match argument list		
			AstNodeList argumentList = new AstNodeList(null);
			this.MatchArgumentList(out argumentList);
			
			// Finalize
			compilationUnit.EndOffset = this.LookAheadToken.EndOffset;
			
			return argumentList;
		}

		/// <summary>
		/// Reaps the comments that have been collected since the last reaping and adds them to an <see cref="IAstNodeList"/>.
		/// </summary>
		/// <param name="nodes">The <see cref="IAstNodeList"/> that should receive any reaped comment nodes.</param>
		/// <param name="sort">Whether to sort the sibling nodes.</param>
		private void ReapComments(IAstNodeList nodes, bool sort) {
			if (this.LexicalParser is CSharpRecursiveDescentLexicalParser) {
				Comment[] comments = ((CSharpRecursiveDescentLexicalParser)this.LexicalParser).ReapComments(nodes.ParentNode.TextRange);
				if (comments != null) {
					foreach (Comment comment in comments)
						nodes.Add(comment);
					if (sort)
						nodes.ParentNode.ChildNodes.SortByStartOffset();
				}
			}
		}

		/// <summary>
		/// Reaps the documentation comments that have been collected since the last reaping.
		/// </summary>
		/// <returns>The documentation comments that have been collection since the last reaping.</returns>
		private string ReapDocumentationComments() {
			if (this.LexicalParser is CSharpRecursiveDescentLexicalParser)
				return ((CSharpRecursiveDescentLexicalParser)this.LexicalParser).ReapDocumentationComments();
			else
				return null;
		}

		/// <summary>
		/// Reports a syntax error.
		/// </summary>
		/// <param name="textRange">The <see cref="TextRange"/> of the error.</param>
		/// <param name="message">The error message.</param>
		protected override void ReportSyntaxError(TextRange textRange, string message) {
			// Don't allow multiple errors at the same offset
			if ((compilationUnit.SyntaxErrors.Count > 0) && (((SyntaxError)compilationUnit.SyntaxErrors[compilationUnit.SyntaxErrors.Count - 1]).TextRange.StartOffset == textRange.StartOffset))
				return;
			
			compilationUnit.SyntaxErrors.Add(new SyntaxError(textRange, message));
		}
		
	]]></Declarations>
	<NonTerminals>
	
		<!-- C.2.1 Basic concepts -->
		<NonTerminal Key="NamespaceName" Parameters="out QualifiedIdentifier namespaceName">
			<Production><![CDATA[				
				"QualifiedIdentifier<@ out namespaceName @>"
				[
					'NamespaceAliasQualifier'
					<%
						string alias = namespaceName.Text;
					%>
					"QualifiedIdentifier<@ out namespaceName @><+ namespaceName.Text = alias + "." + namespaceName.Text; +>"
				]
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="TypeName" Parameters="bool unboundTypeArguments, out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
					QualifiedIdentifier identifier;
					AstNodeList typeArgumentList = null;
				%>
				"QualifiedIdentifier<@ out identifier @>"
				[
					'NamespaceAliasQualifier<- ->'
					<%
						string alias = identifier.Text;
					%>
					"QualifiedIdentifier<@ out identifier @><+ identifier.Text = alias + "." + identifier.Text; +>"
				]
				<% 
					while (this.IsTypeArgumentList()) {					
						if ((unboundTypeArguments) && ((this.AreNextTwo(CSharpTokenID.LessThan, CSharpTokenID.Comma)) || (this.AreNextTwo(CSharpTokenID.LessThan, CSharpTokenID.GreaterThan)))) {
					%>
							[
								'LessThan'
								{ 'Comma' }
								'GreaterThan'
							]
					<%
						}
						else {
					%>
							[ "TypeArgumentList<@ out typeArgumentList @>" ]
					<%
						}
						
						QualifiedIdentifier nextIdentifier;						
					%>
					
						[<? this.IsQualifierIdentifierContinuation() ?>
							'Dot'
							"QualifiedIdentifier<@ out nextIdentifier @><+ identifier.Text += "." + nextIdentifier.Text; +>"
							<%
								// Clear the type argument list since the target type has changed
								typeArgumentList = null;								
							%>
						]
				<%
					}
					
					// Create the type reference
					typeReference = new TypeReference(identifier.Text, identifier.TextRange);
					if (typeArgumentList != null)
						typeReference.GenericTypeArguments.AddRange(typeArgumentList.ToArray());
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: NamespaceOrTypeName combined into TypeName -->

		<!-- C.2.2 Types -->
		<NonTerminal Key="Type" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				"TypeCore<@ false, false, out typeReference @>"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="TypeCore" Parameters="bool unboundTypeArguments, bool useExtendedNullableTypeCheck, out TypeReference typeReference">
			<Production><![CDATA[
				<%
					int[] arrayRanks;
				%>
				"NonArrayType<@ unboundTypeArguments, useExtendedNullableTypeCheck, out typeReference @>"
				"RankSpecifier<@ out arrayRanks @><+ typeReference.ArrayRanks = arrayRanks; +>"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ValueType merged with Type to avoid infinite recursion -->
		<!-- NOTE: StructType merged with Type to avoid infinite recursion -->
		<NonTerminal Key="SimpleType" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				"NumericType<@ out typeReference @>"
				| 'Bool<+ typeReference = new TypeReference("System.Boolean", this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NumericType" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				"IntegralType<@ out typeReference @>"
				| "FloatingPointType<@ out typeReference @>"
				| 'Decimal<+ typeReference = new TypeReference("System.Decimal", this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="IntegralType" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				'SByte<+ typeReference = new TypeReference("System.SByte", this.Token.TextRange); +>'
				| 'Byte<+ typeReference = new TypeReference("System.Byte", this.Token.TextRange); +>'
				| 'Short<+ typeReference = new TypeReference("System.Int16", this.Token.TextRange); +>'
				| 'UShort<+ typeReference = new TypeReference("System.UInt16", this.Token.TextRange); +>'
				| 'Int<+ typeReference = new TypeReference("System.Int32", this.Token.TextRange); +>'
				| 'UInt<+ typeReference = new TypeReference("System.UInt32", this.Token.TextRange); +>'
				| 'Long<+ typeReference = new TypeReference("System.Int64", this.Token.TextRange); +>'
				| 'ULong<+ typeReference = new TypeReference("System.UInt64", this.Token.TextRange); +>'
				| 'Char<+ typeReference = new TypeReference("System.Char", this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="FloatingPointType" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				'Float<+ typeReference = new TypeReference("System.Single", this.Token.TextRange); +>'
				| 'Double<+ typeReference = new TypeReference("System.Double", this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: EnumType merged with Type to avoid infinite recursion -->
		<!-- NOTE: ReferenceType merged with Type to avoid infinite recursion -->
		<NonTerminal Key="ClassType" Parameters="bool unboundTypeArguments, out TypeReference typeReference">
			<!-- NOTE: ClassType handles all reference types to avoid infinite recursion -->
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				"TypeName<@ unboundTypeArguments, out typeReference @>"
				| 'Object<+ typeReference = new TypeReference("System.Object", this.Token.TextRange); +>'
				| 'String<+ typeReference = new TypeReference("System.String", this.Token.TextRange); +>'
				| 'Dynamic<+ typeReference = new TypeReference("System.Object", this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: InterfaceType merged with Type to avoid infinite recursion -->
		<!-- NOTE: ArrayType merged with Type to avoid infinite recursion -->
		<NonTerminal Key="NonArrayType" Parameters="bool unboundTypeArguments, bool useExtendedNullableTypeCheck, out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				(
					"ClassType<@ unboundTypeArguments, out typeReference @>"
					| "SimpleType<@ out typeReference @>"
					| (
						<%
							int startOffset = this.LookAheadToken.StartOffset;
						%>
						'Void'
						'Multiplication'
						<%
							typeReference = new TypeReference("System.Void", new TextRange(startOffset, this.Token.EndOffset));
							typeReference.PointerLevel = 1;
						%>
					)
				)
				[<? 
					(this.TokenIs(this.LookAheadToken, CSharpTokenID.QuestionMark)) && (typeReference.EndOffset == this.LookAheadToken.StartOffset) &&
					(
						(!useExtendedNullableTypeCheck) ||
						(Array.IndexOf(new int[] { CSharpTokenID.SemiColon, CSharpTokenID.Comma, CSharpTokenID.CloseParenthesis, CSharpTokenID.OpenSquareBrace, CSharpTokenID.Colon }, this.GetLookAheadToken(2).ID) != -1)
					)
					?>
					'QuestionMark'
					<%
						TypeReference nullableTypeReference = typeReference;
						typeReference = new TypeReference("System.Nullable", new TextRange(nullableTypeReference.StartOffset, this.Token.EndOffset));
						typeReference.GenericTypeArguments.Add(nullableTypeReference);
					%>
				]
				{
					'Multiplication'
					<%
						typeReference.PointerLevel++;
						typeReference.EndOffset = this.Token.EndOffset;
					%>
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: RankSpecifiers merged with callers of RankSpecifiers -->
		<NonTerminal Key="RankSpecifier" Parameters="out int[] ranks">
			<Production><![CDATA[
				<%
					ranks = null;
					ArrayList rankList = new ArrayList();
					int rank = 0;
				%>
				{
					'OpenSquareBrace<+ rank = 1; +>'
					{ 'Comma<+ rank++; +>' }
					'CloseSquareBrace<+ rankList.Add(rank); +>'
				}
				<%
					if (rankList.Count > 0) {
						ranks = new int[rankList.Count];
						rankList.CopyTo(ranks, 0);
					}
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: DimSeparators merged with RankSpecifiers -->
		<!-- NOTE: DelegateType merged with Type to avoid infinite recursion -->

		<!-- C.2.3 Variables -->
		<!-- NOTE: VariableReference simply uses Expression since the code is really all the same -->
		
		<!-- C.2.4 Expressions -->
		<NonTerminal Key="ArgumentList" Parameters="out AstNodeList initializerArgumentList">
			<Production><![CDATA[
				<%
					initializerArgumentList = new AstNodeList(null);	
					Expression expression;					
				%>
				"Argument<@ out expression @><+ initializerArgumentList.Add(expression); +><- this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ArgumentExpected")); return false; ->"
				{ 'Comma' "Argument<@ out expression @><+ initializerArgumentList.Add(expression); +><- this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ArgumentExpected")); return true; ->" }
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Argument" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					QualifiedIdentifier name = null;
					expression = null;
					int startOffset = this.LookAheadToken.StartOffset;
					if (this.AreNextTwoIdentifierAnd(CSharpTokenID.Colon)) {
						// C# 4.0 named argument
						name = new QualifiedIdentifier(this.LookAheadTokenText, this.LookAheadToken.TextRange); 
						this.AdvanceToNext();
						this.AdvanceToNext();
					}
				%>
				"Expression<@ out expression @><+ expression = new ArgumentExpression(ParameterModifiers.None, name, expression, expression.TextRange); +>"
				| ( 'Ref' "Expression<@ out expression @><+ expression = new ArgumentExpression(ParameterModifiers.Ref, name, expression, new TextRange(startOffset, this.Token.EndOffset)); +>" )
				| ( 'Out' "Expression<@ out expression @><+ expression = new ArgumentExpression(ParameterModifiers.Out, name, expression, new TextRange(startOffset, this.Token.EndOffset)); +>" )
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="PrimaryExpression" Parameters="out Expression expression">
			<AdditionalConditions>
				<ExpressionCondition>this.IsDefaultValueExpression()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					expression = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				'True<+ expression = new LiteralExpression(LiteralType.True, null, this.Token.TextRange); +>'
				| 'False<+ expression = new LiteralExpression(LiteralType.False, null, this.Token.TextRange); +>'
				| 'DecimalIntegerLiteral<+ expression = new LiteralExpression(LiteralType.DecimalInteger, this.TokenText, this.Token.TextRange); +>'
				| 'HexadecimalIntegerLiteral<+ expression = new LiteralExpression(LiteralType.HexadecimalInteger, this.TokenText, this.Token.TextRange); +>'
				| 'RealLiteral<+ expression = new LiteralExpression(LiteralType.Real, this.TokenText, this.Token.TextRange); +>'
				| 'CharacterLiteral<+ expression = new LiteralExpression(LiteralType.Character, this.TokenText, this.Token.TextRange); +>'
				| 'StringLiteral<+ expression = new LiteralExpression(LiteralType.String, this.TokenText, this.Token.TextRange); +>'
				| 'VerbatimStringLiteral<+ expression = new LiteralExpression(LiteralType.VerbatimString, this.TokenText, this.Token.TextRange); +>'
				| 'Null<+ expression = new LiteralExpression(LiteralType.Null, null, this.Token.TextRange); +>'
				| (
					"SimpleIdentifier"
					<%
						if (this.TokenIs(this.LookAheadToken, CSharpTokenID.NamespaceAliasQualifier)) {
							// Create a type reference
							string alias = this.TokenText;
						%>
							'NamespaceAliasQualifier'
							"SimpleIdentifier"
						<%
							expression = new TypeReferenceExpression(new TypeReference(alias + "." + this.TokenText, new TextRange(startOffset, this.Token.EndOffset)));
						}
						else {
							// Create a simple name
							expression = new SimpleName(this.TokenText, this.Token.TextRange);
							AstNodeList typeArgumentList = null;
							if (this.IsTypeArgumentList()) {
						%>
							[ "TypeArgumentList<@ out typeArgumentList @>" ]
						<%
							}
							if (typeArgumentList != null)
								expression.GenericTypeArguments.AddRange(typeArgumentList.ToArray());					
						}
					%>
				)
				| (
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'CloseParenthesis'
					<%
						expression = new ParenthesizedExpression(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>					
				)
				| ( 
					<%
						QualifiedIdentifier memberName;
					%>
					(
						'Bool<+ expression = new TypeReferenceExpression(new TypeReference("System.Boolean", this.Token.TextRange)); +>'
						| 'Byte<+ expression = new TypeReferenceExpression(new TypeReference("System.Byte", this.Token.TextRange)); +>'
						| 'Char<+ expression = new TypeReferenceExpression(new TypeReference("System.'Char", this.Token.TextRange)); +>'
						| 'Decimal<+ expression = new TypeReferenceExpression(new TypeReference("System.Decimal", this.Token.TextRange)); +>'
						| 'Double<+ expression = new TypeReferenceExpression(new TypeReference("System.Double", this.Token.TextRange)); +>'
						| 'Dynamic<+ expression = new TypeReferenceExpression(new TypeReference("System.Object", this.Token.TextRange)); +>'
						| 'Float<+ expression = new TypeReferenceExpression(new TypeReference("System.Single", this.Token.TextRange)); +>'
						| 'Int<+ expression = new TypeReferenceExpression(new TypeReference("System.Int32", this.Token.TextRange)); +>'
						| 'Long<+ expression = new TypeReferenceExpression(new TypeReference("System.Int64", this.Token.TextRange)); +>'
						| 'Object<+ expression = new TypeReferenceExpression(new TypeReference("System.Object", this.Token.TextRange)); +>'
						| 'SByte<+ expression = new TypeReferenceExpression(new TypeReference("System.SByte", this.Token.TextRange)); +>'
						| 'Short<+ expression = new TypeReferenceExpression(new TypeReference("System.Int16", this.Token.TextRange)); +>'
						| 'String<+ expression = new TypeReferenceExpression(new TypeReference("System.String", this.Token.TextRange)); +>'
						| 'UInt<+ expression = new TypeReferenceExpression(new TypeReference("System.UInt32", this.Token.TextRange)); +>'
						| 'ULong<+ expression = new TypeReferenceExpression(new TypeReference("System.UInt64", this.Token.TextRange)); +>'
						| 'UShort<+ expression = new TypeReferenceExpression(new TypeReference("System.UInt16", this.Token.TextRange)); +>'
					)
					'Dot' 
					"Identifier<@ out memberName @>" 
					<%
						expression = new MemberAccess(expression, memberName, new TextRange(startOffset, this.Token.EndOffset));
						AstNodeList typeArgumentList = null;
						if (this.IsTypeArgumentList()) {
					%>
						[ "TypeArgumentList<@ out typeArgumentList @>" ]
					<%
						}
						if (typeArgumentList != null)
							expression.GenericTypeArguments.AddRange(typeArgumentList.ToArray());					
					%>					
				)
				| 'This<+ expression = new ThisAccess(this.Token.TextRange); +>'
				| (
					'Base<+ expression = new BaseAccess(this.Token.TextRange); +>' 
					(
						( 
							<%
								QualifiedIdentifier memberName;
							%>
							'Dot' 
							"Identifier<@ out memberName @>" 
							<%
								expression = new MemberAccess(expression, memberName, new TextRange(startOffset, this.Token.EndOffset));
								AstNodeList typeArgumentList = null;
								if (this.IsTypeArgumentList()) {
							%>
								[ "TypeArgumentList<@ out typeArgumentList @>" ]
							<%
								}
								if (typeArgumentList != null)
									expression.GenericTypeArguments.AddRange(typeArgumentList.ToArray());					
							%>					
						)
						| ( 
							<%
								// Element access
								expression = new InvocationExpression(expression);
								((InvocationExpression)expression).IsIndexerInvocation = true;
								expression.StartOffset = this.LookAheadToken.StartOffset;
								Expression parameterExpression;
							%>
							'OpenSquareBrace' 
							"Expression<@ out parameterExpression @><+ ((InvocationExpression)expression).Arguments.Add(parameterExpression); +>"
							{ ( 'Comma' "Expression<@ out parameterExpression @><+ ((InvocationExpression)expression).Arguments.Add(parameterExpression); +>" ) }
							'CloseSquareBrace' 
							<%
								expression.EndOffset = this.Token.EndOffset;
							%>
						)
					)
				)
				| <? this.AreNextTwo(CSharpTokenID.New, CSharpTokenID.OpenCurlyBrace) ?> 
					"AnonymousObjectCreationExpression<@ out expression @>"
				| <? this.AreNextTwo(CSharpTokenID.New, CSharpTokenID.OpenSquareBrace) ?> 
					"ImplicitlyTypedArrayCreationExpression<@ out expression @>"
				| (
					'New'
					<%
						TypeReference typeReference;
						AstNodeList argumentList = null;										
					%>
					"NonArrayType<@ false, false, out typeReference @>" 
					(
						<%
							expression = new ObjectCreationExpression(typeReference);
							expression.StartOffset = startOffset;
							Expression initializer = null;
						%>
						'OpenParenthesis' 
						[ "ArgumentList<@ out argumentList @>" ]
						'CloseParenthesis' 
						[ "ObjectOrCollectionInitializer<@ out initializer @>" ]
						<%
							// NOTE: This handles both object and delegate creation since their grammar is essentially the same
							if (argumentList != null)
								((ObjectCreationExpression)expression).Arguments.AddRange(argumentList.ToArray());
							expression.EndOffset = this.Token.EndOffset;
							((ObjectCreationExpression)expression).Initializer = (ObjectCollectionInitializerExpression)initializer;
						%>						
					)
					| (
						<%
							// Object or collection initializer
							expression = new ObjectCreationExpression(typeReference);
							expression.StartOffset = startOffset;
							Expression initializer = null;
						%>
						"ObjectOrCollectionInitializer<@ out initializer @>"
						<%
							expression.EndOffset = this.Token.EndOffset;
							((ObjectCreationExpression)expression).Initializer = (ObjectCollectionInitializerExpression)initializer;
						%>						
					)
					| (
						<%
							expression = new ObjectCreationExpression(typeReference);
							((ObjectCreationExpression)expression).IsArray = true;
							expression.StartOffset = startOffset;
							Expression parameterExpression;
							int[] arrayRanks;
							Expression initializer = null;
						%>
						[ <? this.IsArrayRankSpecifiers() ?>
							"RankSpecifier<@ out arrayRanks @><+ typeReference.ArrayRanks = arrayRanks; +>"
							"ArrayInitializer<@ out initializer @>"
						]
						<%
							if (initializer == null) {
						%>
								'OpenSquareBrace' 
								"Expression<@ out parameterExpression @><+ ((ObjectCreationExpression)expression).Arguments.Add(parameterExpression); +>"
								{ ( 'Comma' "Expression<@ out parameterExpression @><+ ((ObjectCreationExpression)expression).Arguments.Add(parameterExpression); +>" ) }
								'CloseSquareBrace' 
								"RankSpecifier<@ out arrayRanks @><+ 
									if (arrayRanks == null)
										arrayRanks = new int[] { ((ObjectCreationExpression)expression).Arguments.Count };
									typeReference.ArrayRanks = arrayRanks; 
									+>"
								[ "ArrayInitializer<@ out initializer @>" ]
						<%
							}
							((ObjectCreationExpression)expression).Initializer = (ObjectCollectionInitializerExpression)initializer;
							expression.EndOffset = this.Token.EndOffset;
						%>
					)
				)
				| (
					'TypeOf'
					'OpenParenthesis' 
					<%
						TypeReference typeReference = null;
						if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.Void)) && (!this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.Multiplication))) {
							// Regular void (non-pointer)
					%>
							'Void<+ typeReference = new TypeReference("System.Void", this.Token.TextRange); +>'
					<%
						}
						else {
					%>
							"TypeCore<@ true, false, out typeReference @>" 
					<%
						}
					%>
					'CloseParenthesis' 
					<%
						expression = new TypeOfExpression(typeReference, new TextRange(startOffset, this.Token.EndOffset));
					%>					
				)				
				| (
					'SizeOf'
					'OpenParenthesis' 
					<%
						TypeReference typeReference = null;
					%>
					"Type<@ out typeReference @>" 
					'CloseParenthesis' 
					<%
						expression = new SizeOfExpression(typeReference, new TextRange(startOffset, this.Token.EndOffset));
					%>					
				)				
				| ( 
					'Checked' 
					'OpenParenthesis' 
					"Expression<@ out expression @>"
					'CloseParenthesis' 
					<%
						expression = new CheckedExpression(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>					
				)
				| ( 
					'Unchecked' 
					'OpenParenthesis' 
					"Expression<@ out expression @>"
					'CloseParenthesis' 
					<%
						expression = new UncheckedExpression(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>					
				)
				| <? this.IsDefaultValueExpression() ?>(
					'Default'
					'OpenParenthesis' 
					<%
						TypeReference typeReference = null;
					%>
					"Type<@ out typeReference @>" 
					'CloseParenthesis' 
					<%
						expression = new DefaultValueExpression(typeReference, new TextRange(startOffset, this.Token.EndOffset));
					%>					
				)
				| "AnonymousMethodExpression<@ out expression @>"
				
				{
					( 
						<%
							// Member access
							QualifiedIdentifier memberName;
						%>
						'Dot' 
						"Identifier<@ out memberName @>" 
						<%
							expression = new MemberAccess(expression, memberName, new TextRange(startOffset, this.Token.EndOffset));
							AstNodeList typeArgumentList = null;
							if (this.IsTypeArgumentList()) {
						%>
							[ "TypeArgumentList<@ out typeArgumentList @>" ]
						<%
							}
							if (typeArgumentList != null)
								expression.GenericTypeArguments.AddRange(typeArgumentList.ToArray());					
						%>					
					)
					| ( 
						<%
							// Member access (via pointer)
							QualifiedIdentifier memberName;
						%>
						'PointerDereference' 
						"Identifier<@ out memberName @>" 
						<%
							expression = new PointerMemberAccess(expression, memberName, new TextRange(startOffset, this.Token.EndOffset));
							AstNodeList typeArgumentList = null;
							if (this.IsTypeArgumentList()) {
						%>
							[ "TypeArgumentList<@ out typeArgumentList @>" ]
						<%
							}
							if (typeArgumentList != null)
								expression.GenericTypeArguments.AddRange(typeArgumentList.ToArray());					
						%>					
					)
					| ( 'Increment<+ expression = new UnaryExpression(OperatorType.PostIncrement, expression); +>' )
					| ( 'Decrement<+ expression = new UnaryExpression(OperatorType.PostDecrement, expression); +>' )
					| (
						<%
							// Invocation expression
							expression = new InvocationExpression(expression);
							expression.StartOffset = startOffset;
							AstNodeList argumentList = null;										
						%>
						'OpenParenthesis' 
						[ "ArgumentList<@ out argumentList @>" ]
						'CloseParenthesis'
						<%
							if (argumentList != null)
								((InvocationExpression)expression).Arguments.AddRange(argumentList.ToArray());
							expression.EndOffset = this.Token.EndOffset;
						%>
					)
					| (
						<%
							// Element access
							expression = new InvocationExpression(expression);
							((InvocationExpression)expression).IsIndexerInvocation = true;
							expression.StartOffset = startOffset;
							AstNodeList argumentList = null;  // C# 4.0 named arguments							
						%>
						'OpenSquareBrace' 
						"ArgumentList<@ out argumentList @>"
						'CloseSquareBrace'
						<%
							if (argumentList != null)
								((InvocationExpression)expression).Arguments.AddRange(argumentList.ToArray());
							expression.EndOffset = this.Token.EndOffset;
						%>
					)
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: PrimaryNoArrayCreationExpression merged with PrimaryExpression -->
		<!-- NOTE: SimpleName merged into PrimaryExpression -->
		<!-- NOTE: ParenthesizedExpression merged into PrimaryExpression -->
		<!-- NOTE: MemberAccess merged into PrimaryExpression -->
		<!-- NOTE: PredefinedType merged into PrimaryExpression -->
		<!-- NOTE: InvocationExpression merged into PrimaryExpression -->
		<!-- NOTE: ElementAccess merged into PrimaryExpression to reduce ambiguity -->
		<!-- NOTE: ExpressionList merged into callers of ExpressionList -->
		<!-- NOTE: ThisAccess merged into PrimaryExpression -->
		<!-- NOTE: BaseAccess merged into PrimaryExpression -->
		<!-- NOTE: PostIncrementExpression merged into callers of PostIncrementExpression -->
		<!-- NOTE: PostDecrementExpression merged into callers of PostDecrementExpression -->
		<!-- NOTE: ObjectCreationExpression merged into PrimaryExpression -->
		<!-- NOTE: ArrayCreationExpression merged into PrimaryExpression -->
		<!-- NOTE: DelegateCreationExpression merged into PrimaryExpression -->
		<!-- NOTE: TypeOfExpression merged into PrimaryExpression -->
		<!-- NOTE: CheckedExpression merged into PrimaryExpression -->
		<!-- NOTE: UncheckedExpression merged into PrimaryExpression -->
		<NonTerminal Key="UnaryExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				( 'Addition' "UnaryExpression<@ out expression @>" <% expression = new UnaryExpression(OperatorType.Addition, expression); %> )
				| ( 'Subtraction' "UnaryExpression<@ out expression @>" <% expression = new UnaryExpression(OperatorType.Subtraction, expression); %> )
				| ( 'Negation' "UnaryExpression<@ out expression @>" <% expression = new UnaryExpression(OperatorType.Negation, expression); %> )
				| ( 'OnesComplement' "UnaryExpression<@ out expression @>" <% expression = new UnaryExpression(OperatorType.OnesComplement, expression); %> )
				| ( 'Multiplication' "UnaryExpression<@ out expression @>" <% expression = new UnaryExpression(OperatorType.PointerIndirection, expression); %> )
				| ( 'BitwiseAnd' "UnaryExpression<@ out expression @>" <% expression = new UnaryExpression(OperatorType.AddressOf, expression); %> )
				| ( 'Increment' "UnaryExpression<@ out expression @>" <% expression = new UnaryExpression(OperatorType.PreIncrement, expression); %> )
				| ( 'Decrement' "UnaryExpression<@ out expression @>" <% expression = new UnaryExpression(OperatorType.PreDecrement, expression); %> )
				| <? this.IsTypeCast() ?> (
					<% // NOTE: Have to do a check for type casts "( type )" since they are similar to PrimaryExpression "( expression )" %>
					"CastExpression<@ out expression @>"
				)
				| "PrimaryExpression<@ out expression @>"
				<%
					if (expression != null) {
						expression.StartOffset	= startOffset;
						expression.EndOffset	= this.Token.EndOffset;
					}
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: PreIncrementExpression merged with UnaryExpression -->
		<!-- NOTE: PreDecrementExpression merged with UnaryExpression -->
		<NonTerminal Key="CastExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					TypeReference typeReference;
					expression = null;
				%>
				'OpenParenthesis' 
				"Type<@ out typeReference @>" 
				'CloseParenthesis' 
				"UnaryExpression<@ out expression @>"
				<%
					expression = new CastExpression(typeReference, expression, new TextRange(startOffset, this.Token.EndOffset));
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="MultiplicativeExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"UnaryExpression<@ out expression @>"
				{
					<%
						OperatorType operatorType = OperatorType.None;
					%>
					(
						'Multiplication<+ operatorType = OperatorType.Multiply; +>'
						| 'Division<+ operatorType = OperatorType.Division; +>'
						| 'Modulus<+ operatorType = OperatorType.Modulus; +>'
					)
					"MultiplicativeExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="AdditiveExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"MultiplicativeExpression<@ out expression @>"
				{
					<%
						OperatorType operatorType = OperatorType.None;
					%>
					(
						'Addition<+ operatorType = OperatorType.Addition; +>'
						| 'Subtraction<+ operatorType = OperatorType.Subtraction; +>'
					)
					"AdditiveExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ShiftExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"AdditiveExpression<@ out expression @>"
				{ <? (this.TokenIs(this.LookAheadToken, CSharpTokenID.LeftShift)) || (this.IsRightShift()) ?>
					<%
						OperatorType operatorType = OperatorType.None;
					%>
					(
						'LeftShift<+ operatorType = OperatorType.LeftShift; +>'
						| <? this.IsRightShift() ?>(
							'GreaterThan'
							'GreaterThan<+ operatorType = OperatorType.RightShift; +>'
						)
					)
					"ShiftExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="RelationalExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"ShiftExpression<@ out expression @>"
				{ <? (this.TokenIs(this.LookAheadToken, new int[] { CSharpTokenID.LessThan, CSharpTokenID.LessThanOrEqual, CSharpTokenID.GreaterThanOrEqual, CSharpTokenID.Is, CSharpTokenID.As })) || ((this.TokenIs(this.LookAheadToken, CSharpTokenID.GreaterThan)) && (!this.IsRightShiftAssignment())) ?>
					(
						<%
							OperatorType operatorType = OperatorType.None;
						%>
						(
							'LessThan<+ operatorType = OperatorType.LessThan; +>'
							| 'LessThanOrEqual<+ operatorType = OperatorType.LessThanOrEqual; +>'
							| 'GreaterThanOrEqual<+ operatorType = OperatorType.GreaterThanOrEqual; +>'
						)
						"RelationalExpression<@ out rightExpression @>"
						<%
							expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
						%>
					)
					| <? (this.TokenIs(this.LookAheadToken, CSharpTokenID.GreaterThan)) && (!this.IsRightShiftAssignment()) ?> (
						<%
							OperatorType operatorType = OperatorType.None;
						%>
						'GreaterThan<+ operatorType = OperatorType.GreaterThan; +>'
						"RelationalExpression<@ out rightExpression @>"
						<%
							expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
						%>
					)
					| (
						<%
							TypeReference typeReference;
						%>
						'Is'
						"TypeCore<@ false, true, out typeReference @>"
						<%
							expression = new IsTypeOfExpression(expression, typeReference, new TextRange(startOffset, this.Token.EndOffset));
						%>
					)
					| (
						<%
							TypeReference typeReference;
						%>
						'As'
						"TypeCore<@ false, true, out typeReference @>"
						<%
							expression = new TryCastExpression(expression, typeReference, new TextRange(startOffset, this.Token.EndOffset));
						%>
					)
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="EqualityExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"RelationalExpression<@ out expression @>"
				{
					<%
						OperatorType operatorType = OperatorType.None;
					%>
					(
						'Equality<+ operatorType = OperatorType.Equality; +>'
						| 'Inequality<+ operatorType = OperatorType.Inequality; +>'
					)
					"EqualityExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="AndExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"EqualityExpression<@ out expression @>"
				{
					'BitwiseAnd'
					"AndExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.BitwiseAnd, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ExclusiveOrExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"AndExpression<@ out expression @>"
				{
					'ExclusiveOr'
					"ExclusiveOrExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.ExclusiveOr, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="InclusiveOrExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"ExclusiveOrExpression<@ out expression @>"
				{
					'BitwiseOr'
					"InclusiveOrExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.BitwiseOr, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ConditionalAndExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"InclusiveOrExpression<@ out expression @>"
				{
					'ConditionalAnd'
					"ConditionalAndExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.ConditionalAnd, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ConditionalOrExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"ConditionalAndExpression<@ out expression @>"
				{
					'ConditionalOr'
					"ConditionalOrExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.ConditionalOr, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ConditionalExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"ConditionalOrExpression<@ out expression @>"
				[
					<%
						Expression nullCoalescingExpression;
					%>
					'NullCoalescing'
					"Expression<@ out nullCoalescingExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.NullCoalescing, expression, nullCoalescingExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				]
				[
					<%
						Expression trueExpression, falseExpression;
					%>
					'QuestionMark'
					"Expression<@ out trueExpression @>"
					'Colon'
					"Expression<@ out falseExpression @>"
					<%
						expression = new ConditionalExpression(expression, trueExpression, falseExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				]
			]]></Production>
		</NonTerminal>
		<!-- NOTE: Assignment merged into Expression -->
		<NonTerminal Key="AssignmentOperator" Parameters="out OperatorType operatorType">
			<AdditionalConditions>
				<ExpressionCondition>this.IsRightShiftAssignment()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					operatorType = OperatorType.None;
				%>
				'Assignment'
				| 'AdditionAssignment<+ operatorType = OperatorType.Addition; +>'
				| 'SubtractionAssignment<+ operatorType = OperatorType.Subtraction; +>'
				| 'MultiplicationAssignment<+ operatorType = OperatorType.Multiply; +>'
				| 'DivisionAssignment<+ operatorType = OperatorType.Division; +>'
				| 'ModulusAssignment<+ operatorType = OperatorType.Modulus; +>'
				| 'BitwiseAndAssignment<+ operatorType = OperatorType.BitwiseAnd; +>'
				| 'BitwiseOrAssignment<+ operatorType = OperatorType.BitwiseOr; +>'
				| 'ExclusiveOrAssignment<+ operatorType = OperatorType.ExclusiveOr; +>'
				| 'LeftShiftAssignment<+ operatorType = OperatorType.LeftShift; +>'
				| <? this.IsRightShiftAssignment() ?> (
					<%
						// NOTE: This handles ambiguity between right shift and generic type specifications in .NET 2.0
					%>
					'GreaterThan'
					'GreaterThanOrEqual<+ operatorType = OperatorType.RightShift; +>'
				)
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NonAssignmentExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
				%>
				"LambdaExpression<@ out expression @>"
				| "QueryExpression<@ out expression @>"
				| "ConditionalExpression<@ out expression @>"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Expression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"NonAssignmentExpression<@ out expression @>"
				<%
					// If the result of the expression is a unary expression...
					if ((expression != null) && (!((expression is ConditionalExpression) || (expression is IsTypeOfExpression) || (expression is TryCastExpression))) && (IsNonTerminal("AssignmentOperator"))) {
						OperatorType operatorType;
						Expression rightExpression;
					%>
						"AssignmentOperator<@ out operatorType @>"
						"Expression<@ out rightExpression @>"
					<%
						expression = new AssignmentExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					}
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ConstantExpression simply uses Expression since the code is really all the same -->
		<!-- NOTE: BooleanExpression simply uses Expression since the code is really all the same -->
		
		
		<!-- C.2.5 Statements -->
		<NonTerminal Key="Statement" Parameters="out Statement statement">
			<AdditionalConditions>
				<TokenCondition>Var</TokenCondition>
				<TokenCondition>Void</TokenCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					statement = null;
				%>
				(
					"LocalConstantDeclaration<@ out statement @>"
					'SemiColon<- ->'
					<%
						statement.EndOffset = this.Token.EndOffset;
					%>
				)
				| <? this.AreNextTwoIdentifierAnd(CSharpTokenID.Colon) ?>
					"LabeledStatement<@ out statement @>"
				| <? (this.IsVariableDeclaration()) && (!this.TokenIs(this.LookAheadToken, CSharpTokenID.From)) ?> (
					"LocalVariableDeclaration<@ out statement @>"
					'SemiColon<- ->'
					<%
						statement.EndOffset = this.Token.EndOffset;
					%>
				)
				| "EmbeddedStatement<@ out statement @>"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="EmbeddedStatement" Parameters="out Statement statement">
			<Production><![CDATA[
				<%
					statement = null;					
				%>
				"Block<@ out statement @>"
				| (
					<%
						// Empty statement
					%>
					'SemiColon'
					<%
						statement = new EmptyStatement(this.Token.TextRange);
					%>
				)
				| <? this.AreNextTwo(CSharpTokenID.Checked, CSharpTokenID.OpenCurlyBrace) ?> (
					<%
						// Checked statement (moved up here with special condition since Expression has 'checked' in its first set)
						Statement embeddedStatement;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Checked'
					"Block<@ out embeddedStatement @>"
					<%
						statement = new CheckedStatement(embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| <? this.AreNextTwo(CSharpTokenID.Unchecked, CSharpTokenID.OpenCurlyBrace) ?> (
					<%
						// Unchecked statement (moved up here with special condition since Expression has 'unchecked' in its first set)
						Statement embeddedStatement;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Unchecked'
					"Block<@ out embeddedStatement @>"
					<%
						statement = new UncheckedStatement(embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Expression statement
					%>
					"StatementExpression<@ out statement @>"
					'SemiColon'
					<%
						statement.EndOffset = this.Token.EndOffset;
					%>
				)
				| (
					<%
						// If statement
						Expression condition;
						Statement trueStatement;
						Statement falseStatement = null;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'If'
					'OpenParenthesis'
					"Expression<@ out condition @>"
					'CloseParenthesis'
					"EmbeddedStatement<@ out trueStatement @>"
					<%
						if (this.AreNextTwo(CSharpTokenID.Else, CSharpTokenID.If)) {
							Stack elseIfStatementStack = new Stack();
							while (this.AreNextTwo(CSharpTokenID.Else, CSharpTokenID.If)) {
								Expression elseIfCondition;
								Statement elseIfTrueStatement;
								int elseIfStartOffset = this.LookAheadToken.StartOffset;
						%>
							'Else'
							'If'
							'OpenParenthesis'
							"Expression<@ out elseIfCondition @>"
							'CloseParenthesis'
							"EmbeddedStatement<@ out elseIfTrueStatement @>"
						<%
								falseStatement = new IfStatement(elseIfCondition, elseIfTrueStatement);
								falseStatement.StartOffset = elseIfStartOffset;
								elseIfStatementStack.Push(falseStatement);
							}
							
							falseStatement = null;
						%>
							[
								'Else'
								"EmbeddedStatement<@ out falseStatement @>"
							]
						<%
							int elseIfEndOffset = this.Token.EndOffset;
							while (elseIfStatementStack.Count > 0) {
								IfStatement parentElseIfStatement = (IfStatement)elseIfStatementStack.Pop();
								parentElseIfStatement.EndOffset = elseIfEndOffset;
								parentElseIfStatement.FalseStatement = falseStatement;
								falseStatement = parentElseIfStatement;
							}
						}
						else if (this.TokenIs(this.LookAheadToken, CSharpTokenID.Else)) {
					%>
							'Else'
							"EmbeddedStatement<@ out falseStatement @>"
					<%
						}
						statement = new IfStatement(condition, trueStatement, falseStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Switch statement
						Expression expression;
						AstNodeList sections = new AstNodeList(null);
						SwitchSection switchSection;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Switch'
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'CloseParenthesis'
					<%
						int statementCurlyBraceLevel = curlyBraceLevel;
					%>
					'OpenCurlyBrace'
					<%
						bool errorReported = false;
						while (!this.IsAtEnd) {
							if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == statementCurlyBraceLevel + 1))
								break;
							else if (IsNonTerminal("SwitchSection")) {
								errorReported = false;
						%>
								{ "SwitchSection<@ out switchSection @><+ sections.Add(switchSection); +><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->" }								
						<%
							}
							else {
								// Error recovery:  Advance to the next token since nothing was matched
								if (!errorReported) {
									this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_SwitchSectionExpected"));
									errorReported = true;
								}
								this.AdvanceToNext();
							}
						}
					%>
					'CloseCurlyBrace<- ->'
					<%
						statement = new SwitchStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
						((SwitchStatement)statement).Sections.AddRange(sections.ToArray());					
					%>
				)
				| (
					<%
						// While statement
						Expression expression;
						Statement embeddedStatement;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'While'
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'CloseParenthesis'
					"Statement<@ out embeddedStatement @><- ->"
					<%
						statement = new WhileStatement(expression, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Do statement
						Statement embeddedStatement;
						Expression expression;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Do'
					"Statement<@ out embeddedStatement @>"
					'While'
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'CloseParenthesis'
					'SemiColon'
					<%
						statement = new DoStatement(embeddedStatement, expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// For statement
						Statement embeddedStatement;
						Expression expression;
						statement = new ForStatement();
						statement.StartOffset = this.LookAheadToken.StartOffset;
					%>
					'For'
					'OpenParenthesis'
					[ <? this.IsVariableDeclaration() ?>
						<%
							Statement initializerVariableDeclaration;
						%>
						"LocalVariableDeclaration<@ out initializerVariableDeclaration @><+ ((ForStatement)statement).Initializers.Add(initializerVariableDeclaration); +>"
					]
					<%
						if (((ForStatement)statement).Initializers.Count == 0) {
					%>
							[
								"Expression<@ out expression @><+ ((ForStatement)statement).Initializers.Add(expression); +>"
								{ 'Comma' "Expression<@ out expression @><+ ((ForStatement)statement).Initializers.Add(expression); +>" }
							]
					<%
						}
					%>
					'SemiColon'
					[ "Expression<@ out expression @><+ ((ForStatement)statement).Condition = expression; +>" ]
					'SemiColon'
					[
						"Expression<@ out expression @><+ ((ForStatement)statement).Iterators.Add(expression); +>"
						{ 'Comma' "Expression<@ out expression @><+ ((ForStatement)statement).Iterators.Add(expression); +>" }
					]
					'CloseParenthesis'
					"Statement<@ out embeddedStatement @><- ->"
					<%
						((ForStatement)statement).Statement = embeddedStatement;
						statement.EndOffset = this.Token.EndOffset;
					%>
				)
				| (
					<%
						// For-each statement
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'ForEach'
					'OpenParenthesis'
					<%
						LocalVariableDeclaration variableDeclaration = new LocalVariableDeclaration();
						variableDeclaration.StartOffset = this.LookAheadToken.StartOffset;
						TypeReference typeReference = null;
						QualifiedIdentifier identifier;
						
						if (this.TokenIs(this.LookAheadToken, CSharpTokenID.Var))
							this.AdvanceToNext();
						else {
					%>
							"Type<@ out typeReference @>"
					<%
						}
					%>
					"Identifier<@ out identifier @>"
					<%
						variableDeclaration.EndOffset = this.Token.EndOffset;
						Expression expression;
						Statement embeddedStatement;
					%>
					'In'
					"Expression<@ out expression @>"
					<%
						// If in an implicitly typed declaration, try and locate the type reference
						bool isImplicitlyTyped = false;
						if (typeReference == null) {
							isImplicitlyTyped = true;
							typeReference = this.GetImplicitType(expression, false);
							if (typeReference == null)
								return false;
						}
					
						// Add the declarator
						VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, identifier, false, true);
						variableDeclarator.IsImplicitlyTyped = isImplicitlyTyped;
						variableDeclaration.Variables.Add(variableDeclarator);
					%>
					'CloseParenthesis'
					"Statement<@ out embeddedStatement @><- ->"
					<%
						statement = new ForEachStatement(variableDeclaration, expression, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Break statement
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Break'
					'SemiColon'
					<%
						statement = new BreakStatement(new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Continue statement
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Continue'
					'SemiColon'
					<%
						statement = new ContinueStatement(new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Goto statement
						Expression expression = null;
						QualifiedIdentifier identifier = null;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Goto'
					(
						"Identifier<@ out identifier @>"
						| ( 'Case' "Expression<@ out expression @>" )
						| 'Default'
					)
					'SemiColon'
					<%
						statement = new GotoStatement(identifier, expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Return statement
						Expression expression = null;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Return'
					[ "Expression<@ out expression @>" ]
					'SemiColon'
					<%
						statement = new ReturnStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Throw statement
						Expression expression = null;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Throw'
					[ "Expression<@ out expression @>" ]
					'SemiColon'
					<%
						statement = new ThrowStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Try statement
						Statement tryBlock;
						Statement finallyBlock = null;
						CatchClause catchClause;
						AstNodeList catchClauses = new AstNodeList(null);
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Try'
					"Block<@ out tryBlock @>"
					(
						(
							"CatchClause<@ out catchClause @><+ catchClauses.Add(catchClause); +>"
							{ "CatchClause<@ out catchClause @><+ catchClauses.Add(catchClause); +>" }
							[
								'Finally' 
								"Block<@ out finallyBlock @>" 
							]
						)
						| ( 
							'Finally' 
							"Block<@ out finallyBlock @>" 
						)
					)
					<%
						statement = new TryStatement(tryBlock, finallyBlock, new TextRange(startOffset, this.Token.EndOffset));
						((TryStatement)statement).CatchClauses.AddRange(catchClauses.ToArray());					
					%>
				)
				| (
					<%
						// Lock statement
						Expression expression;
						Statement embeddedStatement;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Lock'
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'CloseParenthesis'
					"Statement<@ out embeddedStatement @><- ->"
					<%
						statement = new LockStatement(expression, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Using statement
						Statement variableDeclaration = null;
						Expression expression = null;
						Statement embeddedStatement;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Using'
					'OpenParenthesis'
					[ <? this.IsVariableDeclaration() ?> "LocalVariableDeclaration<@ out variableDeclaration @>" ]
					<%
						if (variableDeclaration == null) {
					%>
							"Expression<@ out expression @>"
					<%
						}
					%>
					'CloseParenthesis'
					"Statement<@ out embeddedStatement @><- ->"
					<%
						AstNodeList resourceAcquisitions = new AstNodeList(null);
						resourceAcquisitions.Add(variableDeclaration != null ? (AstNode)variableDeclaration : (AstNode)expression);
						statement = new UsingStatement(resourceAcquisitions, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Yield statement
						Expression expression = null;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Yield'
					(
						(
							'Return'
							[ "Expression<@ out expression @>" ]
						)
						| 'Break'
					)
					'SemiColon'
					<%
						statement = new YieldStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Unsafe statement
						Statement blockStatement;
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					'Unsafe'
					"Statement<@ out blockStatement @><- ->"
					<%
						statement = new UnsafeStatement(blockStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						// Fixed statement
						TypeReference typeReference;
						QualifiedIdentifier variableName;
						Expression expression;
						Statement embeddedStatement;
						statement = new FixedStatement();
						statement.StartOffset = this.LookAheadToken.StartOffset;
					%>
					'Fixed'
					'OpenParenthesis'
					"Type<@ out typeReference @>"
					"Identifier<@ out variableName @>"
					'Assignment'
					"Expression<@ out expression @>"
					<%
						VariableDeclarator declarator = new VariableDeclarator(typeReference, variableName, false, true);
						declarator.Initializer = expression;
						((FixedStatement)statement).Declarators.Add(declarator); 
					%>
					
					{ 
						'Comma'
						"Identifier<@ out variableName @>"
						'Assignment'
						"Expression<@ out expression @>"
						<%
							declarator = new VariableDeclarator(typeReference, variableName, false, true);
							declarator.Initializer = expression;
							((FixedStatement)statement).Declarators.Add(declarator); 
						%>
					}
					'CloseParenthesis'
					"Statement<@ out embeddedStatement @><- ->"
					<%
						((FixedStatement)statement).Statement = embeddedStatement;
						statement.EndOffset = this.Token.EndOffset;
					%>
				)
				
				<%
					if (statement != null) {
						// Reap comments
						this.ReapComments(statement.Comments, true);
					}
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Block" Parameters="out Statement block">
			<Production><![CDATA[
				<%
					block = new BlockStatement();
					block.StartOffset = this.LookAheadToken.StartOffset;
					Statement statement;
					int statementCurlyBraceLevel = curlyBraceLevel;
				%>
				'OpenCurlyBrace'
				<%
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == statementCurlyBraceLevel + 1))
							break;
						else if (IsNonTerminal("Statement")) {
							errorReported = false;
					%>
							{ "Statement<@ out statement @><+ ((BlockStatement)block).Statements.Add(statement); +><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->" }
					<%
						}
						else {
							// Error recovery:  Advance to the next token since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
								errorReported = true;
							}
							this.AdvanceToNext();
						}
					}

					// Reap comments
					this.ReapComments(((BlockStatement)block).Comments, false);
				%>
				'CloseCurlyBrace<- ->'
				<%
					block.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: EmptyStatement merged with EmbeddedStatement -->
		<NonTerminal Key="LabeledStatement" Parameters="out Statement statement">
			<Production><![CDATA[
				<%
					statement = null;
					QualifiedIdentifier label;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"Identifier<@ out label @>"
				'Colon'
				"Statement<@ out statement @><- this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected")); ->"
				<%
					statement = new LabeledStatement(new SimpleName(label.Text, label.TextRange), statement, new TextRange(startOffset, this.Token.EndOffset));
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: DeclarationStatement merged with Statement -->		
		<NonTerminal Key="LocalVariableDeclaration" Parameters="out Statement statement">
			<Production><![CDATA[
				<%
					TypeReference typeReference = null;
					statement = new LocalVariableDeclaration();
					statement.StartOffset = this.LookAheadToken.StartOffset;

					if (this.TokenIs(this.LookAheadToken, CSharpTokenID.Var))
						this.AdvanceToNext();
					else {
				%>
						"Type<@ out typeReference @>"
				<%
					}
				%>
				"LocalVariableDeclarator<@ (LocalVariableDeclaration)statement, ref typeReference @>"
				{ 'Comma' "LocalVariableDeclarator<@ (LocalVariableDeclaration)statement, ref typeReference @>" }
				<%
					statement.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: LocalVariableDeclarators merged with LocalVariableDeclaration -->		
		<NonTerminal Key="LocalVariableDeclarator" Parameters="LocalVariableDeclaration variableDeclaration, ref TypeReference typeReference">
			<Production><![CDATA[
				<%
					QualifiedIdentifier identifier;
					Expression initializer = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"Identifier<@ out identifier @>"
				[
					'Assignment'
					"VariableInitializer<@ out initializer @>"
				]				
				<%
					// If in an implicitly typed declaration, try and locate the type reference
					bool isImplicitlyTyped = false;
					if (typeReference == null) {
						isImplicitlyTyped = true;
						typeReference = this.GetImplicitType(initializer, false);
						if (typeReference == null)
							return false;
					}
					
					VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, identifier, false, true);
					variableDeclarator.IsImplicitlyTyped = isImplicitlyTyped;
					variableDeclarator.Initializer = initializer;
					variableDeclarator.StartOffset = startOffset;
					variableDeclarator.EndOffset = this.Token.EndOffset;
					variableDeclaration.Variables.Add(variableDeclarator);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: LocalVariableInitializer merged with LocalVariableDeclarator -->		
		<NonTerminal Key="LocalConstantDeclaration" Parameters="out Statement statement">
			<Production><![CDATA[
				<%
					TypeReference typeReference;
					statement = new LocalVariableDeclaration();
					((LocalVariableDeclaration)statement).Modifiers = Modifiers.Const;
					statement.StartOffset = this.LookAheadToken.StartOffset;
				%>
				'Const'
				"Type<@ out typeReference @>"
				"LocalConstantDeclarator<@ (LocalVariableDeclaration)statement, typeReference @>"
				{ 'Comma' "LocalConstantDeclarator<@ (LocalVariableDeclaration)statement, typeReference @>" }
				<%
					statement.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ConstantDeclarators merged with LocalConstantDeclaration -->		
		<!-- NOTE: ConstantDeclarator renamed to LocalConstantDeclarator -->		
		<NonTerminal Key="LocalConstantDeclarator" Parameters="LocalVariableDeclaration constantDeclaration, TypeReference typeReference">
			<Production><![CDATA[
				<%
					QualifiedIdentifier identifier;
					Expression initializer = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"Identifier<@ out identifier @>"
				[
					'Assignment'
					"Expression<@ out initializer @>"
				]
				<%
					VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, identifier, true, true);
					variableDeclarator.Initializer = initializer;
					variableDeclarator.StartOffset = startOffset;
					variableDeclarator.EndOffset = this.Token.EndOffset;
					constantDeclaration.Variables.Add(variableDeclarator);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ExpressionStatement merged with EmbeddedStatement -->		
		<NonTerminal Key="StatementExpression" Parameters="out Statement statement">
			<Production><![CDATA[
				<%
					statement = null;
					Expression expression;
					// NOTE: This allows matching for any expression, even though it really should be more restrictive
				%>
				"Expression<@ out expression @>"
				<%
					statement = new StatementExpression(expression);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: SelectionStatement merged with EmbeddedStatement -->		
		<!-- NOTE: IfStatement merged with EmbeddedStatement -->
		<!-- NOTE: BooleanExpression merged with EmbeddedStatement -->
		<!-- NOTE: SwitchStatement merged with EmbeddedStatement -->
		<!-- NOTE: SwitchSections merged with EmbeddedStatement -->
		<NonTerminal Key="SwitchSection" Parameters="out SwitchSection switchSection">
			<Production><![CDATA[
				<%
					switchSection = null;
					Statement statement;
					switchSection = new SwitchSection();
					switchSection.StartOffset = this.LookAheadToken.StartOffset;
				%>
				{ 
					<%
						int startOffset = this.LookAheadToken.StartOffset;
						Expression expression = null;
					%>
					(
						'Case'
						"Expression<@ out expression @>"
					)
					| 'Default'
					'Colon'
					<%
						switchSection.Labels.Add(new SwitchLabel(expression, new TextRange(startOffset, this.Token.EndOffset)));
					%>
				}
				{ "Statement<@ out statement @><+ switchSection.Statements.Add(statement); +>" }
				<%
					switchSection.EndOffset = this.Token.EndOffset;

					// Reap comments
					this.ReapComments(((SwitchSection)switchSection).Comments, false);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: SwitchLabels merged with SwitchSection -->
		<!-- NOTE: SwitchLabel merged with SwitchSection -->
		<!-- NOTE: ForStatement merged with EmbeddedStatement -->
		<!-- NOTE: ForInitializer merged with EmbeddedStatement -->
		<!-- NOTE: ForCondition merged with EmbeddedStatement -->
		<!-- NOTE: ForIterator merged with EmbeddedStatement -->
		<!-- NOTE: StatementExpressionList merged with callers of StatementExpressionList -->
		<!-- NOTE: ForEachStatement merged with EmbeddedStatement -->
		<!-- NOTE: JumpStatement merged with EmbeddedStatement -->		
		<!-- NOTE: BreakStatement merged with EmbeddedStatement -->
		<!-- NOTE: ContinueStatement merged with EmbeddedStatement -->
		<!-- NOTE: GotoStatement merged with EmbeddedStatement -->
		<!-- NOTE: ReturnStatement merged with EmbeddedStatement -->
		<!-- NOTE: ThrowStatement merged with EmbeddedStatement -->
		<!-- NOTE: TryStatement merged with EmbeddedStatement -->
		<!-- NOTE: CatchClauses merged with EmbeddedStatement -->
		<!-- NOTE: SpecificCatchClauses merged with EmbeddedStatement -->
		<NonTerminal Key="CatchClause" Parameters="out CatchClause catchClause">
			<!-- NOTE: CatchClause added to reduce ambiguity -->
			<Production><![CDATA[
				<%
					catchClause = null;
					VariableDeclarator variableDeclarator = null;
					Statement catchBlock;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				'Catch'
				[
					'OpenParenthesis'
					<%
						TypeReference typeReference = null;
						QualifiedIdentifier variableName = null;
						int variableStartOffset = this.LookAheadToken.StartOffset;
					%>
					"Type<@ out typeReference @>"
					[ "Identifier<@ out variableName @>" ]
					<%
						variableDeclarator = new VariableDeclarator(typeReference, variableName, false, true);
						variableDeclarator.TextRange = new TextRange(variableStartOffset, this.Token.EndOffset);
					%>
					'CloseParenthesis'
				]
				"Block<@ out catchBlock @>"
				<%
					catchClause = new CatchClause(variableDeclarator, (BlockStatement)catchBlock, new TextRange(startOffset, this.Token.EndOffset));
				%>
			]]></Production>
		</NonTerminal>		
		<!-- NOTE: SpecificCatchClause merged with CatchClause -->
		<!-- NOTE: GeneralCatchClause merged with CatchClause -->
		<!-- NOTE: FinallyClause merged with EmbeddedStatement -->
		<!-- NOTE: CheckedStatement merged with EmbeddedStatement -->
		<!-- NOTE: UncheckedStatement merged with EmbeddedStatement -->
		<!-- NOTE: LockStatement merged with EmbeddedStatement -->
		<!-- NOTE: UsingStatement merged with EmbeddedStatement -->
		<!-- NOTE: ResourceAcquisition merged with EmbeddedStatement -->
		
		<!-- C.2.6 Namespaces -->
		<NonTerminal Key="CompilationUnit">
			<Production><![CDATA[
				<% 
					blockStack = new Stack();
					curlyBraceLevel = 0;
					compilationUnit = new CompilationUnit();
					compilationUnit.SourceLanguage = DotNetLanguage.CSharp;
					compilationUnit.StartOffset = this.LookAheadToken.StartOffset;
				%>
				{ "ExternAliasDirective
					<- 
						// Error recovery:  Go to the next extern keyword, using keyword, or token that starts a GlobalAttributeSection or NamespaceMemberDeclaration
						while (!this.IsAtEnd) {
							if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.Extern)) || (this.TokenIs(this.LookAheadToken, CSharpTokenID.Using)) || 
								(this.IsGlobalAttributeSection()) || (IsNonTerminal("NamespaceMemberDeclaration")))
								break;
							this.AdvanceToNext();
						}
					->" }
				{ "UsingDirective<@ compilationUnit @>
					<- 
						// Error recovery:  Go to the next using keyword, or token that starts a GlobalAttributeSection or NamespaceMemberDeclaration
						while (!this.IsAtEnd) {
							if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.Using)) || (this.IsGlobalAttributeSection()) || (IsNonTerminal("NamespaceMemberDeclaration")))
								break;
							this.AdvanceToNext();
						}
					->" }
				<%
					// Reap comments
					this.ReapComments(compilationUnit.Comments, false);
				%>
				{<? this.IsGlobalAttributeSection() ?> "GlobalAttributeSection" }
				<%
					bool errorReported = false;
					while (!this.IsAtEnd) {
						// Check for using statements in the wrong location
						if (this.TokenIs(this.LookAheadToken, CSharpTokenID.Extern)) {
							this.ReportSyntaxError(this.LookAheadToken.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ExternalAliasBeforeNamespace"));
							this.AdvanceToNext(CSharpTokenID.SemiColon);
							this.AdvanceToNext();
							continue;
						}
						else if (this.TokenIs(this.LookAheadToken, CSharpTokenID.Using)) {
							this.ReportSyntaxError(this.LookAheadToken.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_UsingBeforeNamespace"));
							this.AdvanceToNext(CSharpTokenID.SemiColon);
							this.AdvanceToNext();
							continue;
						}
						else if (IsNonTerminal("NamespaceMemberDeclaration")) {
							errorReported = false;
					%>
							{ "NamespaceMemberDeclaration" }
					<% 
						}
						else {
							// Error recovery:  Advance to the next token since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_NamespaceMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNext();
						}
					}
					compilationUnit.EndOffset = this.LookAheadToken.EndOffset;
					blockStack = null;
					
					// Reap comments
					this.ReapComments(compilationUnit.Comments, false);
					
					// Get the comment and region text ranges
					if (this.LexicalParser is CSharpRecursiveDescentLexicalParser) {
						compilationUnit.DocumentationCommentTextRanges = ((CSharpRecursiveDescentLexicalParser)this.LexicalParser).DocumentationCommentTextRanges;
						compilationUnit.MultiLineCommentTextRanges = ((CSharpRecursiveDescentLexicalParser)this.LexicalParser).MultiLineCommentTextRanges;
						compilationUnit.RegionTextRanges = ((CSharpRecursiveDescentLexicalParser)this.LexicalParser).RegionTextRanges;
					}
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NamespaceDeclaration">
			<Production><![CDATA[
				<%
					NamespaceDeclaration namespaceDeclaration = new NamespaceDeclaration();
				%>
				'Namespace'
				<%
					namespaceDeclaration.StartOffset = this.Token.StartOffset;
					QualifiedIdentifier name;
				%>
				"QualifiedIdentifier<@ out name @>"
				<%
					namespaceDeclaration.Name = name;
					this.BlockAddChild(namespaceDeclaration);
					this.BlockStart(namespaceDeclaration);
					namespaceDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
					int namespaceCurlyBraceLevel = curlyBraceLevel;
					this.ReapDocumentationComments();
				%>
				'OpenCurlyBrace
					<- 
						// Error recovery:  Go to the next open curly brace and then find the next matching close curly brace
						this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace); 
						this.AdvanceToNextCloseCurlyBrace(namespaceCurlyBraceLevel, false);
					->'
				{ "UsingDirective<@ namespaceDeclaration @>
					<- 
						// Error recovery:  Go past the next close curly brace, using keyword, or token that starts NamespaceMemberDeclaration
						while (!this.IsAtEnd) {
							if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) || (this.TokenIs(this.LookAheadToken, CSharpTokenID.Using)) || (IsNonTerminal("NamespaceMemberDeclaration")))
								break;
							this.AdvanceToNext();
						}
					->" }
				{ "NamespaceMemberDeclaration
					<- 
						// Error recovery:  Go past the next matching close curly brace
						this.AdvanceToNextCloseCurlyBrace(namespaceCurlyBraceLevel, true);
					->" }
				<%
					this.ReapDocumentationComments();
				%>
				'CloseCurlyBrace
					<- 
						// Error recovery:  Go past the next matching close curly brace
						this.AdvanceToNextCloseCurlyBrace(namespaceCurlyBraceLevel, true);
					->'
				<% 
					namespaceDeclaration.BlockEndOffset = this.Token.EndOffset;
					this.BlockEnd();
				%>
				[ 'SemiColon<- ->' ]
				<% 
					namespaceDeclaration.EndOffset = this.Token.EndOffset;

					// Reap comments
					this.ReapComments(namespaceDeclaration.Comments, false);
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="QualifiedIdentifier" Parameters="out QualifiedIdentifier identifier">
			<Production><![CDATA[
				<% 
					identifier = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"SimpleIdentifier<- ->"
				<%
					identifierStringBuilder.Length = 0;
					identifierStringBuilder.Append(this.TokenText);
				%>
				{<? this.IsQualifierIdentifierContinuation() ?>
					'Dot'
					"SimpleIdentifier"
					<%
						identifierStringBuilder.Append(".");
						identifierStringBuilder.Append(this.TokenText);
					%>
				}
				<% 
					identifier = new QualifiedIdentifier(identifierStringBuilder.ToString(), new TextRange(startOffset, this.Token.EndOffset)); 
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="SimpleIdentifier">
			<Production><![CDATA[
				'Identifier<- ->'
				| 'Ascending<- ->'
				| 'By<- ->'
				| 'Descending<- ->'
				| 'Equals<- ->' 
				| 'From<- ->'
				| 'Group<- ->'
				| 'Into<- ->'
				| 'Join<- ->'
				| 'Let<- ->'
				| 'On<- ->'
				| 'OrderBy<- ->'
				| 'Select<- ->'
				| 'Where<- ->'
				| 'Var<- ->'				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: Added Identifier to make it easy to return a QualifiedIdentifier object for a single identifier -->
		<NonTerminal Key="Identifier" Parameters="out QualifiedIdentifier identifier">
			<Production><![CDATA[
				<%
					identifier = new QualifiedIdentifier(this.LookAheadTokenText, this.LookAheadToken.TextRange); 
				%>
				'Identifier<- ->'
				| 'Ascending<- ->'
				| 'By<- ->'
				| 'Descending<- ->'
				| 'Equals<- ->' 
				| 'From<- ->'
				| 'Group<- ->'
				| 'Into<- ->'
				| 'Join<- ->'
				| 'Let<- ->'
				| 'On<- ->'
				| 'OrderBy<- ->'
				| 'Select<- ->'
				| 'Where<- ->'
				| 'Var<- ->'				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: NamespaceBody merged into Namespace -->
		<NonTerminal Key="UsingDirective" Parameters="AstNode parentNode">
			<Production><![CDATA[
				'Using<- ->' 
				<%
					this.ReapDocumentationComments();
					
					UsingDirectiveSection usingDirectives = (parentNode is CompilationUnit ? ((CompilationUnit)parentNode).UsingDirectives : ((NamespaceDeclaration)parentNode).UsingDirectives);
					if (usingDirectives == null) {
						usingDirectives = new UsingDirectiveSection();
						if (parentNode is CompilationUnit)
							((CompilationUnit)parentNode).UsingDirectives = usingDirectives;
						else
							((NamespaceDeclaration)parentNode).UsingDirectives = usingDirectives;
					}
					
					if (usingDirectives.Directives.Count == 0)
						usingDirectives.StartOffset = this.Token.StartOffset;
					if (this.AreNextTwoIdentifierAnd(CSharpTokenID.Assignment)) { 
				%>
						"UsingAliasDirective<@ usingDirectives @><- ->"
				<% 
					}
					else { 
				%>
						"UsingNamespaceDirective<@ usingDirectives @><- ->"
				<% 
					} 
					usingDirectives.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="UsingAliasDirective" Parameters="UsingDirectiveSection usingDirectives">
			<Production><![CDATA[
				<% 
					int startOffset = this.Token.StartOffset;
				%>
				"SimpleIdentifier<- ->"
				<% 
					string alias = this.TokenText;
					TypeReference typeReference; 
				%>
				'Assignment<- ->' 
				"TypeName<@ true, out typeReference @>" 
				'SemiColon<- ->'
				<%
					UsingDirective usingDirective = new UsingDirective(new TextRange(startOffset, this.Token.EndOffset));

					// Reap comments
					this.ReapComments(usingDirective.Comments, false);

					usingDirective.NamespaceName = new QualifiedIdentifier(typeReference.Name, typeReference.TextRange);
					usingDirective.Alias = alias;
					usingDirectives.Directives.Add(usingDirective);
				%>						
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="UsingNamespaceDirective" Parameters="UsingDirectiveSection usingDirectives">
			<Production><![CDATA[
				<% 
					int startOffset = this.Token.StartOffset;
					QualifiedIdentifier namespaceName; 
				%>
				"NamespaceName<@ out namespaceName @>" 
				'SemiColon<- ->'
				<%
					UsingDirective usingDirective = new UsingDirective(new TextRange(startOffset, this.Token.EndOffset));

					// Reap comments
					this.ReapComments(usingDirective.Comments, false);

					usingDirective.NamespaceName = namespaceName;
					usingDirectives.Directives.Add(usingDirective);
				%>						
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NamespaceMemberDeclaration">
			<Production><![CDATA[
				"NamespaceDeclaration"
				| (
					<%
						AttributeSection attributeSection;
						AstNodeList attributeSections = new AstNodeList(null);
						Modifiers modifiers = Modifiers.None;
						Modifiers singleModifier;
					%>
					{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +><- ->" }
					<%
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					{ "Modifier<@ out singleModifier @><+ modifiers |= singleModifier; +>" }
					"TypeDeclaration<@ startOffset, attributeSections, modifiers @>"
				)
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="TypeDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<Production><![CDATA[
				"ClassDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "StructDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "InterfaceDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "EnumDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "DelegateDeclaration<@ startOffset, attributeSections, modifiers @>"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Modifier" Parameters="out Modifiers modifier">
			<!-- NOTE: Modifier added to reduce ambiguity between type declarations -->
			<!-- NOTE: Partial keyword is .NET 2.0 -->
			<Production><![CDATA[
				<% modifier = Modifiers.None; %>
				'Public <+ modifier = Modifiers.Public; +><- ->'
				| 'Protected <+ modifier = Modifiers.Family; +><- ->'
				| 'Internal <+ modifier = Modifiers.Assembly; +><- ->'
				| 'Private <+ modifier = Modifiers.Private; +><- ->'
				| 'Abstract <+ modifier = Modifiers.Abstract; +><- ->'
				| 'Extern <+ modifier = Modifiers.Extern; +><- ->'
				| 'New <+ modifier = Modifiers.New; +><- ->' 
				| 'Partial <+ modifier = Modifiers.Partial; +><- ->'
				| 'Sealed <+ modifier = Modifiers.Final; +><- ->'
				| 'Static <+ modifier = Modifiers.Static; +><- ->'
				| 'Override <+ modifier = Modifiers.Override; +><- ->'
				| 'ReadOnly <+ modifier = Modifiers.ReadOnly; +><- ->'
				| 'Virtual <+ modifier = Modifiers.Virtual; +><- ->'
				| 'Volatile <+ modifier = Modifiers.Volatile; +><- ->'
				| 'Unsafe <+ modifier = Modifiers.Unsafe; +><- ->'
			]]></Production>
		</NonTerminal>

		<!-- C.2.7 Classes -->
		<NonTerminal Key="ClassDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and ClassModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				'Class'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to internal access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Assembly;
				
					ClassDeclaration classDeclaration = new ClassDeclaration(modifiers, identifier);
					classDeclaration.Documentation = this.ReapDocumentationComments();
					classDeclaration.StartOffset = startOffset;
					classDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					AstNodeList typeParameterList = null;
				%>
				[ "TypeParameterList<@ out typeParameterList @>" ]
				<%
					if (typeParameterList != null)
						classDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
				%>
				[ 
					'Colon<- ->' 
					<%
						TypeReference typeReference;
					%>
					"ClassType<@ false, out typeReference @><+ 
							// Ensure that generic type parameters are marked properly
							this.MarkGenericParameters(typeParameterList, typeReference, false);
							
							classDeclaration.BaseTypes.Add(typeReference); 
						+>
						<-
							// Error recovery:  Go to the next open curly brace
							this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
						->" 
					{ 
						'Comma
							<-
								// Error recovery:  Go to the next open curly brace
								this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
							->' 
						"ClassType<@ false, out typeReference @><+ 
								// Ensure that generic type parameters are marked properly
								this.MarkGenericParameters(typeParameterList, typeReference, false);
								
								classDeclaration.BaseTypes.Add(typeReference); 
							+>
							<-
								// Error recovery:  Go to the next open curly brace
								this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
							->" 
					}
				]
				[ "TypeParameterConstraintsClauses<@ typeParameterList @>" ]
				<%
					this.BlockAddChild(classDeclaration);
					AttributeSection attributeSection;
					Modifiers singleModifier;
					classDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
					int classCurlyBraceLevel = curlyBraceLevel;
				%>
				'OpenCurlyBrace'
				<%
					this.BlockStart(classDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == classCurlyBraceLevel + 1))
							break;
						else if (IsNonTerminal("AttributeSection") || IsNonTerminal("Modifier") || IsNonTerminal("ClassMemberDeclaration")) {
							errorReported = false;
							attributeSections = new AstNodeList(null);
							modifiers = Modifiers.None;
						%>
							{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +><- ->" }
							<%
								startOffset = this.LookAheadToken.StartOffset;
							%>
							{ "Modifier<@ out singleModifier @><+ modifiers |= singleModifier; +><- ->" }
							"ClassMemberDeclaration<@ classDeclaration, startOffset, attributeSections, modifiers @><- ->"
					<%
						}
						else {
							// Error recovery:  Advance to the next token since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ClassMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNext();
						}
					}
					this.ReapDocumentationComments();
				%>
				'CloseCurlyBrace<- ->'
				<%
					classDeclaration.BlockEndOffset = this.Token.EndOffset;
					this.BlockEnd();
				%>
				[ 'SemiColon' ]
				<%
					classDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapComments(classDeclaration.Comments, false);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ClassModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: ClassBase merged into ClassDeclaration -->
		<!-- NOTE: InterfaceTypeList merged into ClassDeclaration -->
		<!-- NOTE: ClassBody merged into ClassDeclaration -->
		<NonTerminal Key="ClassMemberDeclaration" Parameters="TypeDeclaration parentTypeDeclaration, int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<Production><![CDATA[
				"StructMemberDeclaration<@ parentTypeDeclaration, startOffset, attributeSections, modifiers @>"
				| (
					'OnesComplement'
					<%
						QualifiedIdentifier identifier;
					%>
					"Identifier<@ out identifier @>"
					<%
						// Destructor declaration
						DestructorDeclaration destructorDeclaration = new DestructorDeclaration(modifiers, identifier);
						destructorDeclaration.Documentation = this.ReapDocumentationComments();
						destructorDeclaration.StartOffset = startOffset;
						destructorDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					%>
					'OpenParenthesis'
					'CloseParenthesis'
					(
						'SemiColon'
						| (
							<%
								destructorDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
								Statement statement;
								int memberCurlyBraceLevel = curlyBraceLevel;
							%>
							'OpenCurlyBrace'
							<%
								bool errorReported = false;
								while (!this.IsAtEnd) {
									if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == memberCurlyBraceLevel + 1))
										break;
									else if (IsNonTerminal("Statement")) {
										errorReported = false;
								%>
										{ "Statement<@ out statement @><+ destructorDeclaration.Statements.Add(statement); +><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->" }
								<%
									}
									else {
										// Error recovery:  Advance to the next token since nothing was matched
										if (!errorReported) {
											this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
											errorReported = true;
										}
										this.AdvanceToNext();
									}
								}
								this.ReapDocumentationComments();

								// Reap comments
								this.ReapComments(destructorDeclaration.Comments, false);
							%>
							'CloseCurlyBrace<- ->'
							<%
								destructorDeclaration.BlockEndOffset = this.Token.EndOffset;
							%>								
						)
					)
					<%
						destructorDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(destructorDeclaration);
					%>
				)
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ConstantDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: ConstantModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: ConstantDeclarators merged into StructMemberDeclaration -->
		<NonTerminal Key="ConstantDeclarator" Parameters="FieldDeclaration constantDeclaration, TypeReference typeReference">
			<Production><![CDATA[
				<%
					QualifiedIdentifier identifier;
					Expression initializer = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"Identifier<@ out identifier @>"
				[
					'Assignment'
					"Expression<@ out initializer @>"
				]
				<%
					VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, identifier, true, false);
					variableDeclarator.Initializer = initializer;
					variableDeclarator.StartOffset = startOffset;
					variableDeclarator.EndOffset = this.Token.EndOffset;
					constantDeclaration.Variables.Add(variableDeclarator);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: FieldDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: FieldModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: VariableDeclarators merged into StructMemberDeclaration -->
		<NonTerminal Key="VariableDeclarator" Parameters="FieldDeclaration fieldDeclaration, TypeReference typeReference">
			<Production><![CDATA[
				<%
					QualifiedIdentifier identifier;
					Expression initializer = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"Identifier<@ out identifier @>"
				[
					'Assignment'
					"VariableInitializer<@ out initializer @>"
				]
				<%
					VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, identifier, false, false);
					variableDeclarator.Initializer = initializer;
					variableDeclarator.StartOffset = startOffset;
					variableDeclarator.EndOffset = this.Token.EndOffset;
					fieldDeclaration.Variables.Add(variableDeclarator);
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="VariableInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
				%>
				"Expression<@ out expression @>"
				| "ArrayInitializer<@ out expression @>"
				| "StackAllocInitializer<@ out expression @>"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: MethodDeclaration merged into StructMemberDeclaration -->
		<!-- NOTE: MethodHeader merged into StructMemberDeclaration -->
		<!-- NOTE: MethodModifier moved to Modifier to reduce ambiguity with type declarations -->
		<NonTerminal Key="ReturnType" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
					if ((!this.TokenIs(this.LookAheadToken, CSharpTokenID.Void)) || (this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.Multiplication))) {
				%>
						"Type<@ out typeReference @>" 
				<%
					}
					else {
						// Regular void (non-pointer)
				%>
						'Void<+ typeReference = new TypeReference("System.Void", this.Token.TextRange); +>'
				<%
					}
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="MemberName" Parameters="out TypeReference interfaceType, out QualifiedIdentifier identifier, out AstNodeList typeParameterList">
			<!-- NOTE: MemberName allows this keywords for indexers -->
			<Production><![CDATA[
				<%
					interfaceType = null;
					identifier = null;
					typeParameterList = null;
				%>
				'This<+ 
					identifier = new QualifiedIdentifier(this.TokenText, this.Token.TextRange); 
					return true;
					+>'
				| (
					"TypeName<@ true, out interfaceType @>"
					<%
						if (this.IsQualifierIdentifierContinuation()) {
							// The interface type is probably a generic... the next item is the name
							%>
							'Dot'
							"Identifier<@ out identifier @>"					
							<%
						}
						else if (this.AreNextTwo(CSharpTokenID.Dot, CSharpTokenID.This)) {
							// Ends with .this
							%>
							'Dot'
							'This<+ identifier = new QualifiedIdentifier(this.TokenText, this.Token.TextRange); +>'
							<%
						}
						else {
							int index = interfaceType.Name.LastIndexOf(".");
							if (index != -1) {
								// Interface type... remove the last item 
								string name = interfaceType.Name.Substring(index + 1);
								identifier = new QualifiedIdentifier(name, new TextRange(interfaceType.EndOffset - name.Length, interfaceType.EndOffset));
								interfaceType.EndOffset -= (name.Length + 1);
								interfaceType.Name = interfaceType.Name.Substring(0, index);				
							}
							else {
								// No interface
								identifier = new QualifiedIdentifier(interfaceType.Name, interfaceType.TextRange); 
								if (interfaceType.GenericTypeArguments != null) {
									typeParameterList = new AstNodeList(null);
									typeParameterList.AddRange(interfaceType.GenericTypeArguments.ToArray());
									
									// Flag each type parameter as a generic parameter
									foreach (TypeReference typeParameter in typeParameterList)
										typeParameter.IsGenericParameter = true;
								}
								interfaceType = null;
							}
						}
					%>
				)
			]]></Production>
		</NonTerminal>
		<!-- NOTE: MethodBody merged into StructMemberDeclaration -->
		<NonTerminal Key="FormalParameterList" Parameters="IAstNodeList genericTypeArguments, out AstNodeList parameterList">
			<Production><![CDATA[
				<%
					AttributeSection attributeSection;
					AstNodeList attributeSections = new AstNodeList(null);
					parameterList = new AstNodeList(null);
					ParameterDeclaration parameterDeclaration;
				%>
				{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
				(
					"FixedParameter<@ genericTypeArguments, attributeSections, out parameterDeclaration @><+ parameterList.Add(parameterDeclaration); +>"
					<%
						attributeSections = new AstNodeList(null);
					%>
					{<? (this.TokenIs(this.LookAheadToken, CSharpTokenID.Comma)) && (!this.IsParameterArray()) ?> 
						'Comma' 
						{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
						"FixedParameter<@ genericTypeArguments, attributeSections, out parameterDeclaration @><+ parameterList.Add(parameterDeclaration); +>" 
						<%
							attributeSections = new AstNodeList(null);
						%>
					}
					[ 
						'Comma' 
						{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
						"ParameterArray<@ genericTypeArguments, attributeSections, out parameterDeclaration @><+ parameterList.Add(parameterDeclaration); +>" 
					]
				)
				| "ParameterArray<@ genericTypeArguments, attributeSections, out parameterDeclaration @><+ parameterList.Add(parameterDeclaration); +>"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: FixedParameters merged into FormalParameterList -->
		<NonTerminal Key="FixedParameter" Parameters="IAstNodeList genericTypeArguments, AstNodeList attributeSections, out ParameterDeclaration fixedParameter">
			<Production><![CDATA[
				<%
					fixedParameter = null;
					ParameterModifiers modifiers = ParameterModifiers.None;
					TypeReference typeReference;
					Expression initializer = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				[ 
					'Ref<+ modifiers = ParameterModifiers.Ref; +>' 
					| 'Out<+ modifiers = ParameterModifiers.Out; +>' 
				]
				"Type<@ out typeReference @><+ this.MarkGenericParameters(genericTypeArguments, typeReference, true); +>" 
				"SimpleIdentifier"
				[
					'Assignment'
					"Expression<@ out initializer @><+ modifiers = ParameterModifiers.Optional; +><- ->"
				]
				<%
					fixedParameter = new ParameterDeclaration(modifiers, this.TokenText);
					fixedParameter.StartOffset = startOffset;
					fixedParameter.EndOffset = this.Token.EndOffset;
					if (attributeSections != null)
						fixedParameter.AttributeSections.AddRange(attributeSections.ToArray());
					fixedParameter.ParameterType = typeReference;
					fixedParameter.Initializer = initializer;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ParameterModifier merged into FixedParameter -->
		<NonTerminal Key="ParameterArray" Parameters="IAstNodeList genericTypeArguments, AstNodeList attributeSections, out ParameterDeclaration parameterArray">
			<Production><![CDATA[
				<%
					parameterArray = null;
					TypeReference typeReference;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				'Params'
				"Type<@ out typeReference @><+ this.MarkGenericParameters(genericTypeArguments, typeReference, true); +>" 
				"SimpleIdentifier"
				<%
					parameterArray = new ParameterDeclaration(ParameterModifiers.ParameterArray, this.TokenText);
					parameterArray.StartOffset = startOffset;
					parameterArray.EndOffset = this.Token.EndOffset;
					parameterArray.AttributeSections.AddRange(attributeSections.ToArray());
					parameterArray.ParameterType = typeReference;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: PropertyDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: PropertyModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: AccessorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: GetAccessorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: SetAccessorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: AccessorBlock merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: EventDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: EventModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: EventAccessorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: AddAccessorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: RemoveAccessorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: IndexerDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: IndexerModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: IndexerDeclarator merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: OperatorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: OperatorModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: OperatorDeclarator merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: UnaryOperatorDeclarator merged into StructMemberDeclaration to reduce ambiguity -->
		<NonTerminal Key="OverloadableOperator" Parameters="out OperatorType operatorType">
			<!-- NOTE: OverloadableOperator added to handle OverloadableUnaryOperator and OverloadableBinaryOperator -->
			<AdditionalConditions>
				<ExpressionCondition>this.IsRightShift()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<% 
					operatorType = OperatorType.None; 
				%>
				'Addition <+ operatorType = OperatorType.Addition; +>'
				| 'Subtraction <+ operatorType = OperatorType.Subtraction; +>'
				| 'Multiplication <+ operatorType = OperatorType.Multiply; +>'
				| 'Division <+ operatorType = OperatorType.Division; +>'
				| 'Modulus <+ operatorType = OperatorType.Modulus; +>'
				| 'BitwiseAnd <+ operatorType = OperatorType.BitwiseAnd; +>'
				| 'BitwiseOr <+ operatorType = OperatorType.BitwiseOr; +>' 
				| 'ExclusiveOr <+ operatorType = OperatorType.ExclusiveOr; +>'
				| 'Negation <+ operatorType = OperatorType.Negation; +>'
				| 'OnesComplement <+ operatorType = OperatorType.OnesComplement; +>'
				| 'LeftShift <+ operatorType = OperatorType.LeftShift; +>'
				| <? this.IsRightShift() ?> (
					<%
						// NOTE: This handles ambiguity between right shift and generic type specifications in .NET 2.0
					%>
					'GreaterThan'
					'GreaterThan<+ operatorType = OperatorType.RightShift; +>'
				)
				| 'LessThan <+ operatorType = OperatorType.LessThan; +>'
				| 'GreaterThan <+ operatorType = OperatorType.GreaterThan; +>'
				| 'Increment <+ operatorType = OperatorType.PreIncrement; // NOTE: Means the same as PostIncrement +>'
				| 'Decrement <+ operatorType = OperatorType.PreDecrement; // NOTE: Means the same as PostDecrement +>'
				| 'Equality <+ operatorType = OperatorType.Equality; +>'
				| 'Inequality <+ operatorType = OperatorType.Inequality; +>'
				| 'LessThanOrEqual <+ operatorType = OperatorType.LessThanOrEqual; +>'
				| 'GreaterThanOrEqual <+ operatorType = OperatorType.GreaterThanOrEqual; +>'
				| 'True <+ operatorType = OperatorType.True; +>'
				| 'False <+ operatorType = OperatorType.False; +>'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: OverloadableUnaryOperator merged into OverloadableOperator to reduce ambiguity -->
		<!-- NOTE: BinaryOperatorDeclarator merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: OverloadableBinaryOperator merged into OverloadableOperator to reduce ambiguity -->
		<!-- NOTE: ConversionOperatorDeclarator merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: OperatorBody merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: ConstructorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: ConstructorModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: ConstructorDeclarator merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: ConstructorInitializer merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: ConstructorBody merged into StructMemberDeclaration to reduce ambiguity -->		
		<!-- NOTE: StaticConstructorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: StaticConstructorModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: StaticConstructorBody merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: DestructorDeclaration merged into StructMemberDeclaration to reduce ambiguity -->
		<!-- NOTE: DestructorBody merged into StructMemberDeclaration to reduce ambiguity -->
		
		<!-- C.2.8 Structs -->
		<NonTerminal Key="StructDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and StructModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				'Struct'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to internal access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Assembly;
				
					StructureDeclaration structureDeclaration = new StructureDeclaration(modifiers, identifier);
					structureDeclaration.Documentation = this.ReapDocumentationComments();
					structureDeclaration.StartOffset = startOffset;
					structureDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					AstNodeList typeParameterList = null;
				%>
				[ "TypeParameterList<@ out typeParameterList @>" ]
				<%
					if (typeParameterList != null)
						structureDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
				%>
				[ 
					'Colon<- ->' 
					<%
						TypeReference typeReference;
					%>
					"ClassType<@ false, out typeReference @><+ structureDeclaration.BaseTypes.Add(typeReference); +>
						<-
							// Error recovery:  Go to the next open curly brace
							this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
						->" 
					{ 
						'Comma
							<-
								// Error recovery:  Go to the next open curly brace
								this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
							->' 
						"ClassType<@ false, out typeReference @><+ structureDeclaration.BaseTypes.Add(typeReference); +>
							<-
								// Error recovery:  Go to the next open curly brace
								this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
							->" 
					}
				]
				[ "TypeParameterConstraintsClauses<@ typeParameterList @>" ]
				<%
					this.BlockAddChild(structureDeclaration);
					AttributeSection attributeSection;
					Modifiers singleModifier;
					structureDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
					int structureCurlyBraceLevel = curlyBraceLevel;
				%>
				'OpenCurlyBrace'
				<%
					this.BlockStart(structureDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == structureCurlyBraceLevel + 1))
							break;
						else if (IsNonTerminal("AttributeSection") || IsNonTerminal("Modifier") || IsNonTerminal("StructMemberDeclaration")) {
							errorReported = false;
							attributeSections = new AstNodeList(null);
							modifiers = Modifiers.None;
						%>
							{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +><- ->" }
							<%
								startOffset = this.LookAheadToken.StartOffset;
							%>
							{ "Modifier<@ out singleModifier @><+ modifiers |= singleModifier; +><- ->" }
							(
								"FixedSizeBufferDeclaration<@ startOffset, attributeSections, modifiers @><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->"
								| "StructMemberDeclaration<@ structureDeclaration, startOffset, attributeSections, modifiers @><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->"
							)
					<%
						}
						else {
							// Error recovery:  Advance to the next token since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StructureMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNext();
						}
					}
					this.ReapDocumentationComments();
				%>
				'CloseCurlyBrace<- ->'
				<%
					structureDeclaration.BlockEndOffset = this.Token.EndOffset;
					this.BlockEnd();
				%>
				[ 'SemiColon' ]
				<%
					structureDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapComments(structureDeclaration.Comments, false);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: StructModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: StructInterfaces merged into StructDeclaration -->
		<!-- NOTE: StructBody merged into StructDeclaration -->
		<NonTerminal Key="StructMemberDeclaration" Parameters="TypeDeclaration parentTypeDeclaration, int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<Production><![CDATA[
				<%
					// Build a list of generic type arguments for the parent type... will add to this collection if a generic method
					AstNodeList scopedGenericTypeArguments = new AstNodeList(null);
					if ((parentTypeDeclaration.GenericTypeArguments != null) && (parentTypeDeclaration.GenericTypeArguments.Count > 0))
						scopedGenericTypeArguments.AddRange(parentTypeDeclaration.GenericTypeArguments.ToArray());					
				%>			
				
				(
					<%
						// Constant declaration
						// NOTE: Attributes and ConstantModifier (alias Modifier) moved to callers of StructMemberDeclaration to reduce ambiguity
					%>
					'Const'
					<%
						TypeReference typeReference;
						FieldDeclaration constantDeclaration = new FieldDeclaration(modifiers);
						constantDeclaration.Documentation = this.ReapDocumentationComments();
						constantDeclaration.StartOffset = startOffset;
						constantDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					%>
					"Type<@ out typeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>" 							
					
					"ConstantDeclarator<@ constantDeclaration, typeReference @>"
					{ 'Comma' "ConstantDeclarator<@ constantDeclaration, typeReference @>" }
					'SemiColon'
					<%
						constantDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(constantDeclaration);
						this.ReapDocumentationComments();						
						return true;
					%>
				)
				| <? ((this.TokenIs(this.LookAheadToken, CSharpTokenID.Void)) && (!this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.Multiplication))) ?> (
					<%
						// Void method declaration
						TypeReference typeReference = new TypeReference("System.Void", this.LookAheadToken.TextRange);
						TypeReference interfaceType;
						QualifiedIdentifier name;
						AstNodeList typeParameterList;
						bool isExtension = false;
					%>
					'Void'
					"MemberName<@ out interfaceType, out name, out typeParameterList @>"
					<%
						// Add to the scoped generic type arguments
						if ((typeParameterList != null) && (typeParameterList.Count > 0))
							scopedGenericTypeArguments.AddRange(typeParameterList.ToArray());					
					
						MethodDeclaration methodDeclaration = new MethodDeclaration(modifiers, name);
						methodDeclaration.Documentation = this.ReapDocumentationComments();
						methodDeclaration.StartOffset = startOffset;
						methodDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						methodDeclaration.ReturnType = typeReference;
						if (interfaceType != null)
							methodDeclaration.ImplementedMembers.Add(new MemberSpecifier(interfaceType, name));
						if (typeParameterList != null)
							methodDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
						AstNodeList parameterList = null;
					%>					
					'OpenParenthesis'
					[ 'This<+ 							
							// Ensure that the containing block is a static class declaration
							if ((parentTypeDeclaration == null) || (!(parentTypeDeclaration is ClassDeclaration)) || 
								((((ClassDeclaration)parentTypeDeclaration).Modifiers & Modifiers.Static) == 0)) {
								this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ExtensionMethodsInStaticClass"));								
							}
							else {
								isExtension = true; 
		
								// Add an Extension attribute to the method
								AttributeSection attributeSection = new AttributeSection();
								attributeSection.Attributes.Add(new ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute(new TypeReference("System.Runtime.CompilerServices.Extension", TextRange.Deleted)));
								methodDeclaration.AttributeSections.Add(attributeSection);
								
								// Add an Extension attribute to the type declaration
								if (!parentTypeDeclaration.IsExtension)
									parentTypeDeclaration.AttributeSections.Add(attributeSection);														
							}
						+>' ]
					[ "FormalParameterList<@ scopedGenericTypeArguments, out parameterList @>" ]
					<%
						if ((parameterList != null) && (parameterList.Count > 0))
							methodDeclaration.Parameters.AddRange(parameterList.ToArray());
						else if (isExtension)
							this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ExtensionMethodsRequireOneParameter"));
					%>
					'CloseParenthesis'
					[ "TypeParameterConstraintsClauses<@ typeParameterList @>" ]
					(
						'SemiColon'
						| (
							<%
								methodDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
								Statement statement;
								int memberCurlyBraceLevel = curlyBraceLevel;
							%>
							'OpenCurlyBrace'
							<%
								bool errorReported = false;
								while (!this.IsAtEnd) {
									if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == memberCurlyBraceLevel + 1))
										break;
									else if (IsNonTerminal("Statement")) {
										errorReported = false;
								%>
										{ "Statement<@ out statement @><+ methodDeclaration.Statements.Add(statement); +><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->" }
								<%
									}
									else {
										// Error recovery:  Advance to the next token since nothing was matched
										if (!errorReported) {
											this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
											errorReported = true;
										}
										this.AdvanceToNext();
									}
								}
								this.ReapDocumentationComments();
								
								// Reap comments
								this.ReapComments(methodDeclaration.Comments, false);
							%>
							'CloseCurlyBrace<- ->'
							<%
								methodDeclaration.BlockEndOffset = this.Token.EndOffset;
							%>								
						)
					)
					<%
						methodDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(methodDeclaration);
					%>
				)
				| (
					<%
						// Implicit/explicit operator declaration
						OperatorType operatorType = OperatorType.None;
						TypeReference typeReference;
						TypeReference parameterTypeReference;
						ParameterDeclaration parameter;
					%>
					(
						'Implicit<+ operatorType = OperatorType.Implicit; +>' 
						| 'Explicit<+ operatorType = OperatorType.Explicit; +>'
					)
					'Operator'
					"Type<@ out typeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>"
					'OpenParenthesis'
					<%
						int parameterStartOffset = this.LookAheadToken.StartOffset;
					%>
					"Type<@ out parameterTypeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, parameterTypeReference, true); +>" 
					"SimpleIdentifier"
					<%
						parameter = new ParameterDeclaration(ParameterModifiers.None, this.TokenText);
						parameter.StartOffset = parameterStartOffset;
						parameter.EndOffset = this.Token.EndOffset;
						parameter.ParameterType = parameterTypeReference;
					%>
					'CloseParenthesis'
					<%
						OperatorDeclaration operatorDeclaration = new OperatorDeclaration(modifiers, operatorType);
						operatorDeclaration.Documentation = this.ReapDocumentationComments();
						operatorDeclaration.StartOffset = startOffset;
						operatorDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						operatorDeclaration.ReturnType = typeReference;
						if (parameter != null)
							operatorDeclaration.Parameters.Add(parameter);
					%>
					(
						'SemiColon'
						| (
							<%
								operatorDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
								Statement statement;
								int memberCurlyBraceLevel = curlyBraceLevel;
							%>
							'OpenCurlyBrace'
							<%
								bool errorReported = false;
								while (!this.IsAtEnd) {
									if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == memberCurlyBraceLevel + 1))
										break;
									else if (IsNonTerminal("Statement")) {
										errorReported = false;
								%>
										{ "Statement<@ out statement @><+ operatorDeclaration.Statements.Add(statement); +><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->" }
								<%
									}
									else {
										// Error recovery:  Advance to the next token since nothing was matched
										if (!errorReported) {
											this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
											errorReported = true;
										}
										this.AdvanceToNext();
									}
								}
								this.ReapDocumentationComments();
								
								// Reap comments
								this.ReapComments(operatorDeclaration.Comments, false);
							%>
							'CloseCurlyBrace<- ->'
							<%
								operatorDeclaration.BlockEndOffset = this.Token.EndOffset;
							%>								
						)
					)
					<%
						operatorDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(operatorDeclaration);
						this.ReapDocumentationComments();
						return true;
					%>
				)
				| (
					<%
						// Event declaration
						// NOTE: Attributes and EventModifier (alias Modifier) moved to callers of StructMemberDeclaration to reduce ambiguity 
					%>
					'Event'
					<%
						TypeReference typeReference;
						TypeReference interfaceType;
						QualifiedIdentifier identifier;
						AstNodeList typeParameterList;
					%>
					"Type<@ out typeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>"
					"MemberName<@ out interfaceType, out identifier, out typeParameterList @>"
					<%
						EventDeclaration eventDeclaration = new EventDeclaration(modifiers, identifier);
						eventDeclaration.Documentation = this.ReapDocumentationComments();
						eventDeclaration.StartOffset = startOffset;
						eventDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						eventDeclaration.EventType = typeReference;
						if (interfaceType != null)
							eventDeclaration.ImplementedMembers.Add(new MemberSpecifier(interfaceType, identifier));
					%>
					(
						'SemiColon'
						| {
							<%
								AttributeSection attributeSection;
								bool isAddAccessor = true;
								Statement block = null;
							%>
							'OpenCurlyBrace'
							<%
								AccessorDeclaration accessorDeclaration = new AccessorDeclaration();							
								accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
								Modifiers singleModifier;
							%>
							{ "AttributeSection<@ out attributeSection @><+ accessorDeclaration.AttributeSections.Add(attributeSection); +>" }
							{ "Modifier<@ out singleModifier @><+ accessorDeclaration.Modifiers |= singleModifier; +>" }											
							(
								'Add<+ isAddAccessor = true; +>'
								| 'Remove<+ isAddAccessor = false; +>'
							)
							'SemiColon'
							| "Block<@ out block @>"
							<%
								accessorDeclaration.BlockStatement = block as BlockStatement;
								accessorDeclaration.EndOffset = this.Token.EndOffset;
								if (isAddAccessor)
									eventDeclaration.AddAccessor = accessorDeclaration;
								else
									eventDeclaration.RemoveAccessor = accessorDeclaration;
							%>
							[
								<%
									isAddAccessor = true;
									block = null;
									accessorDeclaration = new AccessorDeclaration();							
									accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
								%>
								{ "AttributeSection<@ out attributeSection @><+ accessorDeclaration.AttributeSections.Add(attributeSection); +>" }
								{ "Modifier<@ out singleModifier @><+ accessorDeclaration.Modifiers |= singleModifier; +>" }											
								(
									'Add<+ isAddAccessor = true; +>'
									| 'Remove<+ isAddAccessor = false; +>'
								)
								'SemiColon'
								| "Block<@ out block @>"
								<%
									accessorDeclaration.BlockStatement = block as BlockStatement;
									accessorDeclaration.EndOffset = this.Token.EndOffset;
									if (isAddAccessor)
										eventDeclaration.AddAccessor = accessorDeclaration;
									else
										eventDeclaration.RemoveAccessor = accessorDeclaration;
								%>
							]
							<%
								this.ReapDocumentationComments();
							%>
							'CloseCurlyBrace<- ->'
						}
					)
					<%
						eventDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(eventDeclaration);
						this.ReapDocumentationComments();
						return true;
					%>
				)
				| (
					"TypeDeclaration<@ startOffset, attributeSections, modifiers @>"
					<%
						return true;
					%>
				)
				| (
				<% 
					if (!this.AreNextTwoIdentifierAnd(CSharpTokenID.OpenParenthesis)) {
						TypeReference typeReference;
				%>
						"Type<@ out typeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>"
						(
							'Operator'
							<%
								// Operator declaration
								// NOTE: Attributes and OperatorModifier (alias Modifier) moved to callers of StructMemberDeclaration to reduce ambiguity 
								OperatorType operatorType;
								TypeReference parameter1TypeReference;
								ParameterDeclaration parameter1;
								TypeReference parameter2TypeReference = null;
								ParameterDeclaration parameter2 = null;
							%>
							"OverloadableOperator<@ out operatorType @>"
							'OpenParenthesis'
							<%
								int parameterStartOffset = this.LookAheadToken.StartOffset;
							%>
							"Type<@ out parameter1TypeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, parameter1TypeReference, true); +>" 
							"SimpleIdentifier"
							<%
								parameter1 = new ParameterDeclaration(ParameterModifiers.None, this.TokenText);
								parameter1.StartOffset = parameterStartOffset;
								parameter1.EndOffset = this.Token.EndOffset;
								parameter1.ParameterType = parameter1TypeReference;
							%>
							[
								<%
									parameterStartOffset = this.LookAheadToken.StartOffset;
								%>
								'Comma'
								"Type<@ out parameter2TypeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, parameter2TypeReference, true); +>" 
								"SimpleIdentifier"
								<%
									parameter2 = new ParameterDeclaration(ParameterModifiers.None, this.TokenText);
									parameter2.StartOffset = parameterStartOffset;
									parameter2.EndOffset = this.Token.EndOffset;
									parameter2.ParameterType = parameter2TypeReference;
								%>
							]
							'CloseParenthesis'
							<%
								OperatorDeclaration operatorDeclaration = new OperatorDeclaration(modifiers, operatorType);
								operatorDeclaration.Documentation = this.ReapDocumentationComments();
								operatorDeclaration.StartOffset = startOffset;
								operatorDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
								operatorDeclaration.ReturnType = typeReference;
								if (parameter1 != null)
									operatorDeclaration.Parameters.Add(parameter1);
								if (parameter2 != null)
									operatorDeclaration.Parameters.Add(parameter2);
							%>
							(
								'SemiColon'
								| (
									<%
										operatorDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
										Statement statement;
										int memberCurlyBraceLevel = curlyBraceLevel;
									%>
									'OpenCurlyBrace'
									<%
										bool errorReported = false;
										while (!this.IsAtEnd) {
											if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == memberCurlyBraceLevel + 1))
												break;
											else if (IsNonTerminal("Statement")) {
												errorReported = false;
										%>
												{ "Statement<@ out statement @><+ operatorDeclaration.Statements.Add(statement); +><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->" }
										<%
											}
											else {
												// Error recovery:  Advance to the next token since nothing was matched
												if (!errorReported) {
													this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
													errorReported = true;
												}
												this.AdvanceToNext();
											}
										}
										this.ReapDocumentationComments();
										
										// Reap comments
										this.ReapComments(operatorDeclaration.Comments, false);
									%>
									'CloseCurlyBrace<- ->'
									<%
										operatorDeclaration.BlockEndOffset = this.Token.EndOffset;
									%>								
								)
							)
							<%
								operatorDeclaration.EndOffset = this.Token.EndOffset;
								this.BlockAddChild(operatorDeclaration);
							%>
						)
						| (							
							<%
								if (!this.IsVariableDeclarator()) {
									TypeReference interfaceType;
									QualifiedIdentifier name;
									AstNodeList typeParameterList;									
							%>
									"MemberName<@ out interfaceType, out name, out typeParameterList @>"
									<%
										// Add to the scoped generic type arguments
										if ((typeParameterList != null) && (typeParameterList.Count > 0))
											scopedGenericTypeArguments.AddRange(typeParameterList.ToArray());					
									%>
									(
										<%
											// Indexer declaration
											// NOTE: Attributes and IndexerModifier (alias Modifier) moved to callers of StructMemberDeclaration to reduce ambiguity 
										%>
										'OpenSquareBrace'
										<%
											AstNodeList parameterList;
										%>
										"FormalParameterList<@ scopedGenericTypeArguments, out parameterList @>"
										'CloseSquareBrace'
										<%
											PropertyDeclaration indexerDeclaration = new PropertyDeclaration(modifiers, null);
											indexerDeclaration.Documentation = this.ReapDocumentationComments();
											indexerDeclaration.StartOffset = startOffset;
											indexerDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
											indexerDeclaration.ReturnType = typeReference;
											if (interfaceType != null)
												indexerDeclaration.ImplementedMembers.Add(new MemberSpecifier(interfaceType, name));
											indexerDeclaration.Parameters.AddRange(parameterList.ToArray());
											indexerDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
											AttributeSection attributeSection;
											bool isGetAccessor = true;
											Statement block = null;
											Modifiers singleModifier;
										%>
										'OpenCurlyBrace'
										<%
											AccessorDeclaration accessorDeclaration = new AccessorDeclaration();							
											accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
										%>
										{ "AttributeSection<@ out attributeSection @><+ accessorDeclaration.AttributeSections.Add(attributeSection); +>" }
										{ "Modifier<@ out singleModifier @><+ accessorDeclaration.Modifiers |= singleModifier; +>" }											
										(
											'Get<+ isGetAccessor = true; +>'
											| 'Set<+ isGetAccessor = false; +>'
										)
										'SemiColon'
										| "Block<@ out block @>"
										<%
											accessorDeclaration.BlockStatement = block as BlockStatement;
											accessorDeclaration.EndOffset = this.Token.EndOffset;
											if (isGetAccessor)
												indexerDeclaration.GetAccessor = accessorDeclaration;
											else
												indexerDeclaration.SetAccessor = accessorDeclaration;
										%>
										[
											<%
												isGetAccessor = true;
												block = null;
												accessorDeclaration = new AccessorDeclaration();							
												accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
											%>
											{ "AttributeSection<@ out attributeSection @><+ accessorDeclaration.AttributeSections.Add(attributeSection); +>" }
											{ "Modifier<@ out singleModifier @><+ accessorDeclaration.Modifiers |= singleModifier; +>" }											
											(
												'Get<+ isGetAccessor = true; +>'
												| 'Set<+ isGetAccessor = false; +>'
											)
											'SemiColon'
											| "Block<@ out block @>"
											<%
												accessorDeclaration.BlockStatement = block as BlockStatement;
												accessorDeclaration.EndOffset = this.Token.EndOffset;
												if (isGetAccessor)
													indexerDeclaration.GetAccessor = accessorDeclaration;
												else
													indexerDeclaration.SetAccessor = accessorDeclaration;
											%>
										]
										<%
											this.ReapDocumentationComments();
										%>
										'CloseCurlyBrace<- ->'
										<%
											indexerDeclaration.BlockEndOffset = this.Token.EndOffset;
											indexerDeclaration.EndOffset = this.Token.EndOffset;
											this.BlockAddChild(indexerDeclaration);
										%>
									)
									| (
										(
											<%
												// Method declaration
												MethodDeclaration methodDeclaration = new MethodDeclaration(modifiers, name);
												methodDeclaration.Documentation = this.ReapDocumentationComments();
												methodDeclaration.StartOffset = startOffset;
												methodDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
												if (typeReference != null) {
													methodDeclaration.ReturnType = typeReference;
													this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true);
												}
												if (interfaceType != null)
													methodDeclaration.ImplementedMembers.Add(new MemberSpecifier(interfaceType, name));
												if (typeParameterList != null)
													methodDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
												AstNodeList parameterList = null;
												bool isExtension = false;
											%>					
											'OpenParenthesis'
											[ 'This<+
													// Ensure that the containing block is a static class declaration
													if ((parentTypeDeclaration == null) || (!(parentTypeDeclaration is ClassDeclaration)) || 
														((((ClassDeclaration)parentTypeDeclaration).Modifiers & Modifiers.Static) == 0)) {
														this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ExtensionMethodsInStaticClass"));								
													}
													else {
														isExtension = true; 
								
														// Add an Extension attribute to the method
														AttributeSection attributeSection = new AttributeSection();
														attributeSection.Attributes.Add(new ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute(new TypeReference("System.Runtime.CompilerServices.Extension", TextRange.Deleted)));
														methodDeclaration.AttributeSections.Add(attributeSection);
														
														// Add an Extension attribute to the type declaration
														if (!parentTypeDeclaration.IsExtension)
															parentTypeDeclaration.AttributeSections.Add(attributeSection);														
													}
												+>' ]
											[ "FormalParameterList<@ scopedGenericTypeArguments, out parameterList @>" ]
											<%
												if ((parameterList != null) && (parameterList.Count > 0))
													methodDeclaration.Parameters.AddRange(parameterList.ToArray());
												else if (isExtension)
													this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ExtensionMethodsRequireOneParameter"));
											%>
											'CloseParenthesis'
											[ "TypeParameterConstraintsClauses<@ typeParameterList @>" ]
											(
												'SemiColon'
												| (
													<%
														methodDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
														Statement statement;
														int memberCurlyBraceLevel = curlyBraceLevel;
													%>
													'OpenCurlyBrace'
													<%
														bool errorReported = false;
														while (!this.IsAtEnd) {
															if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == memberCurlyBraceLevel + 1))
																break;
															else if (IsNonTerminal("Statement")) {
																errorReported = false;
														%>
																{ "Statement<@ out statement @><+ methodDeclaration.Statements.Add(statement); +><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->" }
														<%
															}
															else {
																// Error recovery:  Advance to the next token since nothing was matched
																if (!errorReported) {
																	this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
																	errorReported = true;
																}
																this.AdvanceToNext();
															}
														}
														this.ReapDocumentationComments();
														
														// Reap comments
														this.ReapComments(methodDeclaration.Comments, false);
													%>
													'CloseCurlyBrace<- ->'
													<%
														methodDeclaration.BlockEndOffset = this.Token.EndOffset;
													%>								
												)
											)
											<%
												methodDeclaration.EndOffset = this.Token.EndOffset;
												this.BlockAddChild(methodDeclaration);
											%>
										)
										| (
											<%
												// Property declaration
												PropertyDeclaration propertyDeclaration = new PropertyDeclaration(modifiers, name);
												propertyDeclaration.Documentation = this.ReapDocumentationComments();
												propertyDeclaration.StartOffset = startOffset;
												propertyDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
												propertyDeclaration.ReturnType = typeReference;
												if (interfaceType != null)
													propertyDeclaration.ImplementedMembers.Add(new MemberSpecifier(interfaceType, name));
												propertyDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
												AttributeSection attributeSection;
												bool isGetAccessor = true;
												Statement block = null;
												Modifiers singleModifier;
											%>
											'OpenCurlyBrace'
											<%
												AccessorDeclaration accessorDeclaration = new AccessorDeclaration();							
												accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
											%>
											{ "AttributeSection<@ out attributeSection @><+ accessorDeclaration.AttributeSections.Add(attributeSection); +>" }
											{ "Modifier<@ out singleModifier @><+ accessorDeclaration.Modifiers |= singleModifier; +>" }											
											(
												'Get<+ isGetAccessor = true; +>'
												| 'Set<+ isGetAccessor = false; +>'
											)
											'SemiColon'
											| "Block<@ out block @>"
											<%
												accessorDeclaration.BlockStatement = block as BlockStatement;
												accessorDeclaration.EndOffset = this.Token.EndOffset;
												if (isGetAccessor)
													propertyDeclaration.GetAccessor = accessorDeclaration;
												else
													propertyDeclaration.SetAccessor = accessorDeclaration;
											%>
											[
												<%
													isGetAccessor = true;
													block = null;
													accessorDeclaration = new AccessorDeclaration();							
													accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
												%>
												{ "AttributeSection<@ out attributeSection @><+ accessorDeclaration.AttributeSections.Add(attributeSection); +>" }
												{ "Modifier<@ out singleModifier @><+ accessorDeclaration.Modifiers |= singleModifier; +>" }											
												(
													'Get<+ isGetAccessor = true; +>'
													| 'Set<+ isGetAccessor = false; +>'
												)
												'SemiColon'
												| "Block<@ out block @>"
												<%
													accessorDeclaration.BlockStatement = block as BlockStatement;
													accessorDeclaration.EndOffset = this.Token.EndOffset;
													if (isGetAccessor)
														propertyDeclaration.GetAccessor = accessorDeclaration;
													else
														propertyDeclaration.SetAccessor = accessorDeclaration;
												%>
											]
											<%
												this.ReapDocumentationComments();
											%>
											'CloseCurlyBrace<- ->'
											<%
												propertyDeclaration.BlockEndOffset = this.Token.EndOffset;
												propertyDeclaration.EndOffset = this.Token.EndOffset;
												this.BlockAddChild(propertyDeclaration);
											%>
										)
									)
							<%
								}
								else {
									// Field declaration
									//  NOTE: Attributes and FieldModifier (alias Modifier) moved to callers of StructMemberDeclaration to reduce ambiguity
									FieldDeclaration fieldDeclaration = new FieldDeclaration(modifiers);
									fieldDeclaration.Documentation = this.ReapDocumentationComments();
									fieldDeclaration.StartOffset = startOffset;
									fieldDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
								%>
									"VariableDeclarator<@ fieldDeclaration, typeReference @>"
									{ 'Comma' "VariableDeclarator<@ fieldDeclaration, typeReference @>" }
									'SemiColon'
									<%
										fieldDeclaration.EndOffset = this.Token.EndOffset;
										this.BlockAddChild(fieldDeclaration);
								}
							%>
						)
				<%						
					}
					else {
				%>
						<%
							QualifiedIdentifier identifier;
						%>
						"Identifier<@ out identifier @>"
						<%
							// Constructor declaration
							bool isStatic = ((modifiers & Modifiers.Static) == Modifiers.Static);
							ConstructorDeclaration constructorDeclaration = new ConstructorDeclaration(modifiers, identifier);
							constructorDeclaration.Documentation = this.ReapDocumentationComments();
							constructorDeclaration.StartOffset = startOffset;
							constructorDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
							AstNodeList parameterList = null;
						%>
							'OpenParenthesis'
						<%
							if (!isStatic) {
						%>
								[ "FormalParameterList<@ scopedGenericTypeArguments, out parameterList @>" ]
						<%
									if (parameterList != null)
										constructorDeclaration.Parameters.AddRange(parameterList.ToArray());
							}
						%>
							'CloseParenthesis'
						<%
							if (!isStatic) {
						%>
								[
									'Colon'
									( 
										'Base<+ constructorDeclaration.InitializerType = ConstructorInitializerType.Base; +>' 
										| 'This<+ constructorDeclaration.InitializerType = ConstructorInitializerType.This; +>'
									)
									<%
										AstNodeList initializerArgumentList = null;										
									%>
									'OpenParenthesis'
									[ "ArgumentList<@ out initializerArgumentList @>" ]
									'CloseParenthesis'
									<%
										if (initializerArgumentList != null)
											constructorDeclaration.InitializerArguments.AddRange(initializerArgumentList.ToArray());
									%>
								]
						<%
							}
						%>
							(
								'SemiColon'
								| (
									<%
										constructorDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
										Statement statement;
										int memberCurlyBraceLevel = curlyBraceLevel;
									%>
									'OpenCurlyBrace'
									<%
										bool errorReported = false;
										while (!this.IsAtEnd) {
											if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == memberCurlyBraceLevel + 1))
												break;
											else if (IsNonTerminal("Statement")) {
												errorReported = false;
										%>
												{ "Statement<@ out statement @><+ constructorDeclaration.Statements.Add(statement); +><- if (!this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) this.AdvanceToNext(); ->" }
										<%
											}
											else {
												// Error recovery:  Advance to the next token since nothing was matched
												if (!errorReported) {
													this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
													errorReported = true;
												}
												this.AdvanceToNext();
											}
										}
										this.ReapDocumentationComments();
										
										// Reap comments
										this.ReapComments(constructorDeclaration.Comments, false);
									%>
									'CloseCurlyBrace<- ->'
									<%
										constructorDeclaration.BlockEndOffset = this.Token.EndOffset;
									%>								
								)
							)
						<%
							constructorDeclaration.EndOffset = this.Token.EndOffset;
							this.BlockAddChild(constructorDeclaration);
					}
				%>
				)
			]]></Production>
		</NonTerminal>
		
		<!-- C.2.9 Arrays -->
		<NonTerminal Key="ArrayInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = new ObjectCollectionInitializerExpression();
					expression.StartOffset = this.LookAheadToken.StartOffset;
				%>
				'OpenCurlyBrace'
				[
					<%
						Expression variableInitializer;
					%>
					"VariableInitializer<@ out variableInitializer @><+ ((ObjectCollectionInitializerExpression)expression).Initializers.Add(variableInitializer); +>"
					{
						'Comma'
						<%
							if (this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace))
								break;
						%>
						"VariableInitializer<@ out variableInitializer @><+ ((ObjectCollectionInitializerExpression)expression).Initializers.Add(variableInitializer); +>"
					}
				]
				'CloseCurlyBrace'
				<%
					expression.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		
		<!-- C.2.10 Interfaces -->
		<NonTerminal Key="InterfaceDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and InterfaceModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				'Interface'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to internal access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Assembly;
				
					InterfaceDeclaration interfaceDeclaration = new InterfaceDeclaration(modifiers, identifier);
					interfaceDeclaration.Documentation = this.ReapDocumentationComments();
					interfaceDeclaration.StartOffset = startOffset;
					interfaceDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					AstNodeList typeParameterList = null;
				%>
				[ "VariantTypeParameterList<@ out typeParameterList @>" ]
				<%
					if (typeParameterList != null)
						interfaceDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
				%>
				[ 
					'Colon<- ->' 
					<%
						TypeReference typeReference;
					%>
					"ClassType<@ false, out typeReference @><+ interfaceDeclaration.BaseTypes.Add(typeReference); +>
						<-
							// Error recovery:  Go to the next open curly brace
							this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
						->" 
					{ 
						'Comma
							<-
								// Error recovery:  Go to the next open curly brace
								this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
							->' 
						"ClassType<@ false, out typeReference @><+ interfaceDeclaration.BaseTypes.Add(typeReference); +>
							<-
								// Error recovery:  Go to the next open curly brace
								this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
							->" 
					}
				]
				[ "TypeParameterConstraintsClauses<@ typeParameterList @>" ]
				<%
					this.BlockAddChild(interfaceDeclaration);
					interfaceDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
					int interfaceCurlyBraceLevel = curlyBraceLevel;
				%>
				'OpenCurlyBrace'
				<%
					this.BlockStart(interfaceDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == interfaceCurlyBraceLevel + 1))
							break;
						else if (IsNonTerminal("InterfaceMemberDeclaration")) {
							errorReported = false;
					%>
							"InterfaceMemberDeclaration<@ interfaceDeclaration @><- ->"
					<%
						}
						else {
							// Error recovery:  Advance to the next token since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_InterfaceMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNext();
						}
					}
					this.ReapDocumentationComments();
				%>
				'CloseCurlyBrace<- ->'
				<%
					interfaceDeclaration.BlockEndOffset = this.Token.EndOffset;
					this.BlockEnd();
				%>
				[ 'SemiColon' ]
				<%
					interfaceDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapComments(interfaceDeclaration.Comments, false);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: InterfaceModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: InterfaceBase merged into StructDeclaration -->
		<!-- NOTE: InterfaceBody merged into StructDeclaration -->
		<NonTerminal Key="InterfaceMemberDeclaration" Parameters="TypeDeclaration parentTypeDeclaration">
			<Production><![CDATA[
				<%
					AttributeSection attributeSection;
					AstNodeList attributeSections = new AstNodeList(null);
					Modifiers modifiers = Modifiers.None;
					TypeReference typeReference;
				%>
				{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
				<%
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				[ 'New<+ modifiers = Modifiers.New; +>' ]
				(
					(
						<%
							// Build a list of generic type arguments for the parent type... will add to this collection if a generic method
							AstNodeList scopedGenericTypeArguments = new AstNodeList(null);
							if ((parentTypeDeclaration.GenericTypeArguments != null) && (parentTypeDeclaration.GenericTypeArguments.Count > 0))
								scopedGenericTypeArguments.AddRange(parentTypeDeclaration.GenericTypeArguments.ToArray());					
						%>			

						"ReturnType<@ out typeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>"

						(
							'This'
							'OpenSquareBrace'
							<%
								AstNodeList parameterList;
								AstNodeList accessorAttributeSections = new AstNodeList(null);
								InterfaceAccessor getAccessor;
								InterfaceAccessor setAccessor;
							%>
							"FormalParameterList<@ scopedGenericTypeArguments, out parameterList @>"
							'CloseSquareBrace'
							<% 
								InterfacePropertyDeclaration indexerDeclaration = new InterfacePropertyDeclaration(modifiers, null);
								indexerDeclaration.Documentation = this.ReapDocumentationComments();
								indexerDeclaration.StartOffset = startOffset;
							%>
							'OpenCurlyBrace'
							"InterfaceAccessors<@ out getAccessor, out setAccessor @>"
							'CloseCurlyBrace'
							<%
								indexerDeclaration.EndOffset = this.Token.EndOffset;
								indexerDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
								indexerDeclaration.ReturnType = typeReference;
								indexerDeclaration.Parameters.AddRange(parameterList.ToArray());
								indexerDeclaration.GetAccessor = getAccessor;
								indexerDeclaration.SetAccessor = setAccessor;
								this.BlockAddChild(indexerDeclaration);
							%>
						)
						| (
							<%
								QualifiedIdentifier identifier;
								AstNodeList typeParameterList = null;
							%>
							"Identifier<@ out identifier @>"
							(
								[ "TypeParameterList<@ out typeParameterList @>" ]
								'OpenParenthesis'
								<%
									AstNodeList parameterList = null;
								%>
								[ "FormalParameterList<@ scopedGenericTypeArguments, out parameterList @>" ]
								'CloseParenthesis'
								[ "TypeParameterConstraintsClauses<@ typeParameterList @>" ]
								<%
									InterfaceMethodDeclaration methodDeclaration = new InterfaceMethodDeclaration(modifiers, identifier);
									methodDeclaration.Documentation = this.ReapDocumentationComments();
									methodDeclaration.StartOffset = startOffset;
								%>
								'SemiColon<- ->'
								<% 
									methodDeclaration.EndOffset = this.Token.EndOffset;
									methodDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
									if (typeReference != null)
										methodDeclaration.ReturnType = typeReference;
									if (typeParameterList != null)
										methodDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
									if (parameterList != null)
										methodDeclaration.Parameters.AddRange(parameterList.ToArray());
									this.BlockAddChild(methodDeclaration);
								%>
							)
							| (
								<%
									InterfaceAccessor getAccessor;
									InterfaceAccessor setAccessor;
								%>
								'OpenCurlyBrace'
								"InterfaceAccessors<@ out getAccessor, out setAccessor @>"
								<%
									InterfacePropertyDeclaration propertyDeclaration = new InterfacePropertyDeclaration(modifiers, identifier);
									propertyDeclaration.Documentation = this.ReapDocumentationComments();
									propertyDeclaration.StartOffset = startOffset;
								%>
								'CloseCurlyBrace'
								<% 
									propertyDeclaration.EndOffset = this.Token.EndOffset;
									propertyDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
									propertyDeclaration.ReturnType = typeReference;
									propertyDeclaration.GetAccessor = getAccessor;
									propertyDeclaration.SetAccessor = setAccessor;
									this.BlockAddChild(propertyDeclaration);
								%>
							)
						)
					)
					| (
						'Event'
						"Type<@ out typeReference @>"
						<%
							QualifiedIdentifier identifier;
						%>
						"Identifier<@ out identifier @>"
						<% 
							InterfaceEventDeclaration eventDeclaration = new InterfaceEventDeclaration(modifiers, identifier);
							eventDeclaration.Documentation = this.ReapDocumentationComments();
							eventDeclaration.StartOffset = startOffset;
							eventDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
							eventDeclaration.EventType = typeReference;
							this.BlockAddChild(eventDeclaration);
						%>
						'SemiColon'
						<% 
							eventDeclaration.EndOffset = this.Token.EndOffset;
						%>
					)
				)
			]]></Production>
		</NonTerminal>
		<!-- NOTE: InterfaceMethodDeclaration merged into InterfaceMemberDeclaration -->
		<!-- NOTE: InterfacePropertyDeclaration merged into InterfaceMemberDeclaration -->
		<NonTerminal Key="InterfaceAccessors" Parameters="out InterfaceAccessor getAccessor, out InterfaceAccessor setAccessor">
			<Production><![CDATA[
				<%
					getAccessor = null;
					setAccessor = null;
					AttributeSection attributeSection;
					AstNodeList attributeSections = new AstNodeList(null);
				%>
				{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
				<%
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				[
					(
						'Get'
						'SemiColon'
						<%
							getAccessor = new InterfaceAccessor(InterfaceAccessorType.Get);
							getAccessor.StartOffset = startOffset;
							getAccessor.EndOffset = this.Token.EndOffset;
							getAccessor.AttributeSections.AddRange(attributeSections.ToArray());
							attributeSections = new AstNodeList(null);									
							startOffset = this.LookAheadToken.StartOffset;
							
							attributeSections = new AstNodeList(null);
						%>
						{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
						[
							'Set'
							'SemiColon'
							<%
								setAccessor = new InterfaceAccessor(InterfaceAccessorType.Set);
								setAccessor.StartOffset = startOffset;
								setAccessor.EndOffset = this.Token.EndOffset;
								setAccessor.AttributeSections.AddRange(attributeSections.ToArray());
								attributeSections = new AstNodeList(null);									
							%>
						]
					)
					| (
						'Set'
						'SemiColon'
						<%
							setAccessor = new InterfaceAccessor(InterfaceAccessorType.Set);
							setAccessor.StartOffset = startOffset;
							setAccessor.EndOffset = this.Token.EndOffset;
							setAccessor.AttributeSections.AddRange(attributeSections.ToArray());
							attributeSections = new AstNodeList(null);									
							startOffset = this.LookAheadToken.StartOffset;
							
							attributeSections = new AstNodeList(null);
						%>
						{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
						[
							'Get'
							'SemiColon'
							<%
								getAccessor = new InterfaceAccessor(InterfaceAccessorType.Get);
								getAccessor.StartOffset = startOffset;
								getAccessor.EndOffset = this.Token.EndOffset;
								getAccessor.AttributeSections.AddRange(attributeSections.ToArray());
								attributeSections = new AstNodeList(null);									
							%>
						]
					)
				]
			]]></Production>
		</NonTerminal>
		<!-- NOTE: InterfaceEventDeclaration merged into InterfaceMemberDeclaration -->
		<!-- NOTE: InterfaceIndexerDeclaration merged into InterfaceMemberDeclaration -->

		<!-- C.2.11 Enums -->
		<NonTerminal Key="EnumDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and EnumModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				'Enum'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to internal access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Assembly;
				
					EnumerationDeclaration enumerationDeclaration = new EnumerationDeclaration(modifiers, identifier);
					enumerationDeclaration.Documentation = this.ReapDocumentationComments();
					enumerationDeclaration.StartOffset = startOffset;
					enumerationDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
				%>
				[ 
					'Colon<- ->' 
					<%
						TypeReference typeReference;
					%>
					"IntegralType<@ out typeReference @><+ enumerationDeclaration.BaseTypes.Add(typeReference); +>
						<-
							// Error recovery:  Go to the next open curly brace
							this.AdvanceToNext(CSharpTokenID.OpenCurlyBrace);
						->" 
				]
				<%
					this.BlockAddChild(enumerationDeclaration);
					enumerationDeclaration.BlockStartOffset = this.LookAheadToken.StartOffset;
					int enumerationCurlyBraceLevel = curlyBraceLevel;
				%>
				'OpenCurlyBrace'
				<%
					this.BlockStart(enumerationDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseCurlyBrace)) && (curlyBraceLevel == enumerationCurlyBraceLevel + 1))
							break;
						else if (IsNonTerminal("EnumMemberDeclaration")) {
							errorReported = false;
					%>
							"EnumMemberDeclaration<- ->"
							[ 'Comma' ]
					<%
						}
						else {
							// Error recovery:  Advance to the next token since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_EnumerationMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNext();
						}
					}
					this.ReapDocumentationComments();
				%>
				'CloseCurlyBrace<- ->'
				<%
					enumerationDeclaration.BlockEndOffset = this.Token.EndOffset;
					this.BlockEnd();
				%>
				[ 'SemiColon' ]
				<%
					enumerationDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapComments(enumerationDeclaration.Comments, false);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: EnumBase merged into EnumDeclaration -->
		<!-- NOTE: EnumBody merged into EnumDeclaration -->
		<!-- NOTE: EnumModifier moved to Modifier to reduce ambiguity with type declarations -->
		<NonTerminal Key="EnumMemberDeclaration">
			<Production><![CDATA[
				<%
					AttributeSection attributeSection;
					AstNodeList attributeSections = new AstNodeList(null);
				%>
				{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					EnumerationMemberDeclaration memberDeclaration = new EnumerationMemberDeclaration(identifier);
					memberDeclaration.Documentation = this.ReapDocumentationComments();
					memberDeclaration.StartOffset = startOffset;
					memberDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					this.BlockAddChild(memberDeclaration);
					Expression initializer;
				%>
				[ 'Assignment' "Expression<@ out initializer @><+ memberDeclaration.Initializer = initializer; +>" ]
				<%
					memberDeclaration.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		
		<!-- C.2.12 Delegates -->
		<NonTerminal Key="DelegateDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and DelegateModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				<%
					TypeReference typeReference;
					AstNodeList parameterList = null;
				%>
				'Delegate'
				"ReturnType<@ out typeReference @>"
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to internal access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Assembly;
				
					DelegateDeclaration delegateDeclaration = new DelegateDeclaration(modifiers, identifier);
					delegateDeclaration.Documentation = this.ReapDocumentationComments();
					delegateDeclaration.StartOffset = startOffset;
					delegateDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					delegateDeclaration.ReturnType = typeReference;
					AstNodeList typeParameterList = null;
				%>
				[ "VariantTypeParameterList<@ out typeParameterList @>" ]
				<%
					if (typeParameterList != null)
						delegateDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
						
					// Ensure that generic type parameters are marked properly
					this.MarkGenericParameters(typeParameterList, typeReference, true);						
				%>
				'OpenParenthesis'
				[ "FormalParameterList<@ delegateDeclaration.GenericTypeArguments, out parameterList @>" ]
				'CloseParenthesis'
				[ "TypeParameterConstraintsClauses<@ typeParameterList @>" ]
				<%
					if (parameterList != null)
						delegateDeclaration.Parameters.AddRange(parameterList.ToArray());
					this.BlockAddChild(delegateDeclaration);					
					delegateDeclaration.GenerateInvokeMembers();
				%>
				'SemiColon'
				<%
					delegateDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapComments(delegateDeclaration.Comments, false);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: DelegateModifier moved to Modifier to reduce ambiguity with type declarations -->
		
		<!-- C.2.13 Attributes -->
		<!-- NOTE: GlobalAttributes merged into callers of GlobalAttributeSection -->
		<NonTerminal Key="GlobalAttributeSection">
			<Production><![CDATA[
				'OpenSquareBrace'
				<%
					AttributeSection attributeSection = new AttributeSection();
					attributeSection.StartOffset = this.Token.StartOffset;
					
					string target = null;
					if (!this.IsKeywordOrIdentifierAndColon()) {
						while (!this.IsAtEnd) {
							if ((this.TokenIs(this.LookAheadToken, CSharpTokenID.CloseSquareBrace)) || (this.IsIdentifier(this.LookAheadToken)))
								break;
							this.AdvanceToNext();
						}
						return false;
					}
					this.AdvanceToNext();
					target = this.TokenText;
				%>
				'Colon'
				"AttributeList<@ attributeSection @>"
				'CloseSquareBrace'
				<%
					foreach (DotNet.Ast.Attribute attribute in attributeSection.Attributes)
						attribute.Target = target;
					attributeSection.EndOffset = this.Token.EndOffset;
					compilationUnit.GlobalAttributeSections.Add(attributeSection);
				%>
				[ 'Comma' ]
			]]></Production>
		</NonTerminal>
		<!-- NOTE: GlobalAttributeTargetSpecifier merged into GlobalAttributeSection -->
		<!-- NOTE: GlobalAttributeTarget merged into GlobalAttributeSection -->
		<!-- NOTE: Attributes merged into callers of AttributeSection -->
		<NonTerminal Key="AttributeSection" Parameters="out AttributeSection attributeSection">
			<Production><![CDATA[
				<%
					attributeSection = new AttributeSection();
					attributeSection.StartOffset = this.LookAheadToken.StartOffset;
					string target = null;
				%>
				'OpenSquareBrace'
				[ <? this.IsKeywordOrIdentifierAndColon() ?>
					<%
						this.AdvanceToNext();
						target = this.TokenText;
					%>
					'Colon' 
				]
				"AttributeList<@ attributeSection @>"
				'CloseSquareBrace'
				<%
					foreach (DotNet.Ast.Attribute attribute in attributeSection.Attributes)
						attribute.Target = target;
					attributeSection.EndOffset = this.Token.EndOffset;
				%>
				[ 'Comma' ]
			]]></Production>
		</NonTerminal>
		<!-- NOTE: AttributeTargetSpecifier merged into AttributeSection -->
		<!-- NOTE: AttributeTarget merged into AttributeSection -->
		<NonTerminal Key="AttributeList" Parameters="AttributeSection attributeSection">
			<Production><![CDATA[
				"Attribute<@ attributeSection @>"
				{ <? this.IsCommaAndIdentifier() ?> 'Comma' "Attribute<@ attributeSection @>" }
				[ 'Comma' ]
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Attribute" Parameters="AttributeSection attributeSection">
			<Production><![CDATA[
				<% 
					int startOffset = this.LookAheadToken.StartOffset;
					TypeReference typeReference; 
				%>
				"TypeName<@ false, out typeReference @>"				
				<%
					ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute attribute = new ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute(typeReference);
					attribute.StartOffset = startOffset;
				%>
				[ "AttributeArguments<@ attribute @>" ]
				<%
					attribute.EndOffset = this.Token.EndOffset;
					attributeSection.Attributes.Add(attribute);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: AttributeName merged into Attribute -->
		<NonTerminal Key="AttributeArguments" Parameters="ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute attribute">
			<Production><![CDATA[
				'OpenParenthesis'
				[
					"AttributeArgument<@ attribute @>"
					{ 'Comma' "AttributeArgument<@ attribute @>" }
				]
				'CloseParenthesis'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: AttributeArgument added -->
		<NonTerminal Key="AttributeArgument" Parameters="ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute attribute">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					string name = null;
					Expression expression;
				%>
				[
					<%
						if (this.AreNextTwoIdentifierAnd(CSharpTokenID.Assignment)) { 
							name = this.LookAheadTokenText;
					%>
							"SimpleIdentifier"
							'Assignment'
					<%
						}
						else if (this.AreNextTwoIdentifierAnd(CSharpTokenID.Colon)) {
							// C# 4.0 named arguments
							name = this.LookAheadTokenText;
					%>
							"SimpleIdentifier"
							'Colon'
					<%
						}
					%>
				]
				"Expression<@ out expression @>"
				<%
					AttributeArgument argument = new AttributeArgument(name, expression, new TextRange(startOffset, this.Token.EndOffset));					
					attribute.Arguments.Add(argument);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: PositionalArgumentList merged into AttributeArgument(s) -->
		<!-- NOTE: PositionalArgument merged into AttributeArgument(s) -->
		<!-- NOTE: NamedArgumentList merged into AttributeArgument(s) -->
		<!-- NOTE: NamedArgument merged into AttributeArgument(s) -->
		<!-- NOTE: AttributeArgumentExpression merged into AttributeArgument(s) -->
	
		<!-- C.3 Grammar extensions for unsafe code -->
		<!-- NOTE: PointerType merged into NonArrayType -->
		<!-- NOTE: PointerIndirectionExpression merged into UnaryExpression -->
		<!-- NOTE: PointerMemberAccess merged into PrimaryExpression -->
		<!-- NOTE: AddressOfExpression merged into UnaryExpression -->
		<!-- NOTE: SizeOfExpression merged into PrimaryExpression -->
		<!-- NOTE: FixedStatement merged into EmbeddedStatement -->
		<NonTerminal Key="StackAllocInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null; 
					int startOffset = this.LookAheadToken.StartOffset;
					TypeReference typeReference;
					Expression childExpression;
				%>
				'StackAlloc'
				"NonArrayType<@ false, false, out typeReference @>"
				'OpenSquareBrace'
				"Expression<@ out childExpression @>"
				'CloseSquareBrace'
				<%
					expression = new StackAllocInitializer(typeReference, childExpression, new TextRange(startOffset, this.Token.EndOffset));
				%>
			]]></Production>
		</NonTerminal>

		
		<!-- 
		
		Grammar extensions for C# 2.0 code 
		
		-->
		
		
		<!-- NOTE: ExternAliasDirectives merged into callers of ExternAliasDirective -->
		<NonTerminal Key="ExternAliasDirective">
			<Production><![CDATA[
				'Extern<- ->' 
				<%
					int startOffset = this.Token.StartOffset;
					if (compilationUnit.ExternAliasDirectives == null)
						compilationUnit.ExternAliasDirectives = new ExternAliasDirectiveSection();
					if (compilationUnit.ExternAliasDirectives.Directives.Count == 0)
						compilationUnit.ExternAliasDirectives.StartOffset = startOffset;
				%>
				"SimpleIdentifier"
				<%
					if (this.TokenText != "alias") {
						this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_AliasExpected"));
						return false;
					}
				%>
				"SimpleIdentifier"
				<% 
					ExternAliasDirective externAliasDirective = new ExternAliasDirective(this.TokenText, new TextRange(startOffset, this.Token.EndOffset));
					
					// Reap comments
					this.ReapComments(externAliasDirective.Comments, false);
					
					compilationUnit.ExternAliasDirectives.Directives.Add(externAliasDirective);
					compilationUnit.ExternAliasDirectives.EndOffset = this.Token.EndOffset;
				%>
				'SemiColon<- ->'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="TypeParameterList" Parameters="out AstNodeList typeParameterList">
			<Production><![CDATA[
				<%
					TypeReference typeParameter;
					typeParameterList = new AstNodeList(null);
				%>
				'LessThan'
				"TypeParameter<@ out typeParameter @><+ typeParameterList.Add(typeParameter); +>"
				{
					'Comma'
					"TypeParameter<@ out typeParameter @><+ typeParameterList.Add(typeParameter); +>"
				}
				'GreaterThan<- ->'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: TypeParameters merged into TypeParameterList -->
		<NonTerminal Key="TypeParameter" Parameters="out TypeReference typeParameter">
			<Production><![CDATA[
				<%
					typeParameter = null;
					AttributeSection attributeSection;
					AstNodeList attributeSections = new AstNodeList(null);
				%>
				{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
				"SimpleIdentifier"
				<%
					typeParameter = new TypeReference(this.TokenText, this.Token.TextRange);
					typeParameter.IsGenericParameter = true;
					if (attributeSections != null)
						typeParameter.AttributeSections.AddRange(attributeSections.ToArray());
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="VariantTypeParameterList" Parameters="out AstNodeList typeParameterList">
			<Production><![CDATA[
				<%
					TypeReference typeParameter;
					typeParameterList = new AstNodeList(null);
				%>
				'LessThan'
				"VariantTypeParameter<@ out typeParameter @><+ typeParameterList.Add(typeParameter); +>"
				{
					'Comma'
					"VariantTypeParameter<@ out typeParameter @><+ typeParameterList.Add(typeParameter); +>"
				}
				'GreaterThan<- ->'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: VariantTypeParameters merged into VariantTypeParameterList -->
		<NonTerminal Key="VariantTypeParameter" Parameters="out TypeReference typeParameter">
			<Production><![CDATA[
				<%
					typeParameter = null;
					AttributeSection attributeSection;
					AstNodeList attributeSections = new AstNodeList(null);
				%>
				{ "AttributeSection<@ out attributeSection @><+ attributeSections.Add(attributeSection); +>" }
				[ 'In' | 'Out' ]
				"SimpleIdentifier"
				<%
					typeParameter = new TypeReference(this.TokenText, this.Token.TextRange);
					typeParameter.IsGenericParameter = true;
					if (attributeSections != null)
						typeParameter.AttributeSections.AddRange(attributeSections.ToArray());
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="TypeArgumentList" Parameters="out AstNodeList typeArgumentList">
			<Production><![CDATA[
				<%
					TypeReference typeReference;
					typeArgumentList = new AstNodeList(null);
				%>
				'LessThan'
				"Type<@ out typeReference @><+ typeArgumentList.Add(typeReference); +>"
				{
					'Comma'
					"Type<@ out typeReference @><+ typeArgumentList.Add(typeReference); +>"
				}
				'GreaterThan<- ->'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: TypeArguments merged into TypeArgumentList -->
		<!-- NOTE: TypeArgument simply calls Type -->
		<NonTerminal Key="TypeParameterConstraintsClauses" Parameters="AstNodeList typeParameterList">
			<Production><![CDATA[
				{
					"SimpleIdentifier"
					<%				
						if (this.TokenText != "where") {
							this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_WhereExpected"));
							return false;
						}
						TypeReference typeParameterReference;
					%>
					"TypeParameter<@ out typeParameterReference @>"
					<%
						TypeReference matchingTypeParameter = null;
						if (typeParameterList != null) {
							foreach (TypeReference typeParameter in typeParameterList) {
								if (typeParameter.Name == typeParameterReference.Name) {
									matchingTypeParameter = typeParameter;
									break;
								}
							}
						}
						// Statements like this no longer work due to changes... need better identifier storage: static T NullableHelper_HACK<T>() where T : struct
						// if (matchingTypeParameter == null)
						//	this.ReportSyntaxError("No matching type parameter was found for the constraint clause.");
					%>
					'Colon'
					"TypeParameterConstraint<@ matchingTypeParameter @>"
					{ 
						'Comma'
						"TypeParameterConstraint<@ matchingTypeParameter @>" 
					}
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="TypeParameterConstraint" Parameters="TypeReference typeParameter">
			<Production><![CDATA[
				(
					<%
						TypeReference typeConstraint;
					%>
					"Type<@ out typeConstraint @><+ 
					if (typeParameter != null)
						typeParameter.GenericTypeParameterConstraints.Add(typeConstraint);
					+>"
				)
				| 'Class<+
					if (typeParameter != null)
						typeParameter.HasGenericParameterReferenceTypeConstraint = true;
					+>'
				| 'Struct<+
					if (typeParameter != null) {
						typeParameter.HasGenericParameterNotNullableValueTypeConstraint = true;
						typeParameter.GenericTypeParameterConstraints.Add(new TypeReference("System.ValueType", this.Token.TextRange));
					}
					+>'
				| (
					'New<+
						if (typeParameter != null)
							typeParameter.HasGenericParameterDefaultConstructorConstraint = true;
						+>'
					'OpenParenthesis'
					'CloseParenthesis'
				)
			]]></Production>
		</NonTerminal>
		<!-- NOTE: DefaultValueExpression merged into PrimaryExpression -->
		<NonTerminal Key="AnonymousMethodExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					Statement statement;
					int startOffset = this.LookAheadToken.StartOffset;
					AstNodeList anonymousMethodParameterList = new AstNodeList(null);
					ParameterDeclaration parameterDeclaration;
				%>
				'Delegate'
				[
					'OpenParenthesis'
					[
						"FixedParameter<@ null, null, out parameterDeclaration @><+ anonymousMethodParameterList.Add(parameterDeclaration); +>"
						{
							'Comma'
							"FixedParameter<@ null, null, out parameterDeclaration @><+ anonymousMethodParameterList.Add(parameterDeclaration); +>"
						}
					]
					'CloseParenthesis'
				]
				"Block<@ out statement @>"
				<%
					expression = new AnonymousMethodExpression((BlockStatement)statement, new TextRange(startOffset, this.Token.EndOffset));
					((AnonymousMethodExpression)expression).GenericTypeParameters.AddRange(anonymousMethodParameterList.ToArray());
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: AnonymousMethodSignature merged into AnonymousMethodExpression -->
		<!-- NOTE: AnonymousMethodParameterList merged into AnonymousMethodExpression -->
		<!-- NOTE: AnonymousMethodParameter merged into AnonymousMethodExpression (by a call to FixedParameter instead since they are the same) -->
		<NonTerminal Key="FixedSizeBufferDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<Production><![CDATA[
				<%
					// NOTE: Attributes and FixedSizeBufferModifier (alias Modifier) moved to callers of FixedSizeBufferDeclaration to reduce ambiguity 
				%>
				'Fixed'
				<%
					TypeReference typeReference;
				%>
				"Type<@ out typeReference @>"
				<%
					FixedSizeBufferDeclaration fixedSizeBufferDeclaration = new FixedSizeBufferDeclaration(modifiers);
					fixedSizeBufferDeclaration.Documentation = this.ReapDocumentationComments();
					fixedSizeBufferDeclaration.StartOffset = startOffset;
					fixedSizeBufferDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
				%>				
				"FixedSizeBufferDeclarator<@ fixedSizeBufferDeclaration, typeReference @>"
				{ 
					'Comma'
					"FixedSizeBufferDeclarator<@ fixedSizeBufferDeclaration, typeReference @>" 
				}
				'SemiColon<- ->'						
				<%
					fixedSizeBufferDeclaration.EndOffset = this.Token.EndOffset;
					this.BlockAddChild(fixedSizeBufferDeclaration);
					this.ReapDocumentationComments();
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="FixedSizeBufferDeclarator" Parameters="FixedSizeBufferDeclaration declaration, TypeReference typeReference">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					QualifiedIdentifier identifier;
					Expression sizeExpression;
				%>
				"Identifier<@ out identifier @>"
				'OpenSquareBrace'
				"Expression<@ out sizeExpression @>"	
				'CloseSquareBrace'
				<%
					FixedSizeBufferDeclarator declarator = new FixedSizeBufferDeclarator(typeReference, identifier, new TextRange(startOffset, this.Token.EndOffset));
					declarator.SizeExpression = sizeExpression;
					declaration.Variables.Add(declarator); 
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: FixedSizeBufferModifier moved to Modifier to reduce ambiguity with type declarations -->
		<!-- NOTE: BufferElementType merged into FixedSizeBufferDeclaration -->
		<!-- NOTE: FixedSizeBufferDeclarators merged into FixedSizeBufferDeclaration -->

		
		<!--
		
		Grammar extensions for C# 3.0 code 
		
		-->
		
		
		<!-- Lambda Expressions -->
		<NonTerminal Key="LambdaExpression" Parameters="out Expression expression">
			<AdditionalConditions>
				<ClearFirstSet />
				<ExpressionCondition>this.IsLambdaExpression()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					expression = null;
					AstNodeList parameterList = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				(
					(
						<%
							parameterList = new AstNodeList(null);				
							ParameterDeclaration parameter;
						%>
						"ImplicitlyTypedLambdaParameter<@ out parameter @><+ parameterList.Add(parameter); +>"
					)
					| (
						'OpenParenthesis'
						[ 
							"ImplicitlyTypedLambdaParameterList<@ out parameterList @>"
							| "ExplicitlyTypedLambdaParameterList<@ out parameterList @>"
						]
						'CloseParenthesis'
					)
				)
				'Lambda'
				<%
					Statement statement = null;
				%>
				(
					"StatementExpression<@ out statement @><- ->"
					| "Block<@ out statement @><- ->"
				)
				<%
					expression = new LambdaExpression(statement, new TextRange(startOffset, this.Token.EndOffset));
					if (parameterList != null)
						((LambdaExpression)expression).Parameters.AddRange(parameterList.ToArray());					
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: LambdaParameterList merged into LambdaExpression -->
		<NonTerminal Key="ExplicitlyTypedLambdaParameterList" Parameters="out AstNodeList parameterList">
			<Production><![CDATA[
				<%
					parameterList = new AstNodeList(null);				
					ParameterDeclaration parameter;
				%>
				"ExplicitlyTypedLambdaParameter<@ out parameter @><+ parameterList.Add(parameter); +>"
				{
					'Comma'
					"ExplicitlyTypedLambdaParameter<@ out parameter @><+ parameterList.Add(parameter); +>"
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ExplicitlyTypedLambdaParameter" Parameters="out ParameterDeclaration parameter">
			<Production><![CDATA[
				<%
					parameter = null;
					ParameterModifiers modifiers = ParameterModifiers.None;
					TypeReference typeReference;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				[ 
					'Ref<+ modifiers = ParameterModifiers.Ref; +>' 
					| 'Out<+ modifiers = ParameterModifiers.Out; +>' 
				]
				"Type<@ out typeReference @>" 
				"SimpleIdentifier"
				<%
					parameter = new ParameterDeclaration(modifiers, this.TokenText);
					parameter.StartOffset = startOffset;
					parameter.EndOffset = this.Token.EndOffset;
					parameter.ParameterType = typeReference;
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ImplicitlyTypedLambdaParameterList" Parameters="out AstNodeList parameterList">
			<AdditionalConditions>
				<ClearFirstSet />
				<ExpressionCondition>this.IsImplicitlyTypedLambdaParameterList()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					parameterList = new AstNodeList(null);				
					ParameterDeclaration parameter;
				%>
				"ImplicitlyTypedLambdaParameter<@ out parameter @><+ parameterList.Add(parameter); +>"
				{
					'Comma'
					"ImplicitlyTypedLambdaParameter<@ out parameter @><+ parameterList.Add(parameter); +>"
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ImplicitlyTypedLambdaParameter" Parameters="out ParameterDeclaration parameter">
			<Production><![CDATA[
				"SimpleIdentifier<- ->"
				<%
					parameter = new ParameterDeclaration(ParameterModifiers.None, this.TokenText);
					parameter.StartOffset = this.Token.StartOffset;
					parameter.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: LambdaBodyExpression merged into LambdaExpression -->

		
		<!-- Object and Collection Initializers -->
		<NonTerminal Key="ObjectOrCollectionInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					AstNodeList initializerList = new AstNodeList(null);
					Expression initializer;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				'OpenCurlyBrace'				
				<% 
					if (this.IsObjectInitializer()) {
				%>
						[ 
							"MemberInitializer<@ out initializer @><+ initializerList.Add(initializer); +>"
							{<? (this.TokenIs(this.LookAheadToken, CSharpTokenID.Comma)) && (!this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.CloseCurlyBrace)) ?>
								'Comma<- ->'
								"MemberInitializer<@ out initializer @><+ initializerList.Add(initializer); +>"
							}
							[ 'Comma<- ->' ]
						]
				<%
					}
					else {
				%>
						"ElementInitializer<@ out initializer @><+ initializerList.Add(initializer); +>"
						{<? (this.TokenIs(this.LookAheadToken, CSharpTokenID.Comma)) && (!this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.CloseCurlyBrace)) ?>
							'Comma<- ->'
							"ElementInitializer<@ out initializer @><+ initializerList.Add(initializer); +>"
						}
						[ 'Comma<- ->' ]
				<%
					}
				%>
				'CloseCurlyBrace<- ->'
				<%
					expression = new ObjectCollectionInitializerExpression(new TextRange(startOffset, this.Token.EndOffset));
					((ObjectCollectionInitializerExpression)expression).Initializers.AddRange(initializerList.ToArray());					
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ObjectInitializer merged into ObjectOrCollectionInitializer -->
		<!-- NOTE: MemberInitializerList merged into ObjectOrCollectionInitializer -->
		<NonTerminal Key="MemberInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					SimpleName memberName;				
					Expression valueExpression;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"SimpleIdentifier<+ memberName = new SimpleName(this.TokenText, this.Token.TextRange); +>"
				'Assignment'
				(
					"Expression<@ out valueExpression @>"
					| "ObjectOrCollectionInitializer<@ out valueExpression @>"
				)
				<%
					expression = new AssignmentExpression(OperatorType.None, memberName, valueExpression, new TextRange(startOffset, this.Token.EndOffset));
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: CollectionInitializer merged into ObjectOrCollectionInitializer -->
		<!-- NOTE: InitializerValue merged into MemberInitializer -->
		<!-- NOTE: ElementInitializerList merged into ObjectOrCollectionInitializer -->
		<NonTerminal Key="ElementInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
				%>
				"NonAssignmentExpression<@ out expression @>"
				| (
					<%
						expression = new ObjectCollectionInitializerExpression();
						expression.StartOffset = this.LookAheadToken.StartOffset;
						Expression initializerExpression;						
					%>
					
					'OpenCurlyBrace'
					"Expression<@ out initializerExpression @><+ ((ObjectCollectionInitializerExpression)expression).Initializers.Add(initializerExpression); +>"
					{ ( 'Comma' "Expression<@ out initializerExpression @><+ ((ObjectCollectionInitializerExpression)expression).Initializers.Add(initializerExpression); +>" ) }
					'CloseCurlyBrace<- ->'
					
					<%
						expression.EndOffset = this.Token.EndOffset;
					%>
				)
			]]></Production>
		</NonTerminal>
		
		
		<!-- Anonymous Types -->
		<NonTerminal Key="AnonymousObjectCreationExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					ObjectCollectionInitializerExpression initializerExpression;
					int startOffset = this.LookAheadToken.StartOffset;
					TextRange newTextRange = this.LookAheadToken.TextRange;
				%>
				'New'
				"AnonymousObjectInitializer<@ out initializerExpression @>"
				<%
					expression = new ObjectCreationExpression(new TypeReference(TypeReference.AnonymousTypeName, newTextRange), new TextRange(startOffset, this.Token.EndOffset));
					((ObjectCreationExpression)expression).Initializer = initializerExpression;
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="AnonymousObjectInitializer" Parameters="out ObjectCollectionInitializerExpression expression">
			<Production><![CDATA[
				<%
					expression = null;
					AstNodeList initializerList = new AstNodeList(null);
					Expression initializer;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				'OpenCurlyBrace'
				[
					"MemberDeclarator<@ out initializer @><+ initializerList.Add(initializer); +>"
					{<? (this.TokenIs(this.LookAheadToken, CSharpTokenID.Comma)) && (!this.TokenIs(this.GetLookAheadToken(2), CSharpTokenID.CloseCurlyBrace)) ?>
						'Comma<- ->'
						"MemberDeclarator<@ out initializer @><+ initializerList.Add(initializer); +>"
					}
					[ 'Comma<- ->' ]
				]
				'CloseCurlyBrace<- ->'
				<%
					expression = new ObjectCollectionInitializerExpression(new TextRange(startOffset, this.Token.EndOffset));
					((ObjectCollectionInitializerExpression)expression).Initializers.AddRange(initializerList.ToArray());					
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: MemberDeclaratorList merged into AnonymousObjectInitializer -->
		<NonTerminal Key="MemberDeclarator" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					Expression primaryExpression;
				%>
				"Expression<@ out primaryExpression @>"
				<%
					if (primaryExpression is SimpleName) {
						// identifer => identifer = identifier
						expression = new AssignmentExpression(OperatorType.None, (SimpleName)primaryExpression, primaryExpression, primaryExpression.TextRange);
					}
					else if (primaryExpression is MemberAccess) {
						// expr . identifier => identifier = expr . identifier
						expression = new AssignmentExpression(OperatorType.None, 
							new SimpleName(((MemberAccess)primaryExpression).MemberName.Text, ((MemberAccess)primaryExpression).MemberName.TextRange), 
							primaryExpression, primaryExpression.TextRange);
					}
					else if (primaryExpression is AssignmentExpression) {
						// identifier = expression
						if (!(((AssignmentExpression)primaryExpression).LeftExpression is SimpleName)) {
							this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_AnonymousTypeMemberDeclaratorAssignment"));
							return false;
						}
						expression = primaryExpression;
					}
					else {
						this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_AnonymousTypeMemberDeclaratorSyntax"));
						return false;
					}
				%>
			]]></Production>
		</NonTerminal>
		
		
		<!-- Implicitly Typed Arrays -->
		<NonTerminal Key="ImplicitlyTypedArrayCreationExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					Expression initializer;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				'New'
				'OpenSquareBrace'
				'CloseSquareBrace'
				"ArrayInitializer<@ out initializer @>"
				<%
					// Determine the type
					TypeReference typeReference = null;
					TypeReference currentTypeReference = null;
					foreach (Expression varInitializer in ((ObjectCollectionInitializerExpression)initializer).Initializers) {
						currentTypeReference = this.GetImplicitType(varInitializer, true);
						if (typeReference == null)
							typeReference = currentTypeReference;
						else if (currentTypeReference != null) {
							if ((typeReference.Name == "System.Int32") && (currentTypeReference.Name == "System.Double")) {
								// Implicitly cast
								typeReference = currentTypeReference;								
							}
						}
					}
					if (typeReference == null) {
						this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ImplicitlyTypedArrayNullInitializer"));
						return false;
					}
				
					expression = new ObjectCreationExpression(typeReference);
					((ObjectCreationExpression)expression).IsArray = true;
					((ObjectCreationExpression)expression).IsImplicitlyTyped = true;
					expression.StartOffset = startOffset;
					expression.EndOffset = this.Token.EndOffset;
					((ObjectCreationExpression)expression).Initializer = (ObjectCollectionInitializerExpression)initializer;
				%>
			]]></Production>
		</NonTerminal>
		
		
		<!-- Query Expressions -->
		<NonTerminal Key="QueryExpression" Parameters="out Expression expression">
			<AdditionalConditions>
				<ClearFirstSet />
				<ExpressionCondition>this.IsQueryExpression()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					expression = new QueryExpression();
					expression.StartOffset = this.LookAheadToken.StartOffset;
					
					AstNode queryOperator;
				%>
				"FromClause<@ out queryOperator @><+ ((QueryExpression)expression).QueryOperators.Add(queryOperator); +>"
				"QueryBody<@ ((QueryExpression)expression).QueryOperators @>"
				<%
					expression.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="CollectionRangeVariableDeclaration" Parameters="out CollectionRangeVariableDeclaration variableDeclaration">
			<Production><![CDATA[
				<%
					variableDeclaration = new CollectionRangeVariableDeclaration();
					variableDeclaration.StartOffset = this.LookAheadToken.StartOffset;

					TypeReference typeReference = new TypeReference(TypeReference.AnonymousTypeName, new TextRange(this.LookAheadToken.StartOffset));
					QualifiedIdentifier variableName;
					Expression source;
				%>
				[<? (!this.AreNextTwoIdentifierAnd(CSharpTokenID.In)) && (IsNonTerminal("Type")) ?> "Type<@ out typeReference @>" ]
				"Identifier<@ out variableName @><+ variableDeclaration.VariableDeclarator = new VariableDeclarator(typeReference, variableName, false, true); +>"
				'In'
				"Expression<@ out source @><+ variableDeclaration.Source = source; +>"
				<%
					variableDeclaration.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="FromClause" Parameters="out AstNode fromQueryOperator">
			<Production><![CDATA[
				<%
					fromQueryOperator = new FromQueryOperator();
					fromQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					CollectionRangeVariableDeclaration variableDeclaration = null;
				%>
				'From'
				"CollectionRangeVariableDeclaration<@ out variableDeclaration @><+ ((FromQueryOperator)fromQueryOperator).CollectionRangeVariableDeclarations.Add(variableDeclaration); +>"
				<%
					fromQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="QueryBody" Parameters="IAstNodeList queryOperators">
			<Production><![CDATA[
				<%
					AstNode queryOperator;
					bool hasQueryContinuation = false;
				%>
				<!-- QueryBodyClauses -->
				{ 
					"FromClause<@ out queryOperator @><+ queryOperators.Add(queryOperator); +>"
					| "LetClause<@ out queryOperator @><+ queryOperators.Add(queryOperator); +>"
					| "WhereClause<@ out queryOperator @><+ queryOperators.Add(queryOperator); +>"
					| "JoinClause<@ out queryOperator @><+ queryOperators.Add(queryOperator); +>"
					| "OrderByClause<@ out queryOperator @><+ queryOperators.Add(queryOperator); +>"
				}
				(
					"SelectClause<@ out queryOperator @><+ 
						queryOperators.Add(queryOperator); 
						if (((SelectQueryOperator)queryOperator).VariableDeclarators.Count > 0) {
							VariableDeclarator variableDeclarator = (VariableDeclarator)((SelectQueryOperator)queryOperator).VariableDeclarators[0];
							hasQueryContinuation = (variableDeclarator.Name != null);
						}
						+>"
					| "GroupClause<@ out queryOperator @><+ 
						queryOperators.Add(queryOperator); 
						hasQueryContinuation = (((GroupQueryOperator)queryOperator).TargetExpressions.Count > 0);
						+>"
				)
				<%
					if (hasQueryContinuation) {
				%>
						"QueryBody<@ queryOperators @>"
				<%
					}
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: QueryBodyClauses merged into QueryBody -->
		<!-- NOTE: QueryBodyClause merged into QueryBody -->
		<NonTerminal Key="LetClause" Parameters="out AstNode letQueryOperator">
			<Production><![CDATA[
				<%
					letQueryOperator = new LetQueryOperator();
					letQueryOperator.StartOffset = this.LookAheadToken.StartOffset;

					QualifiedIdentifier variableName;
					VariableDeclarator variableDeclarator;
					Expression initializer;
				%>
				'Let'
				<%
					TypeReference typeReference = new TypeReference(TypeReference.AnonymousTypeName, new TextRange(this.LookAheadToken.StartOffset));
				%>
				"Identifier<@ out variableName @><+ variableDeclarator = new VariableDeclarator(typeReference, variableName, false, true); +>"
				'Assignment'
				"Expression<@ out initializer @><+ variableDeclarator.Initializer = initializer; +>"
				<%	
					((LetQueryOperator)letQueryOperator).VariableDeclarators.Add(variableDeclarator);
					letQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="WhereClause" Parameters="out AstNode whereQueryOperator">
			<Production><![CDATA[
				<%
					whereQueryOperator = new WhereQueryOperator();
					whereQueryOperator.StartOffset = this.LookAheadToken.StartOffset;

					Expression condition;
				%>
				'Where'
				"Expression<@ out condition @><+ ((WhereQueryOperator)whereQueryOperator).Condition = condition; +>"
				<%	
					whereQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="JoinClause" Parameters="out AstNode joinQueryOperator">
			<Production><![CDATA[
				<%
					joinQueryOperator = new JoinQueryOperator();
					joinQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					CollectionRangeVariableDeclaration variableDeclaration = null;
					Expression expression;
					JoinCondition condition = new JoinCondition();
					QualifiedIdentifier variableName;
				%>
				'Join'
				"CollectionRangeVariableDeclaration<@ out variableDeclaration @><+ ((JoinQueryOperator)joinQueryOperator).CollectionRangeVariableDeclaration = variableDeclaration; +>"
				'On'
				<%
					condition.StartOffset = this.LookAheadToken.StartOffset;
				%>
				"Expression<@ out expression @><+ condition.LeftConditionExpression = expression; +>"
				'Equals'
				"Expression<@ out expression @><+ condition.RightConditionExpression = expression; +>"
				<%
					condition.EndOffset = this.Token.EndOffset;
					((JoinQueryOperator)joinQueryOperator).Conditions.Add(condition);
				%>				
				[
					'Into'
					"Identifier<@ out variableName @><+ ((JoinQueryOperator)joinQueryOperator).TargetExpressions.Add(new SimpleName(variableName.Text, variableName.TextRange)); +>"
				]
				<%
					joinQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="OrderByClause" Parameters="out AstNode orderByQueryOperator">
			<Production><![CDATA[
				<%
					orderByQueryOperator = new OrderByQueryOperator();
					orderByQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					Ordering ordering;
				%>

				'OrderBy'
				"Ordering<@ out ordering @><+ ((OrderByQueryOperator)orderByQueryOperator).Orderings.Add(ordering); +>"
				{ 
					'Comma'
					"Ordering<@ out ordering @><+ ((OrderByQueryOperator)orderByQueryOperator).Orderings.Add(ordering); +>"
				}
				<%	
					orderByQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: Orderings merged into OrderByClause -->
		<NonTerminal Key="Ordering" Parameters="out Ordering ordering">
			<Production><![CDATA[
				<%
					ordering = new Ordering();
					ordering.StartOffset = this.LookAheadToken.StartOffset;
					
					Expression expression;
				%>
				"Expression<@ out expression @><+ ordering.Expression = expression; +>"
				[
					'Ascending<+ ordering.Direction = OrderingDirection.Ascending; +>'
					| 'Descending<+ ordering.Direction = OrderingDirection.Descending; +>'
				]
				<%	
					ordering.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: OrderingDirection merged into Ordering -->
		<!-- NOTE: SelectOrGroupClause merged into QueryBody -->
		<NonTerminal Key="SelectClause" Parameters="out AstNode selectQueryOperator">
			<Production><![CDATA[
				<%
					selectQueryOperator = new SelectQueryOperator();
					selectQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					Expression expression;
					QualifiedIdentifier variableName;
				%>
				'Select'
				<%
					TypeReference typeReference = new TypeReference(TypeReference.AnonymousTypeName, new TextRange(this.LookAheadToken.StartOffset));
					VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, null, false, true); 
				%>
				"Expression<@ out expression @><+ 
						variableDeclarator.Initializer = expression; 
						((SelectQueryOperator)selectQueryOperator).VariableDeclarators.Add(variableDeclarator);	
					+>"
				[
					'Into'
					"Identifier<@ out variableName @><+ variableDeclarator.Name = variableName; variableDeclarator.TextRange = variableName.TextRange; +>"
				]
				<%
					selectQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="GroupClause" Parameters="out AstNode groupQueryOperator">
			<Production><![CDATA[
				<%
					groupQueryOperator = new GroupQueryOperator();
					groupQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					Expression expression;
				%>
				'Group'
				<%
					TypeReference typeReference = new TypeReference(TypeReference.AnonymousTypeName, new TextRange(this.LookAheadToken.StartOffset));
					VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, null, false, true); 
				%>
				"Expression<@ out expression @><+ 
						variableDeclarator.Initializer = expression; 
						((GroupQueryOperator)groupQueryOperator).Groupings.Add(variableDeclarator);	
					+>"
					
				'By'
				<%
					typeReference = new TypeReference(TypeReference.AnonymousTypeName, new TextRange(this.LookAheadToken.StartOffset));
					variableDeclarator = new VariableDeclarator(typeReference, null, false, true); 
				%>
				"Expression<@ out expression @><+ 
						variableDeclarator.Initializer = expression; 
						((GroupQueryOperator)groupQueryOperator).GroupBys.Add(variableDeclarator);	
					+>"
				
				[
					'Into'
					<%
						typeReference = new TypeReference(TypeReference.AnonymousTypeName, new TextRange(this.LookAheadToken.StartOffset));
						variableDeclarator = new VariableDeclarator(typeReference, null, false, true); 
					%>
					"Expression<@ out expression @><+ 
							variableDeclarator.Initializer = expression; 
							((GroupQueryOperator)groupQueryOperator).TargetExpressions.Add(variableDeclarator);	
						+>"
				]					
				<%	
					groupQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: QueryContinuation merged into QueryExpression -->
		
	</NonTerminals>
</Grammar>
	