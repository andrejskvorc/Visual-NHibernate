<!--

GRAMMAR PRODUCTION SYNTAX
'abc' - Terminal (token) with name "abc"
"abc" - Non-terminal with name "abc"
  |   - Alternation
 ( )  - Grouping
 [ ]  - Optional
 { }  - Iteration (zero or more)
<% %> - User code
<@ @> - Parameter code
<? ?> - Conditional code (can be used after a "[", "{", or "|")
<- -> - Failure match code
<+ +> - Successful match code

VALID IN CUSTOM CODE ONLY
IsNonTerminal("abc") - Returns a boolean as to whether the LookAheadToken can start the non-terminal "abc" 
IsNonTerminal("abc", "this.PeekToken") - Returns a boolean as to whether the specified token can start the non-terminal "abc" 

TODO:
ImportsStatement should handle multiple clauses delimited by a comma.
ImportsAliasClause and ImportsNamespaceClause don't handle ConstructedTypeName.
ArraySizeInitializationModifier is ignoring all contained expressions.
ContinueStatement doesn't store the ContinueKind.
ExitStatement doesn't store ExitKind.
DoStatement doesn't store whether the condition is at the beginning or end.
External method declarations don't store CharsetModifier, LibraryClause, or AliasClause.
Handle OrElse short-circuit distinction in InclusiveDisjunctionExpression?
Handle AndAlso short-circuit distinction in ConjunctionExpression?
For Each doesn't currently handle an Expression loop control variable.
Rank handling needs a lot of work.
New query expression keywords shouldn't really be lexically parsed as keyword unless they are in a query expression

-->
<Grammar 
	LanguageName="Visual Basic" 
	TypeName="VBSemanticParser"
	Namespace="ActiproSoftware.SyntaxEditor.Addons.VB"
	RootNonTerminal="CompilationUnit"
	LexicalStateIDTypeName="VBLexicalStateID"
	TokenIDTypeName="VBTokenID">
	<ImportedNamespaces>
		<ImportedNamespace>System.Collections</ImportedNamespace>
		<ImportedNamespace>System.Diagnostics</ImportedNamespace>
		<ImportedNamespace>System.Text</ImportedNamespace>
		<ImportedNamespace>ActiproSoftware.Products.SyntaxEditor.Addons.DotNet</ImportedNamespace>
		<ImportedNamespace>ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast</ImportedNamespace>
	</ImportedNamespaces>
	<LexicalStates>
		<LexicalState>Default</LexicalState>
		<LexicalState>DocumentationComment</LexicalState>
		<LexicalState>PreProcessorDirective</LexicalState>
	</LexicalStates>
	<Tokens>
		<!-- NOTE: Any changes here need to be made to VBSyntaxLanguage.GetTokenString -->
		<Token>Invalid</Token>
		<Token>DocumentEnd</Token>
		<Token>LanguageTransitionStart</Token>
		<Token>LanguageTransitionEnd</Token>

		<Token IsSignificant="false">Whitespace</Token>
		<Token IsSignificant="false">LineTerminator</Token>

		<Token IsSignificant="false">SingleLineComment</Token>
		<Token IsSignificant="false">RemComment</Token>
		
		<Token IsSignificant="false">DocumentationCommentDelimiter</Token>
		<Token IsSignificant="false">DocumentationCommentText</Token>
		<Token IsSignificant="false">DocumentationCommentTag</Token>
				
		<Token>DecimalIntegerLiteral</Token>
		<Token>HexadecimalIntegerLiteral</Token>
		<Token>OctalIntegerLiteral</Token>
		<Token>FloatingPointLiteral</Token>

		<Token>CharacterLiteral</Token>
		<Token>StringLiteral</Token>
		<Token>DateLiteral</Token>
		<Token>XmlLiteral</Token>
		<Token>XmlAttribute</Token>
		
		<Token>Identifier</Token>

		<Token IsSignificant="false">ContextualKeywordStart</Token>
		<Token>Aggregate</Token>
		<Token>Ascending</Token>
		<Token>By</Token>
		<Token>Descending</Token>
		<Token>Distinct</Token>
		<Token>Equals</Token>
		<Token>From</Token>
		<Token>Group</Token>
		<Token>Into</Token>
		<Token>Join</Token>
		<Token>Order</Token>
		<Token>Out</Token>
		<Token>Skip</Token>
		<Token>Take</Token>
		<Token>Where</Token>
		<Token IsSignificant="false">ContextualKeywordEnd</Token>

		<Token IsSignificant="false">KeywordStart</Token>
		<Token>AddHandler</Token>
		<Token>AddressOf</Token>
		<Token>Alias</Token>
		<Token>And</Token>
		<Token>AndAlso</Token>
		<Token>As</Token>
		<Token>Boolean</Token>
		<Token>ByRef</Token>
		<Token>Byte</Token>
		<Token>ByVal</Token>
		<Token>Call</Token>
		<Token>Case</Token>
		<Token>Catch</Token>
		<Token>CBool</Token>
		<Token>CByte</Token>
		<Token>CChar</Token>
		<Token>CDate</Token>
		<Token>CDbl</Token>
		<Token>CDec</Token>
		<Token>Char</Token>
		<Token>CInt</Token>
		<Token>Class</Token>
		<Token>CLng</Token>
		<Token>CObj</Token>
		<Token>Const</Token>
		<Token>Continue</Token>
		<Token>CSByte</Token>
		<Token>CShort</Token>
		<Token>CSng</Token>
		<Token>CStr</Token>
		<Token>CType</Token>
		<Token>CUInt</Token>
		<Token>CULng</Token>
		<Token>CUShort</Token>
		<Token>Custom</Token>
		<Token>Date</Token>
		<Token>Decimal</Token>
		<Token>Declare</Token>
		<Token>Default</Token>
		<Token>Delegate</Token>
		<Token>Dim</Token>
		<Token>DirectCast</Token>
		<Token>Do</Token>
		<Token>Double</Token>
		<Token>Each</Token>
		<Token>Else</Token>
		<Token>ElseIf</Token>
		<Token>End</Token>
		<Token>EndIf</Token>
		<Token>Enum</Token>
		<Token>Erase</Token>
		<Token>Error</Token>
		<Token>Event</Token>
		<Token>Exit</Token>
		<Token>False</Token>
		<Token>Finally</Token>
		<Token>For</Token>
		<Token>Friend</Token>
		<Token>Function</Token>
		<Token>Get</Token>
		<Token>GetTypeKeyword</Token>	<!-- NOTE: Had to add Keyword to the end since GetType causes a compilation error in the enum that is output -->
		<Token>GetXmlNamespace</Token>
		<Token>Global</Token>
		<Token>GoSub</Token>
		<Token>GoTo</Token>
		<Token>Handles</Token>
		<Token>If</Token>
		<Token>IIf</Token>
		<Token>Implements</Token>
		<Token>Imports</Token>
		<Token>In</Token>
		<Token>Inherits</Token>
		<Token>Integer</Token>
		<Token>Interface</Token>
		<Token>Is</Token>
		<Token>IsFalse</Token>
		<Token>IsNot</Token>
		<Token>IsTrue</Token>
		<Token>Let</Token>
		<Token>Lib</Token>
		<Token>Like</Token>
		<Token>Long</Token>
		<Token>Loop</Token>
		<Token>Me</Token>
		<Token>Mid</Token>
		<Token>Mod</Token>
		<Token>Module</Token>
		<Token>MustInherit</Token>
		<Token>MustOverride</Token>
		<Token>MyBase</Token>
		<Token>MyClass</Token>
		<Token>Namespace</Token>
		<Token>Narrowing</Token>
		<Token>New</Token>
		<Token>Next</Token>
		<Token>Not</Token>
		<Token>Nothing</Token>
		<Token>NotInheritable</Token>
		<Token>NotOverridable</Token>
		<Token>Object</Token>
		<Token>Of</Token>
		<Token>On</Token>
		<Token>Operator</Token>
		<Token>Option</Token>
		<Token>Optional</Token>
		<Token>Or</Token>
		<Token>OrElse</Token>
		<Token>Overloads</Token>
		<Token>Overridable</Token>
		<Token>Overrides</Token>
		<Token>ParamArray</Token>
		<Token>Partial</Token>
		<Token>Private</Token>
		<Token>Property</Token>
		<Token>Protected</Token>
		<Token>Public</Token>
		<Token>RaiseEvent</Token>
		<Token>ReadOnly</Token>
		<Token>ReDim</Token>
		<Token>REM</Token>
		<Token>RemoveHandler</Token>
		<Token>Resume</Token>
		<Token>Return</Token>
		<Token>SByte</Token>
		<Token>Select</Token>
		<Token>Set</Token>
		<Token>Shadows</Token>
		<Token>Shared</Token>
		<Token>Short</Token>
		<Token>Single</Token>
		<Token>Static</Token>
		<Token>Step</Token>
		<Token>Stop</Token>
		<Token>String</Token>
		<Token>Structure</Token>
		<Token>Sub</Token>
		<Token>SyncLock</Token>
		<Token>Then</Token>
		<Token>Throw</Token>
		<Token>To</Token>
		<Token>True</Token>
		<Token>Try</Token>
		<Token>TryCast</Token>
		<Token>TypeOf</Token>
		<Token>UInteger</Token>
		<Token>ULong</Token>
		<Token>Until</Token>
		<Token>UShort</Token>
		<Token>Using</Token>
		<Token>Variant</Token>
		<Token>Wend</Token>
		<Token>When</Token>
		<Token>While</Token>
		<Token>Widening</Token>
		<Token>With</Token>
		<Token>WithEvents</Token>
		<Token>WriteOnly</Token>
		<Token>Xor</Token>	
		<Token IsSignificant="false">KeywordEnd</Token>

		<Token IsSignificant="false">OperatorOrPunctuatorStart</Token>
		<Token>LineContinuation</Token>
		<!-- Separators -->
		<Token>OpenParenthesis</Token>
		<Token>CloseParenthesis</Token>
		<Token>OpenCurlyBrace</Token>
		<Token>CloseCurlyBrace</Token>
		<Token>OpenSquareBrace</Token>
		<Token>CloseSquareBrace</Token>
		<Token>Comma</Token>
		<Token>Dot</Token>
		<Token>Colon</Token>
		<Token>ColonEquals</Token>
		<Token>ExclamationPoint</Token>
		<Token>QuestionMark</Token>
		<Token>DotAt</Token>
		<Token>TripleDot</Token>
		<!-- Operators -->
		<Token>StringConcatenation</Token>
		<Token>Multiplication</Token>
		<Token>Addition</Token>
		<Token>Subtraction</Token>
		<Token>FloatingPointDivision</Token>
		<Token>IntegerDivision</Token>
		<Token>Exponentiation</Token>
		<Token>LessThan</Token>
		<Token>Equality</Token>
		<Token>GreaterThan</Token>
		<Token>LessThanOrEqual</Token>
		<Token>GreaterThanOrEqual</Token>
		<Token>Inequality</Token>
		<Token>LeftShift</Token>
		<Token>RightShift</Token>
		<Token>StringConcatenationAssignment</Token>
		<Token>MultiplicationAssignment</Token>
		<Token>AdditionAssignment</Token>
		<Token>SubtractionAssignment</Token>
		<Token>FloatingPointDivisionAssignment</Token>
		<Token>IntegerDivisionAssignment</Token>
		<Token>ExponentiationAssignment</Token>
		<Token>LeftShiftAssignment</Token>
		<Token>RightShiftAssignment</Token>
		<Token IsSignificant="false">OperatorOrPunctuatorEnd</Token>

		<Token IsSignificant="false">PreProcessorDirectiveKeywordStart</Token>
		<Token IsSignificant="false">ConstPreProcessorDirective</Token>
		<Token IsSignificant="false">IfPreProcessorDirective</Token>
		<Token IsSignificant="false">ElseIfPreProcessorDirective</Token>
		<Token IsSignificant="false">ElsePreProcessorDirective</Token>
		<Token IsSignificant="false">EndIfPreProcessorDirective</Token>
		<Token IsSignificant="false">ExternalSourcePreProcessorDirective</Token>
		<Token IsSignificant="false">EndExternalSourcePreProcessorDirective</Token>
		<Token IsSignificant="false">RegionPreProcessorDirective</Token>
		<Token IsSignificant="false">EndRegionPreProcessorDirective</Token>
		<Token IsSignificant="false">ExternalChecksumPreProcessorDirective</Token>
		<Token IsSignificant="false">PreProcessorDirectiveKeywordEnd</Token>
		
		<Token IsSignificant="false">PreProcessorDirectiveText</Token>

		<Token>MaxTokenID</Token>		
	</Tokens>
	<Declarations><![CDATA[
		
		private Stack			blockStack;
		private CompilationUnit	compilationUnit;
		private StringBuilder	identifierStringBuilder = new StringBuilder();
		private int				nestingLevel;
		
		/// <summary>
		/// Stores information about a block node.
		/// </summary>
		private class BlockData {
		
			public AstNode	Node;
			public int		TokenID;
				
			/// <summary>
			/// Initializes a new instance of the <c>BlockData</c> class.
			/// </summary>
			/// <param name="tokenID">The ID of the token for the block.</param>
			/// <param name="node">The <see cref="AstNode"/> that is starting a block.</param>
			public BlockData(int tokenID, AstNode node) {
				// Initialize parameters
				this.TokenID	= tokenID;
				this.Node		= node;
			}
		
		}

		/// <summary>
		/// Initializes a new instance of the <c>VBSemanticParser</c> class.
		/// </summary>
		/// <param name="lexicalParser">The <see cref="ActiproSoftware.SyntaxEditor.ParserGenerator.IRecursiveDescentLexicalParser"/> to use for lexical parsing.</param>
		public VBSemanticParser(ActiproSoftware.SyntaxEditor.ParserGenerator.IRecursiveDescentLexicalParser lexicalParser) : base(lexicalParser) {}
	
		/// <summary>
		/// Advances past any line terminators.
		/// </summary>
		private void AdvancePastTerminators() {
			while (!this.IsAtEnd) {
				if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator))
					this.AdvanceToNext();
				else
					break;
			}			
		}

		/// <summary>
		/// Advances to the next <see cref="IToken"/>.
		/// </summary>
		/// <returns>
		/// The <see cref="IToken"/> that was read.
		/// </returns>
		protected override IToken AdvanceToNext() {
			IToken token = base.AdvanceToNext();
			if (!this.TokenIsLanguageChange(token)) {
				switch (token.ID) {
					case VBTokenID.While:
						nestingLevel++;
						break;
					case VBTokenID.End:
						nestingLevel--;
						break;
				}
			}
			return token;
		}

		/// <summary>
		/// Advances past the next matching end.
		/// </summary>
		/// <param name="tokenID">The ID of the desired end token.</param>
		/// <returns>
		/// <c>true</c> if a match was found; otherwise, <c>false</c>.
		/// </returns>
		private bool AdvanceToNextEnd(int tokenID) {
			return this.AdvanceToNextEnd(tokenID, false);
		}
	
		/// <summary>
		/// Advances past the next matching end.
		/// </summary>
		/// <param name="tokenID">The ID of the desired end token.</param>
		/// <param name="quitOnNonStatementEnd">Whether to quit on a non-statement end.</param>
		/// <returns>
		/// <c>true</c> if a match was found; otherwise, <c>false</c>.
		/// </returns>
		private bool AdvanceToNextEnd(int tokenID, bool quitOnNonStatementEnd) {
			int depth = 1;
			while (!this.IsAtEnd) {
				if ((this.IsEnd(tokenID)) && (--depth == 0))
					break;
				if ((quitOnNonStatementEnd) && (this.IsEndOfNonStatement()))
					return false;
				if (this.TokenIs(this.LookAheadToken, tokenID))
					depth++;
				this.AdvanceToNext();
			}			
			
			// Quit if at the end of the document
			if (this.IsAtEnd)
				return false;
				
			// Skip over the End and next token
			this.AdvanceToNext();
			this.AdvanceToNext();
			return true;
		}
	
		/// <summary>
		/// Advances past the next statement terminator.
		/// </summary>
		private void AdvanceToNextStatementTerminator() {
			this.AdvanceToNextStatementTerminator(true);
		}

		/// <summary>
		/// Advances past the next statement terminator.
		/// </summary>
		/// <param name="movePast">Whether to move past the statement terminator.</param>
		private void AdvanceToNextStatementTerminator(bool movePast) {
			while (!this.IsAtEnd) {
				if ((this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) || (this.TokenIs(this.LookAheadToken, VBTokenID.Colon))) {
					if (movePast) {
						this.AdvanceToNext();
						this.AdvancePastTerminators();
					}
					break;
				}
				this.AdvanceToNext();
			}			
		}

		/// <summary>
		/// Returns whether the next two <see cref="IToken"/> objects match the specified IDs.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the next two <see cref="IToken"/> objects match the specified IDs; otherwise, <c>false</c>.
		/// </returns>
		private bool AreNextTwo(int firstTokenID, params int[] secondTokenIDs) {
			return (this.TokenIs(this.LookAheadToken, firstTokenID)) && (this.TokenIs(this.GetLookAheadToken(2), secondTokenIDs));
		}
		
		/// <summary>
		/// Returns whether the next two <see cref="IToken"/> objects match an identifier and the specified ID.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the next two <see cref="IToken"/> objects match an identifier and the specified ID; otherwise, <c>false</c>.
		/// </returns>
		private bool AreNextTwoIdentifierAnd(int secondTokenID) {
			return (this.IsIdentifier(this.LookAheadToken)) && 
				this.TokenIs(this.GetLookAheadToken(2), secondTokenID);
		}
		
		/// <summary>
		/// Adds a child node to the current block.
		/// </summary>
		/// <param name="node">The <see cref="AstNode"/> to add to the current block.</param>
		private void BlockAddChild(AstNode node) {
			AstNode currentBlock = (blockStack.Count > 0 ? (AstNode)((BlockData)blockStack.Peek()).Node : null);
		
			// If the node is a type declaration, add it to the Types list
			if (node is TypeDeclaration) 
				compilationUnit.Types.Add(node);
		
			if (currentBlock == null) {
				// Compilation unit
				if ((node is NamespaceDeclaration) || (node is TypeDeclaration)) {
					compilationUnit.NamespaceMembers.Add(node);
					return;
				}
			}
			else {
				if (currentBlock is NamespaceDeclaration) {
					if ((node is NamespaceDeclaration) || (node is TypeDeclaration)) {
						((NamespaceDeclaration)currentBlock).NamespaceMembers.Add(node);
						return;
					}
				}
				else if (currentBlock is TypeDeclaration) {
					if (node is TypeMemberDeclaration) {
						((TypeDeclaration)currentBlock).Members.Add(node);
						return;
					}
				}
			}
			
			// 12/29/2009 (14A-12CCDF57-DE29) - throw new NotSupportedException();
		}

		/// <summary>
		/// Starts a block and pushes it on the block stack.
		/// </summary>
		/// <param name="tokenID">The ID of the token for the block.</param>
		/// <param name="node">The <see cref="AstNode"/> that is starting a block.</param>
		private void BlockStart(int tokenID, AstNode node) {
			// Push the block data on the stack
			BlockData data = new BlockData(tokenID, node);
			this.BlockAddChild(node);
			blockStack.Push(data);
		}

		/// <summary>
		/// Ends the current block and pops it from the block stack.
		/// </summary>
		private void BlockEnd() {
			blockStack.Pop();
		}

		/// <summary>
		/// Gets the <see cref="CompilationUnit"/> that was parsed.
		/// </summary>
		/// <value>The <see cref="CompilationUnit"/> that was parsed.</value>
		public CompilationUnit CompilationUnit {
			get {
				return compilationUnit;
			}
		}

		/// <summary>
		/// Returns an inferred <see cref="TypeReference"/> for the return type of the specified <see cref="Expression"/> initializer.
		/// </summary>
		/// <param name="initializer">The <see cref="Expression"/> to examine.</param>
		/// <param name="allowNull">Whether to allow a null initializer.</param>
		/// <returns>An inferred <see cref="TypeReference"/> for the return type of the specified <see cref="Expression"/> initializer.</returns>
		private TypeReference GetImplicitType(Expression initializer, bool allowNull) {
			if (initializer == null) {
				this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ImplicitlyTypedVariableDeclarationNoInitializer"));
				return null;
			}
			
			// NOTE: GetReturnType is not currently looking backwards to resolve SimpleName references, thus foreach use of var will
			//		 reflect System.Object most of the time
			
			// Try and determine what the type reference is from the initializer
			TypeReference typeReference = this.GetReturnType(initializer);
						
			// Clone the type reference
			if (typeReference != null)
				typeReference = typeReference.Clone();

			// TODO: Need to ensure that a collection initializer is not passed.
			
			if ((!allowNull) && (typeReference == null))
				this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ImplicitlyTypedVariableDeclarationNullInitializer"));
				
			return typeReference;
		}
		
		/// <summary>
		/// Returns an inferred <see cref="TypeReference"/> for the return type of the specified <see cref="Expression"/>.
		/// </summary>
		/// <param name="expression">The <see cref="Expression"/> to examine.</param>
		/// <returns>An inferred <see cref="TypeReference"/> for the return type of the specified <see cref="Expression"/>.</returns>
		private TypeReference GetReturnType(Expression expression) {
			if (expression is LiteralExpression) {
				switch (((LiteralExpression)expression).LiteralType) {
					case LiteralType.True:
					case LiteralType.False:
						return new TypeReference("System.Boolean", expression.TextRange);
					case LiteralType.DecimalInteger:
					case LiteralType.HexadecimalInteger:
					case LiteralType.OctalInteger:
						return new TypeReference("System.Int32", expression.TextRange);
					case LiteralType.Real:
						return new TypeReference("System.Double", expression.TextRange);
					case LiteralType.Character:
						return new TypeReference("System.Char", expression.TextRange);
					case LiteralType.String:
					case LiteralType.VerbatimString:
						return new TypeReference("System.String", expression.TextRange);
					case LiteralType.Date:
						return new TypeReference("System.DateTime", expression.TextRange);
					case LiteralType.Null:
						return null;
				}
			}
			else if (expression is CastExpression)
				return ((CastExpression)expression).ReturnType;
			else if (expression is DefaultValueExpression)
				return ((DefaultValueExpression)expression).ReturnType;
			else if (expression is ObjectCreationExpression)
				return ((ObjectCreationExpression)expression).ObjectType;
			else if (expression is ParenthesizedExpression)
				return this.GetReturnType(((ParenthesizedExpression)expression).Expression);
			else if (expression is SizeOfExpression)
				return new TypeReference("System.Int32", expression.TextRange);
			else if (expression is TryCastExpression)
				return ((TryCastExpression)expression).ReturnType;
			else if (expression is TypeOfExpression)
				return new TypeReference("System.Type", expression.TextRange);
			else if (expression is TypeReferenceExpression)
				return ((TypeReferenceExpression)expression).TypeReference;
				
			// No type could be found within the initializer
			return new TypeReference("System.Object", expression.TextRange);
		}
	
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of an array creation expression (after the type name).
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of an array creation expression (after the type name); otherwise, <c>false</c>.
		/// </returns>
		private bool IsArrayCreationExpression() {
			if (!this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis))
				return false;
			
			// Look for an open curly brace after matching pairs of parenthesis
			int curlyBraceLevel = 0;
			int parenthesisLevel = 1;
			this.StartPeek();
			try {
				this.Peek();  // Skip the open parenthesis
				while (!this.IsAtEnd) {						
					if (this.TokenIsLanguageChange(this.PeekToken))
						return false;
					switch (this.PeekToken.ID) {
						case VBTokenID.OpenCurlyBrace:
							curlyBraceLevel++;							
							break;
						case VBTokenID.CloseCurlyBrace:
							--curlyBraceLevel;							
							break;
						case VBTokenID.OpenParenthesis:
							parenthesisLevel++;							
							break;
						case VBTokenID.CloseParenthesis:
							if (--parenthesisLevel < 1) {
								this.Peek();
								return this.TokenIs(this.PeekToken, VBTokenID.OpenCurlyBrace);
							}
							break;
						case VBTokenID.LineTerminator:
							return false;
					}
					this.Peek();
				}
				return false;
			}
			finally {
				this.StopPeek();
			}
		}
				
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of an array type modifier.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of an array type modifier; otherwise, <c>false</c>.
		/// </returns>
		private bool IsArrayTypeModifier() {
			return (this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis)) && (
				(this.TokenIs(this.GetLookAheadToken(2), VBTokenID.CloseParenthesis)) || (this.TokenIs(this.GetLookAheadToken(2), VBTokenID.Comma))
				);
		}
	
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is a statement block terminator.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is a statement block terminator; otherwise, <c>false</c>.
		/// </returns>
		private bool IsBlockTerminator() {
			switch (this.LookAheadToken.ID) {
				case VBTokenID.Case:
				case VBTokenID.Catch:
				case VBTokenID.Else:
				case VBTokenID.ElseIf:
				case VBTokenID.Finally:
				case VBTokenID.Loop:
				case VBTokenID.Next:
					// Double check for language change
					if (this.TokenIs(this.LookAheadToken, this.LookAheadToken.ID))
						return true;					
					break;
				case VBTokenID.End:
					// Double check for language change
					if ((this.TokenIs(this.LookAheadToken, this.LookAheadToken.ID)) && (!this.IsEndStatement()))
						return true;					
					break;
			}
			return false;
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a conditional expression.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a conditional expression; otherwise, <c>false</c>.
		/// </returns>
		private bool IsConditionalExpression() {
			if (!this.AreNextTwo(VBTokenID.If, VBTokenID.OpenParenthesis))
				return false;
			
			// Look for a comma
			int curlyBraceLevel = 0;
			int parenthesisLevel = 1;
			this.StartPeek();
			try {
				this.Peek();  // Skip the If
				this.Peek();  // Skip the open parenthesis
				while (!this.IsAtEnd) {						
					if (this.TokenIsLanguageChange(this.PeekToken))
						return false;
					switch (this.PeekToken.ID) {
						case VBTokenID.OpenCurlyBrace:
							curlyBraceLevel++;							
							break;
						case VBTokenID.CloseCurlyBrace:
							--curlyBraceLevel;							
							break;
						case VBTokenID.OpenParenthesis:
							parenthesisLevel++;							
							break;
						case VBTokenID.CloseParenthesis:
							if (--parenthesisLevel < 1)
								return false;
							break;
						case VBTokenID.Comma:
							if (parenthesisLevel == 1)
								return true;
							break;
						case VBTokenID.LineTerminator:
							return false;
					}
					this.Peek();
				}
				return false;
			}
			finally {
				this.StopPeek();
			}
		}
		
		/// <summary>
		/// Returns whether the specified <see cref="IToken"/> is a contextual keyword.
		/// </summary>
		/// <param name="token">The <see cref="IToken"/> to examine.</param>
		/// <returns>
		/// <c>true</c> if the specified <see cref="IToken"/> is a Contextual keyword; otherwise, <c>false</c>.
		/// </returns>
		private bool IsContextualKeyword(IToken token) {
			if ((token.ID > VBTokenID.ContextualKeywordStart) && (token.ID < VBTokenID.ContextualKeywordEnd)) {
				// Double check for language change
				if (this.TokenIs(token, token.ID))
					return true;					
			}
			return false;
		}
			
		/// <summary>
		/// Returns whether the next two <see cref="IToken"/> objects are a dot followed by an identifier or keyword.
		/// </summary>
		/// <param name="allowXml">Whether to allow XML literals and attributes as well.</param>
		/// <returns>
		/// <c>true</c> if the next two <see cref="IToken"/> objects are a dot followed by an identifier or keyword; otherwise, <c>false</c>.
		/// </returns>
		private bool IsDotIdentifierOrKeyword(bool allowXml) {
			if (!this.TokenIs(this.LookAheadToken, VBTokenID.Dot))
				return false;
				
			IToken token = this.GetLookAheadToken(2);
			if ((this.IsIdentifier(token)) || (this.IsKeyword(token)))
				return true;

			if (allowXml)
				return (this.TokenIs(token, VBTokenID.XmlLiteral)) || (this.TokenIs(token, VBTokenID.XmlAttribute));
			else
				return false;
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is a specified end.
		/// </summary>
		/// <param name="tokenID">The ID of the desired end token.</param>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is a specified end; otherwise, <c>false</c>.
		/// </returns>
		private bool IsEnd(int tokenID) {
			return (this.TokenIs(this.LookAheadToken, VBTokenID.End)) && (this.TokenIs(this.GetLookAheadToken(2), tokenID));
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is an end of a non-statement.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is an end of a non-statement; otherwise, <c>false</c>.
		/// </returns>
		private bool IsEndOfNonStatement() {
			return (this.TokenIs(this.LookAheadToken, VBTokenID.End)) && (this.TokenIs(this.GetLookAheadToken(2), new int[] { 
				VBTokenID.Sub, VBTokenID.Function, VBTokenID.Get, VBTokenID.Set, VBTokenID.Class, VBTokenID.Structure, 
				VBTokenID.Module, VBTokenID.Interface, VBTokenID.Namespace, VBTokenID.Operator, 
				VBTokenID.AddHandler, VBTokenID.RemoveHandler, VBTokenID.RaiseEvent, VBTokenID.Event }));
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is an end statement.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is an end statement; otherwise, <c>false</c>.
		/// </returns>
		private bool IsEndStatement() {
			return (this.TokenIs(this.LookAheadToken, VBTokenID.End)) && (
				(this.TokenIs(this.GetLookAheadToken(2), VBTokenID.LineTerminator)) || (this.TokenIs(this.GetLookAheadToken(2), VBTokenID.Colon)));
		}
		
		/// <summary>
		/// Returns whether the specified <see cref="IToken"/> is an identifier (or contextual keyword).
		/// </summary>
		/// <param name="token">The <see cref="IToken"/> to examine.</param>
		/// <returns>
		/// <c>true</c> if the specified <see cref="IToken"/> is an identifier (or contextual keyword); otherwise, <c>false</c>.
		/// </returns>
		private bool IsIdentifier(IToken token) {
			return (this.TokenIs(token, VBTokenID.Identifier)) ||
				(this.IsContextualKeyword(token));
		}
		
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is a keyword.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is a keyword; otherwise, <c>false</c>.
		/// </returns>
		private bool IsKeyword() {
			return this.IsKeyword(this.LookAheadToken);
		}
		
		/// <summary>
		/// Returns whether the specified <see cref="IToken"/> is a keyword.
		/// </summary>
		/// <param name="token">The <see cref="IToken"/> to examine.</param>
		/// <returns>
		/// <c>true</c> if the specified <see cref="IToken"/> is a keyword; otherwise, <c>false</c>.
		/// </returns>
		private bool IsKeyword(IToken token) {
			if ((token.ID > VBTokenID.KeywordStart) && (token.ID < VBTokenID.KeywordEnd)) {
				// Double check for language change
				if (this.TokenIs(token, token.ID))
					return true;					
			}
			return false;
		}
			
		/// <summary>
		/// Returns whether the look-ahead <see cref="IToken"/> comes immediately after the previous token.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the look-ahead <see cref="IToken"/> comes immediately after the previous token; otherwise, <c>false</c>.
		/// </returns>
		private bool IsLookAheadTokenSequential() {
			return (this.Token.EndOffset == this.LookAheadToken.StartOffset);
		}
	
		/// <summary>
		/// Returns whether the current <see cref="IToken"/> is the start of a variable declarator.
		/// </summary>
		/// <returns>
		/// <c>true</c> if the current <see cref="IToken"/> is the start of a variable declarator; otherwise, <c>false</c>.
		/// </returns>
		private bool IsVariableDeclarator() {
			// Must start with an identifier
			if (!this.IsIdentifier(this.LookAheadToken))
				return false;
			
			this.StartPeek();
			try {
				this.Peek();  // Skip the identifier
				while (!this.IsAtEnd) {						
					if (this.TokenIsLanguageChange(this.PeekToken))
						return false;
					switch (this.PeekToken.ID) {
						case VBTokenID.QuestionMark:
						case VBTokenID.OpenParenthesis:
							// Allow
							break;
						case VBTokenID.As:
						case VBTokenID.Equality:
						case VBTokenID.Comma:
						case VBTokenID.CloseParenthesis:
							return true;
						default:
							return false;
					}
					this.Peek();
				}
				return false;
			}
			finally {
				this.StopPeek();
			}
		}
		
		/// <summary>
		/// Flags any generic parameters that are located.
		/// </summary>
		/// <param name="typeParameterList">The list of type parameters that are defined.</param>
		/// <param name="typeReference">The <see cref="TypeReference"/> to examine.</param>
		/// <param name="allowTopLevelMark">Whether to allow the type reference to be marked.</param>
		private void MarkGenericParameters(IAstNodeList typeParameterList, TypeReference typeReference, bool allowTopLevelMark) {
			if ((typeParameterList == null) || (typeReference == null))
				return;

			if (allowTopLevelMark) {
				// Look for a match on the specified type reference
				foreach (TypeReference declaredTypeParameter in typeParameterList) {
					if (declaredTypeParameter.Name == typeReference.Name) {
						typeReference.IsGenericParameter = true;
						return;
					}
				}
			}

			// Recurse
			if (typeReference.GenericTypeArguments != null) {
				foreach (TypeReference genericTypeArgument in typeReference.GenericTypeArguments)
					this.MarkGenericParameters(typeParameterList, genericTypeArgument, true);
			}
		}

		/// <summary>
		/// Parses the code and returns the list of arguments that were parsed.
		/// </summary>
		/// <returns>
		/// An <see cref="IAstNodeList" /> containing the list of arguments that were parsed.
		/// </returns>
		internal IAstNodeList ParseArgumentList() {
			// Initialize
			blockStack = new Stack();
			compilationUnit = new CompilationUnit();
			compilationUnit.SourceLanguage = DotNetLanguage.VB;
			compilationUnit.StartOffset = this.LookAheadToken.StartOffset;
			
			// Match argument list		
			AstNodeList argumentList = new AstNodeList(null);
			this.MatchArgumentList(out argumentList);

			// Finalize
			compilationUnit.EndOffset = this.LookAheadToken.EndOffset;
			
			return argumentList;			
		}

		/// <summary>
		/// Reaps the comments that have been collected since the last reaping and adds them to an <see cref="IAstNodeList"/>.
		/// </summary>
		/// <param name="nodes">The <see cref="IAstNodeList"/> that should receive any reaped comment nodes.</param>
		/// <param name="sort">Whether to sort the sibling nodes.</param>
		private void ReapComments(IAstNodeList nodes, bool sort) {
			if (this.LexicalParser is VBRecursiveDescentLexicalParser) {
				Comment[] comments = ((VBRecursiveDescentLexicalParser)this.LexicalParser).ReapComments(nodes.ParentNode.TextRange);
				if (comments != null) {
					foreach (Comment comment in comments)
						nodes.Add(comment);
					if (sort)
						nodes.ParentNode.ChildNodes.SortByStartOffset();
				}
			}
		}

		/// <summary>
		/// Reaps the documentation comments that have been collected since the last reaping.
		/// </summary>
		/// <returns>The documentation comments that have been collection since the last reaping.</returns>
		private string ReapDocumentationComments() {
			if (this.LexicalParser is VBRecursiveDescentLexicalParser)
				return ((VBRecursiveDescentLexicalParser)this.LexicalParser).ReapDocumentationComments();
			else
				return null;
		}

		/// <summary>
		/// Reports a syntax error.
		/// </summary>
		/// <param name="textRange">The <see cref="TextRange"/> of the error.</param>
		/// <param name="message">The error message.</param>
		protected override void ReportSyntaxError(TextRange textRange, string message) {
			// Don't allow multiple errors at the same offset
			if ((compilationUnit.SyntaxErrors.Count > 0) && (((SyntaxError)compilationUnit.SyntaxErrors[compilationUnit.SyntaxErrors.Count - 1]).TextRange.StartOffset == textRange.StartOffset))
				return;
			
			compilationUnit.SyntaxErrors.Add(new SyntaxError(textRange, message));
		}
		
	]]></Declarations>
	<NonTerminals>
		
		<!-- 13.1.2 Identifiers -->
		<NonTerminal Key="SimpleIdentifier">
			<Production><![CDATA[
				'Identifier<- ->'
				| 'Aggregate<- ->'
				| 'Ascending<- ->'
				| 'By<- ->'
				| 'Descending<- ->' 
				| 'Distinct<- ->'
				| 'Equals<- ->'
				| 'From<- ->'
				| 'Group<- ->'
				| 'Into<- ->'
				| 'Join<- ->'
				| 'Order<- ->'
				| 'Out<- ->'
				| 'Skip<- ->'
				| 'Take<- ->'
				| 'Where<- ->'				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NonQueryIdentifier" Parameters="out QualifiedIdentifier identifier">
			<Production><![CDATA[
				<%
					identifier = new QualifiedIdentifier(this.LookAheadTokenText, this.LookAheadToken.TextRange); 
				%>
				'Identifier<- ->'
				<% 
					// Remove escape chars if they were used
					if ((identifier.Text.Length > 2) && (identifier.Text.StartsWith("[")) && (identifier.Text.EndsWith("]")))
						identifier.Text = identifier.Text.Substring(1, identifier.Text.Length - 2);
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Identifier" Parameters="out QualifiedIdentifier identifier">
			<Production><![CDATA[
				<%
					identifier = new QualifiedIdentifier(this.LookAheadTokenText, this.LookAheadToken.TextRange); 
				%>
				'Identifier<- ->'
				| 'Aggregate<- ->'
				| 'Ascending<- ->'
				| 'By<- ->'
				| 'Descending<- ->' 
				| 'Distinct<- ->'
				| 'Equals<- ->'
				| 'From<- ->'
				| 'Group<- ->'
				| 'Into<- ->'
				| 'Join<- ->'
				| 'Order<- ->'
				| 'Out<- ->'
				| 'Skip<- ->'
				| 'Take<- ->'
				| 'Where<- ->'				
				<% 
					// Remove escape chars if they were used
					if ((identifier.Text.Length > 2) && (identifier.Text.StartsWith("[")) && (identifier.Text.EndsWith("]")))
						identifier.Text = identifier.Text.Substring(1, identifier.Text.Length - 2);
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="IdentifierOrKeyword" Parameters="out QualifiedIdentifier identifier">
			<AdditionalConditions>
				<ExpressionCondition>this.IsKeyword()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					identifier = null;
					if (this.IsKeyword()) {
						identifier = new QualifiedIdentifier(this.TokenText, this.Token.TextRange); 
						this.AdvanceToNext();
						return true;
					}
				%>
				"Identifier<@ out identifier @>"
			]]></Production>
		</NonTerminal>
		
		<!-- 13.3 Syntactic Grammar -->
		<!-- NOTE: AccessModifier merged into Modifier -->
		<NonTerminal Key="Modifier" Parameters="out Modifiers modifier">
			<!-- NOTE: Modifier added to reduce ambiguity between type declarations -->
			<Production><![CDATA[
				<% modifier = Modifiers.None; %>
				'Public <+ modifier = Modifiers.Public; +><- ->'
				| 'Protected <+ modifier = Modifiers.Family; +><- ->'
				| 'Friend <+ modifier = Modifiers.Assembly; +><- ->'
				| 'Private <+ modifier = Modifiers.Private; +><- ->'				
				| 'Default <+ modifier = Modifiers.Default; +><- ->'
				| 'Dim <+ modifier = Modifiers.Dim; +><- ->'
				| 'MustInherit <+ modifier = Modifiers.Abstract; +><- ->'
				| 'MustOverride <+ modifier = Modifiers.Abstract; +><- ->'				
				| 'Narrowing <+ modifier = Modifiers.Narrowing; +><- ->'
				| 'NotInheritable <+ modifier = Modifiers.Final; +><- ->'				
				| 'NotOverridable <+ modifier = Modifiers.Final; +><- ->'				
				| 'Overloads <+ modifier = Modifiers.Overloads; +><- ->'
				| 'Overridable <+ modifier = Modifiers.Virtual; +><- ->'
				| 'Overrides <+ modifier = Modifiers.Override; +><- ->'
				| 'Partial <+ modifier = Modifiers.Partial; +><- ->'				
				| 'ReadOnly <+ modifier = Modifiers.ReadOnly; +><- ->'
				| 'Shadows <+ modifier = Modifiers.New; +><- ->' 				
				| 'Shared <+ modifier = Modifiers.Static; +><- ->'
				| 'Static <+ modifier = Modifiers.Static; +><- ->'
				| 'Widening <+ modifier = Modifiers.Widening; +><- ->'
				| 'WithEvents <+ modifier = Modifiers.WithEvents; +><- ->'
				| 'WriteOnly <+ modifier = Modifiers.WriteOnly; +><- ->'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Modifiers" Parameters="out Modifiers modifiers">
			<!-- NOTE: Modifier added to reduce ambiguity between type declarations -->
			<Production><![CDATA[
				<% 
					modifiers = Modifiers.None; 
					Modifiers singleModifier;
				%>
				{ "Modifier<@ out singleModifier @><+ modifiers |= singleModifier; +>" }
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="QualifiedIdentifier" Parameters="out QualifiedIdentifier identifier">
			<Production><![CDATA[
				<% 
					identifier = null;
					int startOffset = this.LookAheadToken.StartOffset;
					identifierStringBuilder.Length = 0;
				%>
				(
					( 
						'Global<- -><+ identifierStringBuilder.Append("Global"); +>'
						'Dot<+ identifierStringBuilder.Append("."); +>'
						"IdentifierOrKeyword<@ out identifier @><+ identifierStringBuilder.Append(identifier.Text); +>"
					)
					| "SimpleIdentifier<- -><+ identifierStringBuilder.Append(this.TokenText); +>"
				)
				{<? this.IsDotIdentifierOrKeyword(false) ?>
					'Dot'
					<%
						this.AdvanceToNext();
						identifierStringBuilder.Append(".");
						identifierStringBuilder.Append(this.TokenText);
					%>
				}
				<% 
					identifier = new QualifiedIdentifier(identifierStringBuilder.ToString(), new TextRange(startOffset, this.Token.EndOffset)); 
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="TypeParameterList" Parameters="out AstNodeList typeParameterList">
			<AdditionalConditions>
				<ClearFirstSet />
				<ExpressionCondition>this.AreNextTwo(VBTokenID.OpenParenthesis, VBTokenID.Of)</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					TypeReference typeParameter;
					typeParameterList = new AstNodeList(null);
				%>
				'OpenParenthesis'
				'Of'
				"TypeParameter<@ out typeParameter @><+ typeParameterList.Add(typeParameter); +>"
				{
					'Comma'
					"TypeParameter<@ out typeParameter @><+ typeParameterList.Add(typeParameter); +>"
				}
				'CloseParenthesis<- ->'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: TypeParameters merged into TypeParameterList -->
		<NonTerminal Key="TypeParameter" Parameters="out TypeReference typeParameter">
			<Production><![CDATA[
				<%
					typeParameter = null;
				%>
				[ 'In' | 'Out' ]
				"SimpleIdentifier"
				<%
					typeParameter = new TypeReference(this.TokenText, this.Token.TextRange);
					typeParameter.IsGenericParameter = true;
				%>
				[ 
					'As' 
					(
						"Constraint<@ typeParameter @>"
						| (
							'OpenCurlyBrace<- ->'
							"Constraint<@ typeParameter @>"							
							{ 'Comma' "Constraint<@ typeParameter @>" }
							'CloseCurlyBrace<- ->'
						)						
					)
				]
			]]></Production>
		</NonTerminal>
		<!-- NOTE: TypeParameterConstraints merged into TypeParameter -->
		<!-- NOTE: ConstraintList merged into TypeParameter -->
		<NonTerminal Key="Constraint" Parameters="TypeReference typeParameter">
			<Production><![CDATA[
				(
					<%
						TypeReference typeConstraint;
					%>
					"TypeName<@ out typeConstraint, false @><+
						if (typeParameter != null)
							typeParameter.GenericTypeParameterConstraints.Add(typeConstraint);
						+>"
				)
				| (
					'New<+
						if (typeParameter != null)
							typeParameter.HasGenericParameterDefaultConstructorConstraint = true;
						+>'
				)
			]]></Production>
		</NonTerminal>
		
		<!-- 13.3.1 Attributes -->
		<NonTerminal Key="Attributes" Parameters="IAstNodeList attributeSections">
			<Production><![CDATA[
				{ 
					<%
						AttributeSection attributeSection = new AttributeSection();
						attributeSection.StartOffset = this.LookAheadToken.StartOffset;
					%>
					'LessThan'
					"AttributeList<@ attributeSection @>"
					[ 'LineTerminator<- ->' ]
					'GreaterThan<- ->'
					<%
						attributeSection.EndOffset = this.Token.EndOffset;
						attributeSections.Add(attributeSection);
					%>
					[ 'Comma' ]
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: AttributeBlock merged into Attributes -->
		<NonTerminal Key="AttributeList" Parameters="AttributeSection attributeSection">
			<Production><![CDATA[
				"Attribute<@ attributeSection @>"
				{ <? (this.TokenIs(this.LookAheadToken, VBTokenID.Comma)) && ((this.IsIdentifier(this.GetLookAheadToken(2)))) || (this.TokenIs(this.GetLookAheadToken(2), VBTokenID.Global)) ?> 
					'Comma' "Attribute<@ attributeSection @>" 
					}
				[ 'Comma' ]
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Attribute" Parameters="AttributeSection attributeSection">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					string target = null;
				%>
				[ <? this.AreNextTwoIdentifierAnd(VBTokenID.Colon) ?>
					"SimpleIdentifier<+ target = this.TokenText; +>"
					'Colon' 
				]
				<% TypeReference typeReference = null; %>
				"TypeName<@ out typeReference, false @>"				
				<%
					ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute attribute = new ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute(typeReference);
					attribute.StartOffset = startOffset;
					attribute.Target = target;
				%>
				[ "AttributeArguments<@ attribute @>" ]
				<%
					attribute.EndOffset = this.Token.EndOffset;
					attributeSection.Attributes.Add(attribute);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: AttributeModifier merged into Attribute -->
		<NonTerminal Key="AttributeArguments" Parameters="ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute attribute">
			<Production><![CDATA[
				'OpenParenthesis'
				[<? (this.IsIdentifier(this.LookAheadToken)) || (this.IsKeyword(this.LookAheadToken)) || (IsNonTerminal("AttributeArgument")) ?>
					"AttributeArgument<@ attribute @>"
					{ 'Comma' "AttributeArgument<@ attribute @>" }
				]
				'CloseParenthesis'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="AttributeArgument" Parameters="ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute attribute">
			<Production><![CDATA[
				<%
					string name = null;
					Expression expression;
					int startOffset = this.LookAheadToken.StartOffset;

					if (((this.IsIdentifier(this.LookAheadToken)) || (this.IsKeyword(this.LookAheadToken))) && (this.TokenIs(this.GetLookAheadToken(2), VBTokenID.ColonEquals))) { 
						name = this.LookAheadTokenText;
						this.AdvanceToNext();  // Identifier/keyword
						this.AdvanceToNext();  // :=
					}
				%>
				"Expression<@ out expression @>"
				<%
					attribute.Arguments.Add(new AttributeArgument(name, expression, new TextRange(startOffset, this.Token.EndOffset)));
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: AttributePositionalArgumentList merged into AttributeArgument(s) -->
		<!-- NOTE: VariablePropertyInitializerList merged into AttributeArgument(s) -->
		<!-- NOTE: NamVariablePropertyInitializer merged into AttributeArgument(s) -->
		<!-- NOTE: AttributeArgumentExpression merged into AttributeArgument(s) -->
			
		<!-- 13.3.2 Source Files and Namespaces -->
		<NonTerminal Key="CompilationUnit">
			<Production><![CDATA[
				<% 
					blockStack = new Stack();
					nestingLevel = 0;
					compilationUnit = new CompilationUnit();
					compilationUnit.SourceLanguage = DotNetLanguage.VB;
					compilationUnit.StartOffset = this.LookAheadToken.StartOffset;
				%>
				{ "StatementTerminator<- ->" 
					| "OptionsStatement
					<- 
						// Error recovery:  Go to the next Option keyword, Imports keyword, or token that starts a AttributeStatement or NamespaceMemberDeclaration
						while (!this.IsAtEnd) {
							if ((this.TokenIs(this.LookAheadToken, VBTokenID.Option)) || (this.TokenIs(this.LookAheadToken, VBTokenID.Imports)) || 
								(IsNonTerminal("AttributesStatement")) || (IsNonTerminal("NamespaceMemberDeclaration")))
								break;
							this.AdvanceToNextStatementTerminator();
						}
					->" }
				{ "StatementTerminator<- ->" 
					| "ImportsStatement
					<- 
						// Error recovery:  Go to the next Imports keyword, or token that starts a AttributeStatement or NamespaceMemberDeclaration
						while (!this.IsAtEnd) {
							if ((this.TokenIs(this.LookAheadToken, VBTokenID.Imports)) || 
								(IsNonTerminal("AttributesStatement")) || (IsNonTerminal("NamespaceMemberDeclaration")))
								break;
							this.AdvanceToNextStatementTerminator();
						}
					->" }
				<%
					// Reap comments
					this.ReapComments(compilationUnit.Comments, false);
				%>
				{ "AttributesStatement" }
				<%
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
							// Skip over blank lines
							this.AdvancePastTerminators();
							continue;
						}			
						
						// Check for using statements in the wrong location
						if (this.TokenIs(this.LookAheadToken, VBTokenID.Option)) {
							this.ReportSyntaxError(this.LookAheadToken.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_OptionBeforeDeclarations"));
							this.AdvanceToNextStatementTerminator();
							continue;
						}
						else if (this.TokenIs(this.LookAheadToken, VBTokenID.Imports)) {
							this.ReportSyntaxError(this.LookAheadToken.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ImportsBeforeDeclarations"));
							this.AdvanceToNextStatementTerminator();
							continue;
						}
						else if (IsNonTerminal("NamespaceMemberDeclaration")) {
							errorReported = false;
					%>
							{ "NamespaceMemberDeclaration" }
					<% 
						}
						else {
							// Error recovery:  Advance to the next statement terminator since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_NamespaceMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNextStatementTerminator();
						}
					}
					compilationUnit.EndOffset = this.LookAheadToken.EndOffset;
					blockStack = null;
					
					// Reap comments
					this.ReapComments(compilationUnit.Comments, false);
					
					// Get the comment and region text ranges
					if (this.LexicalParser is VBRecursiveDescentLexicalParser) {
						compilationUnit.DocumentationCommentTextRanges = ((VBRecursiveDescentLexicalParser)this.LexicalParser).DocumentationCommentTextRanges;
						compilationUnit.RegionTextRanges = ((VBRecursiveDescentLexicalParser)this.LexicalParser).RegionTextRanges;
					}
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="StatementTerminator">
			<Production><![CDATA[
				'LineTerminator<+ this.AdvancePastTerminators(); +>
					<- this.AdvanceToNextStatementTerminator(); ->'
				| 'Colon<- this.AdvanceToNextStatementTerminator(); ->'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="AttributesStatement">
			<Production><![CDATA[
				[ "Attributes<@ compilationUnit.GlobalAttributeSections @><- ->" ]
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="OptionsStatement">
			<Production><![CDATA[
				'Option<- ->'
				"SimpleIdentifier<- this.AdvanceToNextStatementTerminator(); ->"
				<%
					switch (this.TokenText.ToLower()) {
						case "explicit":
							switch (this.LookAheadTokenText.ToLower()) {
								case "on":  // Default
									compilationUnit.OptionExplicit = "On";
									this.AdvanceToNext();
									break;
								case "off":
									compilationUnit.OptionExplicit = "Off";
									this.AdvanceToNext();
									break;
								default:
									if (!(IsNonTerminal("StatementTerminator"))) {
										this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_OptionExplicitSyntax"));
										this.AdvanceToNextStatementTerminator();
										return false;
									}
									break;
							}
							break;
						case "compare":
							switch (this.LookAheadTokenText.ToLower()) {
								case "binary":  // Default value
									compilationUnit.OptionCompare = "Binary";
									this.AdvanceToNext();
									break;
								case "text":
									compilationUnit.OptionCompare = "Text";
									this.AdvanceToNext();
									break;
								default:
									this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_OptionCompareSyntax"));
									this.AdvanceToNextStatementTerminator();
									return false;
							}
							break;
						case "strict":
							switch (this.LookAheadTokenText.ToLower()) {
								case "on":
									compilationUnit.OptionStrict = "On";
									this.AdvanceToNext();
									break;
								case "off":
									compilationUnit.OptionStrict = "Off";
									this.AdvanceToNext();
									break;
								default:
									if (!(IsNonTerminal("StatementTerminator"))) {
										this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_OptionStrictSyntax"));
										this.AdvanceToNextStatementTerminator();
										return false;
									}
									break;
							}
							break;
						case "infer":
							switch (this.LookAheadTokenText.ToLower()) {
								case "on":
									compilationUnit.OptionInfer = "On";
									this.AdvanceToNext();
									break;
								case "off":
									compilationUnit.OptionInfer = "Off";
									this.AdvanceToNext();
									break;
								default:
									if (!(IsNonTerminal("StatementTerminator"))) {
										this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_OptionInferSyntax"));
										this.AdvanceToNextStatementTerminator();
										return false;
									}
									break;
							}
							break;
						default:
							this.ReportSyntaxError(this.Token.TextRange, AssemblyInfo.Instance.Resources.GetString("SemanticParserError_OptionFollowedBy"));
							this.AdvanceToNextStatementTerminator();
							return false;
					}
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: OptionExplicitStatement merged into OptionsStatement -->
		<!-- NOTE: OffOn merged into OptionsStatement -->
		<!-- NOTE: OptionStrictStatement merged into OptionsStatement -->
		<!-- NOTE: OptionCompareStatement merged into OptionsStatement -->
		<!-- NOTE: CompareOption merged into OptionsStatement -->
		<NonTerminal Key="ImportsStatement">
			<Production><![CDATA[
				'Imports<- ->' 
				<%
					this.ReapDocumentationComments();
					
					if (compilationUnit.UsingDirectives == null)
						compilationUnit.UsingDirectives = new UsingDirectiveSection();					
					if (compilationUnit.UsingDirectives.Directives.Count == 0)
						compilationUnit.UsingDirectives.StartOffset = this.Token.StartOffset;
				%>
				"ImportsClause"
				{ 'Comma' "ImportsClause" }
				<% 
					compilationUnit.UsingDirectives.EndOffset = this.Token.EndOffset;
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ImportsClause">
			<Production><![CDATA[
				(
					'XmlLiteral'
					<%
						UsingDirective usingDirective = new UsingDirective(new TextRange(this.Token.StartOffset, this.Token.EndOffset));

						// Reap comments
						this.ReapComments(usingDirective.Comments, false);

						usingDirective.NamespaceName = new QualifiedIdentifier(this.TokenText, this.Token.TextRange);
						compilationUnit.UsingDirectives.Directives.Add(usingDirective);
					%>						
				)
				| (
					<%					
						if (this.AreNextTwoIdentifierAnd(VBTokenID.Equality)) { 
					%>
							"ImportsAliasClause<- ->"
					<% 
						}
						else { 
					%>
							"ImportsNamespaceClause<- ->"
					<% 
						}
					%>
				)
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ImportsAliasClause">
			<Production><![CDATA[
				<% 
					int startOffset = this.Token.StartOffset;
				%>
				"SimpleIdentifier<- ->"
				<% 
					string alias = this.TokenText;
					QualifiedIdentifier namespaceName; 
				%>
				'Equality<- ->' 
				"QualifiedIdentifier<@ out namespaceName @>" 
				<%
					UsingDirective usingDirective = new UsingDirective(new TextRange(startOffset, this.Token.EndOffset));

					// Reap comments
					this.ReapComments(usingDirective.Comments, false);

					usingDirective.NamespaceName = namespaceName;
					usingDirective.Alias = alias;
					compilationUnit.UsingDirectives.Directives.Add(usingDirective);
				%>						
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ImportsNamespaceClause">
			<Production><![CDATA[
				<% 
					int startOffset = this.Token.StartOffset;
					QualifiedIdentifier namespaceName; 
				%>
				"QualifiedIdentifier<@ out namespaceName @>" 
				<%
					UsingDirective usingDirective = new UsingDirective(new TextRange(startOffset, this.Token.EndOffset));

					// Reap comments
					this.ReapComments(usingDirective.Comments, false);

					usingDirective.NamespaceName = namespaceName;
					compilationUnit.UsingDirectives.Directives.Add(usingDirective);
				%>						
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NamespaceDeclaration">
			<Production><![CDATA[
				<%
					NamespaceDeclaration namespaceDeclaration = new NamespaceDeclaration();
				%>
				'Namespace'
				<%
					namespaceDeclaration.StartOffset = this.Token.StartOffset;
					namespaceDeclaration.BlockStartOffset = namespaceDeclaration.StartOffset;
					QualifiedIdentifier name;
				%>
				"QualifiedIdentifier<@ out name @>
					<- 
						// Error recovery:  Go to the next statement terminator
						this.AdvanceToNextStatementTerminator(); 
						return false;
					->"
				<%
					namespaceDeclaration.Name = name;
					this.BlockStart(VBTokenID.Namespace, namespaceDeclaration);
					int namespaceNestingLevel = nestingLevel;
					this.ReapDocumentationComments();
				%>
				"StatementTerminator<- ->"
				{ "NamespaceMemberDeclaration
					<- 
						// Error recovery:  Go to the next statement terminator
						this.AdvanceToNextStatementTerminator(false); 
					->" }
				<%
					this.BlockEnd();
					this.AdvanceToNextEnd(VBTokenID.Namespace);
					namespaceDeclaration.BlockEndOffset = this.Token.EndOffset;
					namespaceDeclaration.EndOffset = this.Token.EndOffset;

					// Reap comments
					this.ReapDocumentationComments();
					this.ReapComments(namespaceDeclaration.Comments, false);
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NamespaceMemberDeclaration">
			<Production><![CDATA[
				"StatementTerminator<- ->"
				| "NamespaceDeclaration"
				| (
					<%
						AstNodeList attributeSections = new AstNodeList(null);
						Modifiers modifiers = Modifiers.None;
					%>
					[ "Attributes<@ attributeSections @><- ->" ]
					<%
						int startOffset = this.LookAheadToken.StartOffset;
					%>
					[ "Modifiers<@ out modifiers @>" ]
					"TypeDeclaration<@ startOffset, attributeSections, modifiers @>"
				)
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="TypeDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and TypeModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				"ModuleDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "NonModuleDeclaration<@ startOffset, attributeSections, modifiers @>"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NonModuleDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and TypeModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				"EnumDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "DelegateDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "ClassDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "StructureDeclaration<@ startOffset, attributeSections, modifiers @>"
				| "InterfaceDeclaration<@ startOffset, attributeSections, modifiers @>"
			]]></Production>
		</NonTerminal>
		
		<!-- 13.3.3 Types -->
		<NonTerminal Key="TypeName" Parameters="out TypeReference typeReference, bool canBeUnbound">
			<Production><![CDATA[
				<%
					int[] arrayRanks;
				%>
				"NonArrayTypeName<@ out typeReference, canBeUnbound @>"
				{<? this.IsArrayTypeModifier() ?> "ArrayTypeModifier<@ out arrayRanks @><+ typeReference.ArrayRanks = arrayRanks; +>" }
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="NonArrayTypeName" Parameters="out TypeReference typeReference, bool canBeUnbound">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				(
					<%
						QualifiedIdentifier identifier;
						AstNodeList typeArgumentList = null;
					%>
					"QualifiedIdentifier<@ out identifier @>"
					[<? this.AreNextTwo(VBTokenID.OpenParenthesis, VBTokenID.Of) ?>					
						'OpenParenthesis'
						'Of'
						( 
							"TypeArgumentList<@ out typeArgumentList @>"
							| <? (canBeUnbound) && ((this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis)) || (this.TokenIs(this.LookAheadToken, VBTokenID.Comma))) ?> (
								<!-- TypeArityList -->
								{ 'Comma<+ typeArgumentList.Add(new TypeReference(null, TextRange.Deleted));  // Add a null type reference +>' }
							)
						)
						'CloseParenthesis'
					]
					<%
						typeReference = new TypeReference(identifier.Text, identifier.TextRange);
						if (typeArgumentList != null)
							typeReference.GenericTypeArguments.AddRange(typeArgumentList.ToArray());
					%>
				)
				| "BuiltInTypeName<@ out typeReference @>"
				
				[
					'QuestionMark'
					<%
						TypeReference nullableTypeReference = typeReference;
						typeReference = new TypeReference("System.Nullable", new TextRange(nullableTypeReference.StartOffset, this.Token.EndOffset));
						typeReference.GenericTypeArguments.Add(nullableTypeReference);
					%>
				]
			]]></Production>
		</NonTerminal>
		<!-- NOTE: SimpleTypeName merged into NonArrayTypeName -->
		<NonTerminal Key="BuiltInTypeName" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				'Object<+ typeReference = new TypeReference("System.Object", this.Token.TextRange); +>'
				| "IntegralTypeName<@ out typeReference @>"
				| 'Single<+ typeReference = new TypeReference("System.Single", this.Token.TextRange); +>'
				| 'Double<+ typeReference = new TypeReference("System.Double", this.Token.TextRange); +>'
				| 'Decimal<+ typeReference = new TypeReference("System.Decimal", this.Token.TextRange); +>'
				| 'Boolean<+ typeReference = new TypeReference("System.Boolean", this.Token.TextRange); +>'
				| 'Date<+ typeReference = new TypeReference("System.DateTime", this.Token.TextRange); +>'
				| 'Char<+ typeReference = new TypeReference("System.Char", this.Token.TextRange); +>'
				| 'String<+ typeReference = new TypeReference("System.String", this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: TypeModifier merged into callers of Modifiers -->
		<NonTerminal Key="TypeImplementsClause" Parameters="out AstNodeList implementsList">
			<Production><![CDATA[
				<%
					implementsList = null;
				%>
				'Implements'
				"Implements<@ out implementsList @>"
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Implements" Parameters="out AstNodeList implementsList">
			<Production><![CDATA[
				<%
					TypeReference typeReference;
					implementsList = new AstNodeList(null);
				%>
				"NonArrayTypeName<@ out typeReference, false @><+ implementsList.Add(typeReference); +>"
				{
					'Comma'
					"NonArrayTypeName<@ out typeReference, false @><+ implementsList.Add(typeReference); +>"
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: PrimitiveTypeName merged into BuiltInTypeName -->
		<!-- NOTE: NumericTypeName merged into BuiltInTypeName -->
		<NonTerminal Key="IntegralTypeName" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				'Byte<+ typeReference = new TypeReference("System.Byte", this.Token.TextRange); +>'
				| 'SByte<+ typeReference = new TypeReference("System.SByte", this.Token.TextRange); +>'
				| 'UShort<+ typeReference = new TypeReference("System.UInt16", this.Token.TextRange); +>'
				| 'Short<+ typeReference = new TypeReference("System.Int16", this.Token.TextRange); +>'
				| 'UInteger<+ typeReference = new TypeReference("System.UInt32", this.Token.TextRange); +>'
				| 'Integer<+ typeReference = new TypeReference("System.Int32", this.Token.TextRange); +>'
				| 'ULong<+ typeReference = new TypeReference("System.UInt64", this.Token.TextRange); +>'
				| 'Long<+ typeReference = new TypeReference("System.Int64", this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: FloatingPointTypeName merged into BuiltInTypeName -->
		<NonTerminal Key="EnumDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and ClassModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				'Enum'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to public access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Public;
				
					EnumerationDeclaration enumerationDeclaration = new EnumerationDeclaration(modifiers, identifier);
					enumerationDeclaration.Documentation = this.ReapDocumentationComments();
					enumerationDeclaration.StartOffset = startOffset;
					enumerationDeclaration.BlockStartOffset = startOffset;
					enumerationDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
				%>				
				[ 
					'As' 
					<%
						TypeReference typeReference;
					%>
					"NonArrayTypeName<@ out typeReference, false @><+ enumerationDeclaration.BaseTypes.Add(typeReference); +>"
				]
				"StatementTerminator<- ->"
				<%
					int enumerationNestingLevel = nestingLevel;
				
					this.BlockStart(VBTokenID.Enum, enumerationDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if (this.IsEnd(VBTokenID.Enum))
							break;
						else if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
							// Skip over line terminators
							this.AdvancePastTerminators();
						}
						else if (IsNonTerminal("EnumMemberDeclaration")) {
							errorReported = false;
					%>
							"EnumMemberDeclaration<- ->"
					<%
						}
						else {
							// Error recovery:  Advance to the next statement terminator since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_EnumerationMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNextStatementTerminator();
						}
					}
					
					this.BlockEnd();
					this.AdvanceToNextEnd(VBTokenID.Enum);
					enumerationDeclaration.BlockEndOffset = this.Token.EndOffset;
					enumerationDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapDocumentationComments();
					this.ReapComments(enumerationDeclaration.Comments, false);
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="EnumMemberDeclaration">
			<Production><![CDATA[
				<%
					AstNodeList attributeSections = new AstNodeList(null);
				%>
				[ "Attributes<@ attributeSections @><- ->" ]
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					EnumerationMemberDeclaration memberDeclaration = new EnumerationMemberDeclaration(identifier);
					memberDeclaration.Documentation = this.ReapDocumentationComments();
					memberDeclaration.StartOffset = startOffset;
					memberDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					this.BlockAddChild(memberDeclaration);
					Expression initializer;
				%>
				[ 'Equality' "Expression<@ out initializer @><+ memberDeclaration.Initializer = initializer; +>" ]
				<%
					memberDeclaration.EndOffset = this.Token.EndOffset;
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ClassDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and ClassModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				'Class'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to public access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Public;
				
					ClassDeclaration classDeclaration = new ClassDeclaration(modifiers, identifier);
					classDeclaration.Documentation = this.ReapDocumentationComments();
					classDeclaration.StartOffset = startOffset;
					classDeclaration.BlockStartOffset = startOffset;
					classDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					AstNodeList typeParameterList = null;
					AstNodeList implementsList = null;
				%>
				[ "TypeParameterList<@ out typeParameterList @>" ]
				<%
					if (typeParameterList != null)
						classDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
				%>
				"StatementTerminator<- ->"
				[ 
					'Inherits<- ->' 
					<%
						TypeReference typeReference;
					%>
					"NonArrayTypeName<@ out typeReference, false @><+ 
							// Ensure that generic type parameters are marked properly
							this.MarkGenericParameters(typeParameterList, typeReference, false);
							
							classDeclaration.BaseTypes.Add(typeReference); 
						+>
						<-
							// Error recovery:  Go to the next statement terminator
							this.AdvanceToNextStatementTerminator();
						->" 
					"StatementTerminator<- ->"
				]
				{ "TypeImplementsClause<@ out implementsList @><+
						if (implementsList != null) {
							// Ensure that generic type parameters are marked properly
							foreach (TypeReference typeReference in implementsList)
								this.MarkGenericParameters(typeParameterList, typeReference, false);

							classDeclaration.BaseTypes.AddRange(implementsList.ToArray());					
						}
					+>" }
				<%
					int classNestingLevel = nestingLevel;
					
					this.BlockStart(VBTokenID.Class, classDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if (this.IsEnd(VBTokenID.Class))
							break;
						else if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
							// Skip over line terminators
							this.AdvancePastTerminators();
						}
						else if (IsNonTerminal("Attributes") || IsNonTerminal("Modifier") || IsNonTerminal("StructureMemberDeclaration")) {
							errorReported = false;
							attributeSections = new AstNodeList(null);
						%>
							[ "Attributes<@ attributeSections @><- ->" ]
							<%
								startOffset = this.LookAheadToken.StartOffset;
								modifiers = Modifiers.None;
							%>
							[ "Modifiers<@ out modifiers @>" ]
							"StructureMemberDeclaration<@ classDeclaration, startOffset, attributeSections, modifiers @><- ->"
					<%
						}
						else {
							// Error recovery:  Advance to the next statement terminator since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ClassMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNextStatementTerminator();
						}
					}
					
					this.BlockEnd();
					this.AdvanceToNextEnd(VBTokenID.Class);
					classDeclaration.BlockEndOffset = this.Token.EndOffset;
					classDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapDocumentationComments();
					this.ReapComments(classDeclaration.Comments, false);
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ClassBase merged into ClassDeclaration -->
		<!-- NOTE: ClassMemberDeclaration merged into StructureMemberDeclaration, since they are the same -->
		<NonTerminal Key="StructureDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and StructureModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				'Structure'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to public access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Public;
				
					StructureDeclaration structureDeclaration = new StructureDeclaration(modifiers, identifier);
					structureDeclaration.Documentation = this.ReapDocumentationComments();
					structureDeclaration.StartOffset = startOffset;
					structureDeclaration.BlockStartOffset = startOffset;
					structureDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					AstNodeList typeParameterList = null;
					AstNodeList implementsList = null;
				%>
				[ "TypeParameterList<@ out typeParameterList @>" ]
				<%
					if (typeParameterList != null)
						structureDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
				%>
				"StatementTerminator<- ->"
				{ "TypeImplementsClause<@ out implementsList @><+
						if (implementsList != null)
							structureDeclaration.BaseTypes.AddRange(implementsList.ToArray());					
					+>" }
				<%
					int structureNestingLevel = nestingLevel;
					
					this.BlockStart(VBTokenID.Structure, structureDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if (this.IsEnd(VBTokenID.Structure))
							break;
						else if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
							// Skip over line terminators
							this.AdvancePastTerminators();
						}
						else if (IsNonTerminal("Attributes") || IsNonTerminal("Modifier") || IsNonTerminal("StructureMemberDeclaration")) {
							errorReported = false;
							attributeSections = new AstNodeList(null);
						%>
							[ "Attributes<@ attributeSections @><- ->" ]
							<%
								startOffset = this.LookAheadToken.StartOffset;
								modifiers = Modifiers.None;
							%>
							[ "Modifiers<@ out modifiers @>" ]
							"StructureMemberDeclaration<@ structureDeclaration, startOffset, attributeSections, modifiers @><- ->"
					<%
						}
						else {
							// Error recovery:  Advance to the next statement terminator since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StructureMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNextStatementTerminator();
						}
					}

					this.BlockEnd();
					this.AdvanceToNextEnd(VBTokenID.Structure);
					structureDeclaration.BlockEndOffset = this.Token.EndOffset;
					structureDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapDocumentationComments();
					this.ReapComments(structureDeclaration.Comments, false);
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="StructureMemberDeclaration" Parameters="TypeDeclaration parentTypeDeclaration, int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<Production><![CDATA[		
				<%
					// Build a list of generic type arguments for the parent type... will add to this collection if a generic method
					AstNodeList scopedGenericTypeArguments = new AstNodeList(null);
					if ((parentTypeDeclaration.GenericTypeArguments != null) && (parentTypeDeclaration.GenericTypeArguments.Count > 0))
						scopedGenericTypeArguments.AddRange(parentTypeDeclaration.GenericTypeArguments.ToArray());					
				%>			
			
				"NonModuleDeclaration<@ startOffset, attributeSections, modifiers @>"
				| (
					<!-- VariableMemberDeclaration -->
					<%
						FieldDeclaration fieldDeclaration = new FieldDeclaration(modifiers);
						fieldDeclaration.Documentation = this.ReapDocumentationComments();
						fieldDeclaration.StartOffset = startOffset;
						fieldDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					%>
					"VariableDeclarator<@ scopedGenericTypeArguments, fieldDeclaration @>"
					{ 'Comma' "VariableDeclarator<@ scopedGenericTypeArguments, fieldDeclaration @>" }
					<%
						fieldDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(fieldDeclaration);
						this.ReapDocumentationComments();						
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- ConstantMemberDeclaration -->
					'Const'
					<%
						FieldDeclaration constantDeclaration = new FieldDeclaration(modifiers);
						constantDeclaration.Documentation = this.ReapDocumentationComments();
						constantDeclaration.StartOffset = startOffset;
						constantDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					%>
					"ConstantDeclarator<@ constantDeclaration @>"
					{ 'Comma' "ConstantDeclarator<@ constantDeclaration @>" }
					<%
						constantDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(constantDeclaration);
						this.ReapDocumentationComments();						
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- RegularEventMemberDeclaration (via EventMemberDeclaration) -->
					'Event'
					<%
						QualifiedIdentifier identifier;
						AstNodeList parameterList = null;
						TypeReference typeReference = null;
						AstNodeList implementsList = null;
					%>
					"Identifier<@ out identifier @>"
					[ "ParametersOrType<@ scopedGenericTypeArguments, out parameterList, out typeReference @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>" ]
					[ "ImplementsClause<@ out implementsList @>" ]
					<%
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						EventDeclaration eventDeclaration = new EventDeclaration(modifiers, identifier);
						eventDeclaration.Documentation = this.ReapDocumentationComments();
						eventDeclaration.StartOffset = startOffset;
						eventDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						eventDeclaration.EventType = typeReference;
						if (parameterList != null)
							eventDeclaration.Parameters.AddRange(parameterList.ToArray());
						if (implementsList != null)
							eventDeclaration.ImplementedMembers.AddRange(implementsList.ToArray());
						eventDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(eventDeclaration);
						
						// Reap comments
						this.ReapDocumentationComments();
						this.ReapComments(eventDeclaration.Comments, false);
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- CustomEventMemberDeclaration -->
					'Custom'
					'Event'
					<%
						QualifiedIdentifier identifier;
						TypeReference typeReference;
						AstNodeList implementsList = null;
					%>
					"Identifier<@ out identifier @>"
					'As'
					"TypeName<@ out typeReference, false @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>"
					[ "ImplementsClause<@ out implementsList @>" ]
					<%
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						EventDeclaration eventDeclaration = new EventDeclaration(modifiers, identifier);
						eventDeclaration.Documentation = this.ReapDocumentationComments();
						eventDeclaration.StartOffset = startOffset;
						eventDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						eventDeclaration.EventType = typeReference;
						if (implementsList != null)
							eventDeclaration.ImplementedMembers.AddRange(implementsList.ToArray());
							
						attributeSections = new AstNodeList(null);
					%>
					"StatementTerminator"
					{ 
						[ "Attributes<@ attributeSections @><- ->" ]
						(
							<!-- AddHandlerDeclaration -->
							<%
								AstNodeList parameterList = null;					
								Statement block = null;
								
								AccessorDeclaration accessorDeclaration = new AccessorDeclaration();							
								accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
							%>
							'AddHandler'
							'OpenParenthesis'
							"ParameterList<@ scopedGenericTypeArguments, out parameterList @>"
							<%
								if (parameterList != null)
									accessorDeclaration.Parameters.AddRange(parameterList.ToArray());
							%>
							'CloseParenthesis'
							'LineTerminator'
							[ "Block<@ out block @>" ]
							<%
								this.AdvanceToNextEnd(VBTokenID.AddHandler);
								accessorDeclaration.BlockStatement = block as BlockStatement;
								accessorDeclaration.EndOffset = this.Token.EndOffset;
								eventDeclaration.AddAccessor = accessorDeclaration;
								this.ReapDocumentationComments();
							%>
						)
						| (
							<!-- RemoveHandlerDeclaration -->
							<%
								AstNodeList parameterList = null;					
								Statement block = null;
								
								AccessorDeclaration accessorDeclaration = new AccessorDeclaration();							
								accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
							%>
							'RemoveHandler'
							'OpenParenthesis'
							"ParameterList<@ scopedGenericTypeArguments, out parameterList @>"
							<%
								if (parameterList != null)
									accessorDeclaration.Parameters.AddRange(parameterList.ToArray());
							%>
							'CloseParenthesis'
							'LineTerminator'
							[ "Block<@ out block @>" ]
							<%
								this.AdvanceToNextEnd(VBTokenID.RemoveHandler);
								accessorDeclaration.BlockStatement = block as BlockStatement;
								accessorDeclaration.EndOffset = this.Token.EndOffset;
								eventDeclaration.RemoveAccessor = accessorDeclaration;
								this.ReapDocumentationComments();
							%>
						)
						| (
							<!-- RaiseEventDeclaration -->
							<%
								AstNodeList parameterList = null;					
								Statement block = null;
								
								AccessorDeclaration accessorDeclaration = new AccessorDeclaration();							
								accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
							%>
							'RaiseEvent'
							'OpenParenthesis'
							"ParameterList<@ scopedGenericTypeArguments, out parameterList @>"
							<%
								if (parameterList != null)
									accessorDeclaration.Parameters.AddRange(parameterList.ToArray());
							%>
							'CloseParenthesis'
							'LineTerminator'
							[ "Block<@ out block @>" ]
							<%
								this.AdvanceToNextEnd(VBTokenID.RaiseEvent);
								accessorDeclaration.BlockStatement = block as BlockStatement;
								accessorDeclaration.EndOffset = this.Token.EndOffset;
								eventDeclaration.RaiseEventAccessor = accessorDeclaration;
								this.ReapDocumentationComments();
							%>
						)
					}
					<%
						this.AdvanceToNextEnd(VBTokenID.Event);
						eventDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(eventDeclaration);
						
						// Reap comments
						this.ReapDocumentationComments();
						this.ReapComments(eventDeclaration.Comments, false);
					%>
				)
				| (
					<!-- ConstructorMemberDeclaration and SubDeclaration/MustOverrideSubDeclaration/FunctionDeclaration/MustOverrideFunctionDeclaration (via MethodMemberDeclaration/MethodDeclaration) -->
					<%
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						bool isFunction = false;
					%>
					(
						'Sub'
						| 'Function<+ isFunction = true; +>'
					)
					<%
						if ((!isFunction) && (this.TokenIs(this.LookAheadToken, VBTokenID.New))) {
					%>
							'New'
							<%
								ConstructorDeclaration constructorDeclaration = new ConstructorDeclaration(modifiers, null);
								constructorDeclaration.Documentation = this.ReapDocumentationComments();
								constructorDeclaration.StartOffset = startOffset;
								constructorDeclaration.BlockStartOffset = startOffset;
								constructorDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
								AstNodeList parameterList = null;
								Statement statement;
							%>
							[
								'OpenParenthesis'
								[ "ParameterList<@ scopedGenericTypeArguments, out parameterList @>" ]
								<%
									if (parameterList != null)
										constructorDeclaration.Parameters.AddRange(parameterList.ToArray());
								%>
								'CloseParenthesis'
							]
							'LineTerminator'
							"Block<@ out statement @><+ constructorDeclaration.Statements.Add(statement); +>"
							<%
								this.AdvanceToNextEnd(VBTokenID.Sub);
								constructorDeclaration.BlockEndOffset = this.Token.EndOffset;
								constructorDeclaration.EndOffset = this.Token.EndOffset;
								this.BlockAddChild(constructorDeclaration);
								
								// Reap comments
								this.ReapDocumentationComments();
								this.ReapComments(constructorDeclaration.Comments, false);
							%>
							"StatementTerminator<- ->"
					<%
						}
						else {
							QualifiedIdentifier name = null;
							AstNodeList typeParameterList = null;
							AstNodeList parameterList = null;
							TypeReference typeReference = null;
							AstNodeList implementsList = null;								
							bool isAbstract = ((modifiers & Modifiers.Abstract) == Modifiers.Abstract);
						%>
							[<? !isFunction ?> "SubSignature<@ scopedGenericTypeArguments, out name, out typeParameterList, out parameterList @>" ]
							[<? isFunction ?> "FunctionSignature<@ scopedGenericTypeArguments, out name, out typeParameterList, out parameterList, out typeReference @>" ]
							<%
								MethodDeclaration methodDeclaration = new MethodDeclaration(modifiers, name);
								methodDeclaration.Documentation = this.ReapDocumentationComments();
								methodDeclaration.StartOffset = startOffset;
								methodDeclaration.BlockStartOffset = startOffset;
								methodDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
								if (typeParameterList != null)
									methodDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
								if (parameterList != null)
									methodDeclaration.Parameters.AddRange(parameterList.ToArray());
								methodDeclaration.ReturnType = typeReference;
								
								// If an extension method...
								if (methodDeclaration.IsExtension) {
									// Ensure that the containing block is a static class declaration
									if ((parentTypeDeclaration != null) && (parentTypeDeclaration is ClassDeclaration) && 
										((((ClassDeclaration)parentTypeDeclaration).Modifiers & Modifiers.Static) == Modifiers.Static)) {
										// Add extension method attribute to parent type declaration 
										if (!parentTypeDeclaration.IsExtension) {
											AttributeSection attributeSection = new AttributeSection();
											attributeSection.Attributes.Add(new ActiproSoftware.SyntaxEditor.Addons.DotNet.Ast.Attribute(new TypeReference("System.Runtime.CompilerServices.Extension", TextRange.Deleted)));
											parentTypeDeclaration.AttributeSections.Add(attributeSection);														
										}
									}
								}								
							%>
							[ 
								(
									'Handles'
									"EventHandlesList<@ out implementsList @><- ->"
								)
								| "ImplementsClause<@ out implementsList @><- ->"
							]
							<%
								if (implementsList != null)
									methodDeclaration.ImplementedMembers.AddRange(implementsList.ToArray());
							%>
							[<? !isAbstract ?>
								<%
									Statement statement;
								%>
								'LineTerminator'
								"Block<@ out statement @><+ methodDeclaration.Statements.Add(statement); +>"
								'End'
								[<? !isFunction ?> 'Sub' ]
								[<? isFunction ?> 'Function' ]
							]
					<%
							methodDeclaration.BlockEndOffset = this.Token.EndOffset;
							methodDeclaration.EndOffset = this.Token.EndOffset;
							this.BlockAddChild(methodDeclaration);
						
							// Reap comments
							this.ReapDocumentationComments();
							this.ReapComments(methodDeclaration.Comments, false);
					%>				
							"StatementTerminator<- ->"
					<%
						}
					%>
				)
				| (
					<!-- MethodMemberDeclaration/ExternalMethodDeclaration start -->
					<%
						AstNodeList parameterList = null;					
						bool isFunction = false;
						QualifiedIdentifier name = null;
						TypeReference typeReference = new TypeReference("System.Object", TextRange.Deleted);
					%>
					'Declare'
					[ "CharsetModifier" ]
					(
						'Sub'
						| 'Function<+ isFunction = true; +>'
					)
					"Identifier<@ out name @>"
					"LibraryClause"
					[ "AliasClause" ]
					[
						'OpenParenthesis'
						[ "ParameterList<@ scopedGenericTypeArguments, out parameterList @>" ]
						'CloseParenthesis'
					]
					[<? (isFunction) && (this.TokenIs(this.LookAheadToken, VBTokenID.As)) ?>
						<%
							AstNodeList typeAttributeSections = new AstNodeList(null);
						%>
						'As'
						[ "Attributes<@ typeAttributeSections @>" ]
						"TypeName<@ out typeReference, false @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>"
						<%
							if (attributeSections != null)
								typeReference.AttributeSections.AddRange(attributeSections.ToArray());
						%>
					]
					<%
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						MethodDeclaration methodDeclaration = new MethodDeclaration(modifiers, name);
						methodDeclaration.Documentation = this.ReapDocumentationComments();
						methodDeclaration.StartOffset = startOffset;
						methodDeclaration.BlockStartOffset = startOffset;
						methodDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						if (parameterList != null)
							methodDeclaration.Parameters.AddRange(parameterList.ToArray());
						methodDeclaration.ReturnType = typeReference;
						methodDeclaration.BlockEndOffset = this.Token.EndOffset;
						methodDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(methodDeclaration);
					
						// Reap comments
						this.ReapDocumentationComments();
						this.ReapComments(methodDeclaration.Comments, false);
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- PropertySignature/RegularPropertyMemberDeclaration/MustOverridePropertyMemberDeclaration/AutoPropertyMemberDeclaration (via PropertyMemberDeclaration) -->
					<%
						QualifiedIdentifier name;
						AstNodeList typeParameterList;
						AstNodeList parameterList;
						TypeReference typeReference = new TypeReference("System.Object", TextRange.Deleted);				
						AstNodeList implementsList = null;								
						bool isAbstract = ((modifiers & Modifiers.Abstract) == Modifiers.Abstract);
						bool isNewExpression = false;
						Expression initializer = null;
					%>
					'Property'
					"SubSignature<@ scopedGenericTypeArguments, out name, out typeParameterList, out parameterList @>"
					[
						'As'
						<%
							AstNodeList typeRefAttributeSections = new AstNodeList(null);
						%>
						[ "Attributes<@ typeRefAttributeSections @><- ->" ]
						"NewExpression<@ out initializer @><+ isNewExpression = true; +>"
						| (
							"TypeName<@ out typeReference, false @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>"
							<%
								if (typeRefAttributeSections != null)
									typeReference.AttributeSections.AddRange(typeRefAttributeSections.ToArray());
							%>
						)
					]
					<%
						if (!isNewExpression) {
					%>
							[
								'Equality<- ->'
								"Expression<@ out initializer @>"								
							]
					<%
						}
						
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						PropertyDeclaration propertyDeclaration = new PropertyDeclaration(modifiers, name);
						propertyDeclaration.Documentation = this.ReapDocumentationComments();
						propertyDeclaration.StartOffset = startOffset;
						propertyDeclaration.BlockStartOffset = startOffset;
						propertyDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						if (parameterList != null)
							propertyDeclaration.Parameters.AddRange(parameterList.ToArray());
						propertyDeclaration.Initializer = initializer;
						propertyDeclaration.ReturnType = typeReference;
					%>
					[ "ImplementsClause<@ out implementsList @>" ]
					<%
						if (implementsList != null)
							propertyDeclaration.ImplementedMembers.AddRange(implementsList.ToArray());
					%>
					[<? !isAbstract ?>
						'LineTerminator'
						
						<%
							this.AdvancePastTerminators();
						
							if (this.TokenIs(this.LookAheadToken, new int[] { VBTokenID.Get, VBTokenID.Set })) {
								bool isGetAccessor = true;
								Statement block = null;
								Modifiers singleModifier;
								
								parameterList = null;												
								AccessorDeclaration accessorDeclaration = new AccessorDeclaration();							
								accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
							%>
							[ "Attributes<@ accessorDeclaration.AttributeSections @>" ]
							{ "Modifier<@ out singleModifier @><+ accessorDeclaration.Modifiers |= singleModifier; +>" }											
							(
								'Get<+ isGetAccessor = true; +>'
								| 'Set<+ isGetAccessor = false; +>'
							)
							[<? (!isGetAccessor) && (this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis)) ?>
								'OpenParenthesis'
								"ParameterList<@ scopedGenericTypeArguments, out parameterList @><- ->"
								<%
									if (parameterList != null)
										accessorDeclaration.Parameters.AddRange(parameterList.ToArray());
								%>
								'CloseParenthesis<- ->'
							]
							'LineTerminator<- ->'
							[ "Block<@ out block @>" ]
							<%
								this.AdvanceToNextEnd(isGetAccessor ? VBTokenID.Get : VBTokenID.Set);
								accessorDeclaration.BlockStatement = block as BlockStatement;
								accessorDeclaration.EndOffset = this.Token.EndOffset;
								if (isGetAccessor)
									propertyDeclaration.GetAccessor = accessorDeclaration;
								else
									propertyDeclaration.SetAccessor = accessorDeclaration;
									
								this.AdvancePastTerminators();
							%>
							
							[
								<%
									parameterList = null;												
									accessorDeclaration = new AccessorDeclaration();							
									accessorDeclaration.StartOffset = this.LookAheadToken.StartOffset;
								%>
								[ "Attributes<@ accessorDeclaration.AttributeSections @>" ]
								{ "Modifier<@ out singleModifier @><+ accessorDeclaration.Modifiers |= singleModifier; +>" }											
								(
									'Get<+ isGetAccessor = true; +>'
									| 'Set<+ isGetAccessor = false; +>'
								)
								[<? (!isGetAccessor) && (this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis)) ?>
									'OpenParenthesis'
									"ParameterList<@ scopedGenericTypeArguments, out parameterList @><- ->"
									<%
										if (parameterList != null)
											accessorDeclaration.Parameters.AddRange(parameterList.ToArray());
									%>
									'CloseParenthesis<- ->'
								]
								'LineTerminator<- ->'
								[ "Block<@ out block @>" ]
								<%
									this.AdvanceToNextEnd(isGetAccessor ? VBTokenID.Get : VBTokenID.Set);
									accessorDeclaration.BlockStatement = block as BlockStatement;
									accessorDeclaration.EndOffset = this.Token.EndOffset;
									if (isGetAccessor)
										propertyDeclaration.GetAccessor = accessorDeclaration;
									else
										propertyDeclaration.SetAccessor = accessorDeclaration;
										
									this.AdvancePastTerminators();
								%>
							]
							
							'End'
							'Property'
						<%
							}
						%>
					]
					<%
						propertyDeclaration.BlockEndOffset = this.Token.EndOffset;
						propertyDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(propertyDeclaration);
					
						// Reap comments
						this.ReapDocumentationComments();
						this.ReapComments(propertyDeclaration.Comments, false);
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- OperatorDeclaration -->
					<%
						OperatorType operatorType = OperatorType.None;
						ParameterDeclaration parameter1 = null;
						ParameterDeclaration parameter2 = null;
						TypeReference typeReference = new TypeReference("System.Object", TextRange.Deleted);
						Statement block;
						bool isAbstract = ((modifiers & Modifiers.Abstract) == Modifiers.Abstract);
					%>
					'Operator'
					(
						<!-- UnaryOperatorDeclaration / BinaryOperatorDeclaration -->
						<%
							bool requiresSingleOperand = false;
						%>
						(
							'Addition<+ operatorType = OperatorType.Addition; +>'
							| 'Subtraction<+ operatorType = OperatorType.Subtraction; +>'
							| 'Multiplication<+ operatorType = OperatorType.Multiply; +>'
							| 'FloatingPointDivision<+ operatorType = OperatorType.Division; +>'
							| 'IntegerDivision<+ operatorType = OperatorType.IntegerDivision; +>'
							| 'StringConcatenation<+ operatorType = OperatorType.StringConcatenation; +>'
							| 'Like<+ operatorType = OperatorType.Like; +>'
							| 'Mod<+ operatorType = OperatorType.Modulus; +>'
							| 'And<+ operatorType = OperatorType.ConditionalAnd; +>'
							| 'Or<+ operatorType = OperatorType.ConditionalOr; +>'
							| 'Xor<+ operatorType = OperatorType.ExclusiveOr; +>'
							| 'Exponentiation<+ operatorType = OperatorType.Exponentiation; +>'
							| 'LeftShift<+ operatorType = OperatorType.LeftShift; +>'
							| 'RightShift<+ operatorType = OperatorType.RightShift; +>'
							| 'Equality<+ operatorType = OperatorType.Equality; +>'
							| 'Inequality<+ operatorType = OperatorType.Inequality; +>'
							| 'GreaterThan<+ operatorType = OperatorType.GreaterThan; +>'
							| 'LessThan<+ operatorType = OperatorType.LessThan; +>'
							| 'GreaterThanOrEqual<+ operatorType = OperatorType.GreaterThanOrEqual; +>'
							| 'LessThanOrEqual<+ operatorType = OperatorType.LessThanOrEqual; +>'		
							| 'Not<+ operatorType = OperatorType.Negation; requiresSingleOperand = true; +>'
							| 'IsTrue<+ operatorType = OperatorType.True; requiresSingleOperand = true; +>'
							| 'IsFalse<+ operatorType = OperatorType.False; requiresSingleOperand = true; +>'
						)
						'OpenParenthesis'
						"Operand<@ out parameter1 @>"
						[ <? !requiresSingleOperand ?>
							'Comma'
							"Operand<@ out parameter2 @>"
						]
						'CloseParenthesis'
					)
					| (
						<!-- ConversionOperatorDeclaration -->
						'CType<+ operatorType = OperatorType.Explicit; +>'
						'OpenParenthesis'
						"Operand<@ out parameter1 @>"
						'CloseParenthesis'
					)
					<%
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						OperatorDeclaration operatorDeclaration = new OperatorDeclaration(modifiers, operatorType);
						operatorDeclaration.Documentation = this.ReapDocumentationComments();
						operatorDeclaration.StartOffset = startOffset;
						operatorDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						if (parameter1 != null)
							operatorDeclaration.Parameters.Add(parameter1);
						if (parameter2 != null)
							operatorDeclaration.Parameters.Add(parameter2);
					%>
					[<? !isAbstract ?>
						<%
							AstNodeList typeAttributeSections = new AstNodeList(null);
						%>
						'As'
						[ "Attributes<@ typeAttributeSections @>" ]
						"TypeName<@ out typeReference, false @><+ this.MarkGenericParameters(scopedGenericTypeArguments, typeReference, true); +>"
						<%
							if (attributeSections != null)
								typeReference.AttributeSections.AddRange(attributeSections.ToArray());
						%>
					]
					'LineTerminator'
					[ "Block<@ out block @><+ operatorDeclaration.Statements.Add(block); +>" ]
					<%
						this.AdvanceToNextEnd(VBTokenID.Operator);
						operatorDeclaration.BlockEndOffset = this.Token.EndOffset;
						operatorDeclaration.EndOffset = this.Token.EndOffset;
						this.BlockAddChild(operatorDeclaration);
					
						// Reap comments
						this.ReapDocumentationComments();
						this.ReapComments(operatorDeclaration.Comments, false);
					%>
				)
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ModuleDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<Production><![CDATA[
				'Module'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to internal access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Assembly;
				
					StandardModuleDeclaration moduleDeclaration = new StandardModuleDeclaration(modifiers, identifier);
					moduleDeclaration.Documentation = this.ReapDocumentationComments();
					moduleDeclaration.StartOffset = startOffset;
					moduleDeclaration.BlockStartOffset = startOffset;
					moduleDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
				%>
				"StatementTerminator<- ->"
				<%
					this.BlockStart(VBTokenID.Module, moduleDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if (this.IsEnd(VBTokenID.Module))
							break;
						else if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
							// Skip over line terminators
							this.AdvancePastTerminators();
						}
						else if (IsNonTerminal("Attributes") || IsNonTerminal("Modifier") || IsNonTerminal("StructureMemberDeclaration")) {
							errorReported = false;
							attributeSections = new AstNodeList(null);
						%>
							[ "Attributes<@ attributeSections @><- ->" ]
							<%
								startOffset = this.LookAheadToken.StartOffset;
								modifiers = Modifiers.None;
							%>
							[ "Modifiers<@ out modifiers @>" ]
							<%
								// Ensure all members are shared
								modifiers |= Modifiers.Static;
							%>
							"StructureMemberDeclaration<@ moduleDeclaration, startOffset, attributeSections, modifiers @><- ->"
					<%
						}
						else {
							// Error recovery:  Advance to the next statement terminator since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ModuleMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNextStatementTerminator();
						}
					}

					this.BlockEnd();
					this.AdvanceToNextEnd(VBTokenID.Module);
					moduleDeclaration.BlockEndOffset = this.Token.EndOffset;
					moduleDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapDocumentationComments();
					this.ReapComments(moduleDeclaration.Comments, false);
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ModuleMemberDeclaration merged into StructureMemberDeclaration, since they are the same other than structures allow operators -->
		<NonTerminal Key="InterfaceDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and InterfaceModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				'Interface'
				<%
					QualifiedIdentifier identifier;
				%>
				"Identifier<@ out identifier @>"
				<%
					// Default to public access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Public;
				
					InterfaceDeclaration interfaceDeclaration = new InterfaceDeclaration(modifiers, identifier);
					interfaceDeclaration.Documentation = this.ReapDocumentationComments();
					interfaceDeclaration.StartOffset = startOffset;
					interfaceDeclaration.BlockStartOffset = startOffset;
					interfaceDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					AstNodeList typeParameterList = null;
				%>
				[ "TypeParameterList<@ out typeParameterList @>" ]
				<%
					if (typeParameterList != null)
						interfaceDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
				%>
				"StatementTerminator<- ->"
				{ 
					<%
						AstNodeList implementsList;
					%>
					'Inherits'
					"Implements<@ out implementsList @>"
					"StatementTerminator<- ->"
					<%
						if (implementsList != null)
							interfaceDeclaration.BaseTypes.AddRange(implementsList.ToArray());
					%>
				}
				<%
					this.BlockStart(VBTokenID.Interface, interfaceDeclaration);
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if (this.IsEnd(VBTokenID.Interface))
							break;
						else if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
							// Skip over line terminators
							this.AdvancePastTerminators();
						}
						else if (IsNonTerminal("Attributes") || IsNonTerminal("Modifier") || IsNonTerminal("InterfaceMemberDeclaration")) {
							errorReported = false;
							attributeSections = new AstNodeList(null);
						%>
							[ "Attributes<@ attributeSections @><- ->" ]
							<%
								startOffset = this.LookAheadToken.StartOffset;
								modifiers = Modifiers.None;
							%>
							[ "Modifiers<@ out modifiers @>" ]
							"InterfaceMemberDeclaration<@ interfaceDeclaration, startOffset, attributeSections, modifiers @><- ->"
					<%
						}
						else {
							// Error recovery:  Advance to the next statement terminator since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_InterfaceMemberDeclarationExpected"));
								errorReported = true;
							}
							this.AdvanceToNextStatementTerminator(); 
						}
					}

					this.BlockEnd();
					this.AdvanceToNextEnd(VBTokenID.Interface);
					interfaceDeclaration.BlockEndOffset = this.Token.EndOffset;
					interfaceDeclaration.EndOffset = this.Token.EndOffset;
					
					// Reap comments
					this.ReapDocumentationComments();
					this.ReapComments(interfaceDeclaration.Comments, false);
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: InterfaceBase merged into InterfaceDeclaration -->
		<!-- NOTE: Implements used instead of InterfaceBases -->
		<NonTerminal Key="InterfaceMemberDeclaration" Parameters="TypeDeclaration parentTypeDeclaration, int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<Production><![CDATA[			
				<%
					// Build a list of generic type arguments for the parent type... will add to this collection if a generic method
					AstNodeList scopedGenericTypeArguments = new AstNodeList(null);
					if ((parentTypeDeclaration.GenericTypeArguments != null) && (parentTypeDeclaration.GenericTypeArguments.Count > 0))
						scopedGenericTypeArguments.AddRange(parentTypeDeclaration.GenericTypeArguments.ToArray());					
						
					QualifiedIdentifier identifier;
					AstNodeList typeParameterList;
					AstNodeList parameterList = null;
					TypeReference typeReference = null;
				%>
				"NonModuleDeclaration<@ startOffset, attributeSections, modifiers @>"
				| (
					'Event'
					"Identifier<@ out identifier @>"
					[ "ParametersOrType<@ scopedGenericTypeArguments, out parameterList, out typeReference @>" ]
					<%
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						InterfaceEventDeclaration eventDeclaration = new InterfaceEventDeclaration(modifiers, identifier);
						eventDeclaration.Documentation = this.ReapDocumentationComments();
						eventDeclaration.StartOffset = startOffset;
						eventDeclaration.EndOffset = this.Token.EndOffset;
						eventDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						eventDeclaration.EventType = typeReference;
						if (parameterList != null)
							eventDeclaration.Parameters.AddRange(parameterList.ToArray());
						this.BlockAddChild(eventDeclaration);
					%>
					"StatementTerminator<- ->"
				)
				| (
					(
						'Sub'
						"SubSignature<@ scopedGenericTypeArguments, out identifier, out typeParameterList, out parameterList @>"
					)
					| (
						'Function'
						"FunctionSignature<@ scopedGenericTypeArguments, out identifier, out typeParameterList, out parameterList, out typeReference @>"
					)
					<% 
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						InterfaceMethodDeclaration methodDeclaration = new InterfaceMethodDeclaration(modifiers, identifier);
						methodDeclaration.Documentation = this.ReapDocumentationComments();
						methodDeclaration.StartOffset = startOffset;
						methodDeclaration.EndOffset = this.Token.EndOffset;
						methodDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						methodDeclaration.ReturnType = typeReference;
						if (typeParameterList != null)
							methodDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
						if (parameterList != null)
							methodDeclaration.Parameters.AddRange(parameterList.ToArray());
						this.BlockAddChild(methodDeclaration);
					%>
					"StatementTerminator<- ->"
				)
				| (
					'Property'
					"FunctionSignature<@ scopedGenericTypeArguments, out identifier, out typeParameterList, out parameterList, out typeReference @>"
					<% 
						// Default to public access
						if (!AstNode.IsAccessSpecified(modifiers))
							modifiers |= Modifiers.Public;
					
						InterfacePropertyDeclaration propertyDeclaration = new InterfacePropertyDeclaration(modifiers, identifier);
						propertyDeclaration.Documentation = this.ReapDocumentationComments();
						propertyDeclaration.StartOffset = startOffset;
						propertyDeclaration.EndOffset = this.Token.EndOffset;
						propertyDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
						propertyDeclaration.ReturnType = typeReference;
						if (parameterList != null)
							propertyDeclaration.Parameters.AddRange(parameterList.ToArray());
						this.BlockAddChild(propertyDeclaration);
					%>
					"StatementTerminator<- ->"
				)
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ArrayTypeName merged into TypeName -->
		<!-- NOTE: ArrayTypeModifiers merged into callers of ArrayTypeModifier -->
		<NonTerminal Key="ArrayTypeModifier" Parameters="out int[] ranks">
			<Production><![CDATA[
				<%
					ranks = null;
					ArrayList rankList = new ArrayList();
					int rank = 0;
				%>
				{
					'OpenParenthesis<+ rank = 1; +>'
					{ 'Comma<+ rank++; +>' }
					'CloseParenthesis<+ rankList.Add(rank); +>'
				}
				<%
					if (rankList.Count > 0) {
						ranks = new int[rankList.Count];
						rankList.CopyTo(ranks, 0);
					}
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: RankList merged into callers -->
		<!-- NOTE: ArrayNameModifier merged into callers -->
		<NonTerminal Key="DelegateDeclaration" Parameters="int startOffset, AstNodeList attributeSections, Modifiers modifiers">
			<!-- NOTE: Attributes and ClassModifier (alias Modifier) moved to callers of TypeDeclaration to reduce ambiguity -->
			<Production><![CDATA[
				<%
					QualifiedIdentifier identifier = null;
					AstNodeList typeParameterList = null;
					AstNodeList parameterList = null;
					TypeReference typeReference = null;
					bool isFunction = false;
					AstNodeList scopedGenericTypeArguments = new AstNodeList(null);					
				%>
				'Delegate'
				(
					'Sub'
					| 'Function<+ isFunction = true; +>'
				)
				[<? !isFunction ?> "SubSignature<@ scopedGenericTypeArguments, out identifier, out typeParameterList, out parameterList @>" ]
				[<? isFunction ?> "FunctionSignature<@ scopedGenericTypeArguments, out identifier, out typeParameterList, out parameterList, out typeReference @>" ]
				<%
					// Default to public access
					if (!AstNode.IsAccessSpecified(modifiers))
						modifiers |= Modifiers.Public;
				
					DelegateDeclaration delegateDeclaration = new DelegateDeclaration(modifiers, identifier);
					delegateDeclaration.Documentation = this.ReapDocumentationComments();
					delegateDeclaration.StartOffset = startOffset;
					delegateDeclaration.AttributeSections.AddRange(attributeSections.ToArray());
					if (typeParameterList != null)
						delegateDeclaration.GenericTypeArguments.AddRange(typeParameterList.ToArray());					
					if (parameterList != null)
						delegateDeclaration.Parameters.AddRange(parameterList.ToArray());
					delegateDeclaration.ReturnType = typeReference;
					delegateDeclaration.EndOffset = this.Token.EndOffset;
					this.BlockAddChild(delegateDeclaration);					
					delegateDeclaration.GenerateInvokeMembers();
					
					// Reap comments
					this.ReapDocumentationComments();
					this.ReapComments(delegateDeclaration.Comments, false);
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: MethodSignature merged into DelegateDeclaration -->
		<!-- NOTE: ConstructedTypeName merged into callers -->
		<NonTerminal Key="TypeArgumentList" Parameters="out AstNodeList typeArgumentList">
			<Production><![CDATA[
				<%
					typeArgumentList = new AstNodeList(null);
					TypeReference typeReference;
				%>
				"TypeName<@ out typeReference, false @><+ typeArgumentList.Add(typeReference); +>"
				{
					'Comma' 
					"TypeName<@ out typeReference, false @><+ typeArgumentList.Add(typeReference); +>"					
				}
			]]></Production>
		</NonTerminal>
		
		<!-- 13.3.4 Type Members -->
		<NonTerminal Key="ImplementsClause" Parameters="out AstNodeList implementsList">
			<Production><![CDATA[
				<%
					implementsList = new AstNodeList(null);
					MemberSpecifier memberSpecifier;
				%>
				'Implements'
				"InterfaceMemberSpecifier<@ out memberSpecifier @><+ implementsList.Add(memberSpecifier); +>"				
				{
					'Comma'
					"InterfaceMemberSpecifier<@ out memberSpecifier @><+ implementsList.Add(memberSpecifier); +>"					
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ImplementsList merged into ImplementsClause -->
		<NonTerminal Key="InterfaceMemberSpecifier" Parameters="out MemberSpecifier memberSpecifier">
			<Production><![CDATA[
				<%
					memberSpecifier = null;
					TypeReference typeReference;
					QualifiedIdentifier memberName;
					bool isIdentifier = this.IsIdentifier(this.LookAheadToken);
				%>
				"NonArrayTypeName<@ out typeReference, false @>"
				<%
					bool requiresIdentifier = !isIdentifier;
					if (!requiresIdentifier) {
						requiresIdentifier = (typeReference.GenericTypeArguments.Count > 0);
						if (!requiresIdentifier)
							requiresIdentifier = (typeReference.Name.IndexOf('.') == -1);							
					}
					if (!requiresIdentifier) {
						// Remove the last part of the qualified identifier and use that as the member name
						int index = typeReference.Name.LastIndexOf('.');
						memberName = new QualifiedIdentifier(typeReference.Name.Substring(index + 1));
						typeReference.Name = typeReference.Name.Substring(0, index);
						memberName.StartOffset = typeReference.EndOffset - memberName.Text.Length;
						memberName.EndOffset = typeReference.EndOffset;
						typeReference.EndOffset -= (memberName.Text.Length + 1);
						memberSpecifier = new MemberSpecifier(typeReference, memberName);
						return true;
					}
				%>
				'Dot'
				"IdentifierOrKeyword<@ out memberName @><+ memberSpecifier = new MemberSpecifier(typeReference, memberName); +>"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: MethodMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: InterfaceMethodMemberDeclaration merged into InterfaceMemberDeclaration -->
		<!-- NOTE: MethodDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: InterfaceMethodDeclaration merged into InterfaceMemberDeclaration -->
		<NonTerminal Key="SubSignature" Parameters="IAstNodeList genericTypeArguments, out QualifiedIdentifier identifier, out AstNodeList typeParameterList, out AstNodeList parameterList">
			<Production><![CDATA[
				<%
					identifier = null;
					typeParameterList = null;					
					parameterList = null;					
				%>
				"Identifier<@ out identifier @>"
				[ "TypeParameterList<@ out typeParameterList @><- -><+
					// Add to the scoped generic type arguments
					if ((typeParameterList != null) && (typeParameterList.Count > 0)) 
						genericTypeArguments.AddRange(typeParameterList.ToArray());	
					+>" ]
				[
					'OpenParenthesis'
					[ "ParameterList<@ genericTypeArguments, out parameterList @><- ->" ]
					'CloseParenthesis<- ->'
				]
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="FunctionSignature" Parameters="IAstNodeList genericTypeArguments, out QualifiedIdentifier identifier, out AstNodeList typeParameterList, out AstNodeList parameterList, out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = new TypeReference("System.Object", TextRange.Deleted);
				%>
				"SubSignature<@ genericTypeArguments, out identifier, out typeParameterList, out parameterList @>"
				[
					'As'
					<%
						AstNodeList attributeSections = new AstNodeList(null);
					%>
					[ "Attributes<@ attributeSections @><- ->" ]
					"TypeName<@ out typeReference, false @><+ this.MarkGenericParameters(genericTypeArguments, typeReference, true); +>"
					<%
						if (attributeSections != null)
							typeReference.AttributeSections.AddRange(attributeSections.ToArray());
					%>
				]
			]]></Production>
		</NonTerminal>
		<!-- NOTE: SubDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: MustOverrideSubDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: InterfaceSubDeclaration merged into InterfaceMemberDeclaration -->
		<!-- NOTE: FunctionDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: MustOverrideFunctionDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: InterfaceFunctionDeclaration merged into InterfaceMemberDeclaration -->
		<!-- NOTE: ProcedureModifier merged into Modifiers -->
		<!-- NOTE: MustOverrideProcedureModifier merged into Modifiers -->
		<!-- NOTE: InterfaceProcedureModifier merged into Modifiers -->
		<!-- NOTE: HandlesOrImplements merged into StructureMemberDeclaration -->
		<!-- NOTE: ExternalMethodDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: ExternalSubDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: ExternalFunctionDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: ExternalMethodModifier merged into Modifiers -->		
		<NonTerminal Key="CharsetModifier">
			<Production><![CDATA[
				"SimpleIdentifier"
				<!-- Must be 'Ansi' | 'Unicode' | 'Auto' -->
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="LibraryClause">
			<Production><![CDATA[
				'Lib'
				'StringLiteral'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="AliasClause">
			<Production><![CDATA[
				'Alias'
				'StringLiteral'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ParameterList" Parameters="IAstNodeList genericTypeArguments, out AstNodeList parameterList">
			<Production><![CDATA[
				<%
					parameterList = new AstNodeList(null);
					ParameterDeclaration parameter;
				%>
				"Parameter<@ genericTypeArguments, out parameter @><+ parameterList.Add(parameter); +>"
				{ 'Comma' "Parameter<@ genericTypeArguments, out parameter @><+ parameterList.Add(parameter); +>" }
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Parameter" Parameters="IAstNodeList genericTypeArguments, out ParameterDeclaration parameter">
			<Production><![CDATA[
				<%
					parameter = null;
					int startOffset = this.LookAheadToken.StartOffset;
					AstNodeList attributeSections = new AstNodeList(null);
					ParameterModifiers modifiers = ParameterModifiers.None;
					TypeReference typeReference = new TypeReference("System.Object", TextRange.Deleted);
					Expression initializer = null;
				%>
				[ "Attributes<@ attributeSections @><- ->" ]
				{ 
					'ByVal'
					| 'ByRef<+ modifiers |= ParameterModifiers.Ref; +>'
					| 'Optional<+ modifiers |= ParameterModifiers.Optional; +>'
					| 'ParamArray<+ modifiers |= ParameterModifiers.ParameterArray; +>'
				}
				<%
					string name;
					int[] arrayRanks;
				%>
				"SimpleIdentifier<+ name = this.TokenText; +>"
				[ <? this.TokenIs(this.LookAheadToken, new int[] { VBTokenID.QuestionMark, VBTokenID.OpenParenthesis }) ?>
					(
						'QuestionMark'
					)
					|<? this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis) ?> (
						<%
							bool isArrayTypeModifier = false;
						%>
						{<? this.IsArrayTypeModifier() ?> "ArrayTypeModifier<@ out arrayRanks @><+ isArrayTypeModifier = true; +>" }
						[<? !isArrayTypeModifier ?> "ArraySizeInitializationModifier<@ out arrayRanks @>" ]					
					)
				]
				[
					'As'
					"TypeName<@ out typeReference, false @><+ this.MarkGenericParameters(genericTypeArguments, typeReference, true); +>"
				]
				[
					'Equality'
					"Expression<@ out initializer @><- ->"
				]
				<%
					parameter = new ParameterDeclaration(modifiers, name);
					parameter.StartOffset = startOffset;
					parameter.EndOffset = this.Token.EndOffset;
					parameter.AttributeSections.AddRange(attributeSections.ToArray());
					parameter.ParameterType = typeReference;
					parameter.Initializer = initializer;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ParameterModifier merged into Parameter -->		
		<!-- NOTE: ParameterIdentifier merged into Parameter -->		
		<!-- NOTE: HandlesClause merged into StructureMemberDeclaration -->
		<NonTerminal Key="EventHandlesList" Parameters="out AstNodeList handlesList">
			<Production><![CDATA[
				<%
					handlesList = new AstNodeList(null);
					EventMemberSpecifier memberSpecifier;
				%>
				"EventMemberSpecifier<@ out memberSpecifier @><+ handlesList.Add(memberSpecifier); +>"				
				{
					'Comma'
					"EventMemberSpecifier<@ out memberSpecifier @><+ handlesList.Add(memberSpecifier); +>"					
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="EventMemberSpecifier" Parameters="out EventMemberSpecifier memberSpecifier">
			<Production><![CDATA[
				<%
					memberSpecifier = null;
					QualifiedIdentifier target;
					QualifiedIdentifier memberName = null;
				%>
				(	
					"QualifiedIdentifier<@ out target @>"
					<%
						int index = target.Text.LastIndexOf('.');
						if (index != -1) {
							int length = target.Text.Length - index;
							memberName = new QualifiedIdentifier(target.Text.Substring(index + 1), new TextRange(target.EndOffset - length, target.EndOffset));
							target.Text = target.Text.Substring(0, index);
							target.EndOffset -= length;
						}							
					%>
				)
				| ( 'MyBase<+ target = new QualifiedIdentifier(this.TokenText, this.Token.TextRange); +>' 'Dot' "Identifier<@ out memberName @>" )
				| ( 'Me<+ target = new QualifiedIdentifier(this.TokenText, this.Token.TextRange); +>' 'Dot' "Identifier<@ out memberName @>" )
				<%
					memberSpecifier = new EventMemberSpecifier(target, memberName);
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ConstructorMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: ConstructorModifier merged into Modifiers -->
		<!-- NOTE: EventMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: RegularEventMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: InterfaceEventMemberDeclaration merged into InterfaceMemberDeclaration -->
		<NonTerminal Key="ParametersOrType" Parameters="IAstNodeList genericTypeArguments, out AstNodeList parameterList, out TypeReference typeReference">
			<Production><![CDATA[
				<%
					parameterList = null;
					typeReference = new TypeReference("System.Object", TextRange.Deleted);
				%>
				(
					'OpenParenthesis'
					[ "ParameterList<@ genericTypeArguments, out parameterList @>" ]
					'CloseParenthesis'
				)
				| (
					'As'
					"NonArrayTypeName<@ out typeReference, false @>"
				)
			]]></Production>
		</NonTerminal>
		<!-- NOTE: EventModifier merged into Modifiers -->
		<!-- NOTE: InterfaceEventModifier merged into Modifiers -->
		<!-- NOTE: CustomEventMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: EventAccessorDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: AddHandlerDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: RemoveHandlerDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: RaiseEventDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: ConstantMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: ConstantModifier merged into Modifiers -->
		<!-- NOTE: ConstantDeclarators merged into StructureMemberDeclaration -->
		<NonTerminal Key="ConstantDeclarator" Parameters="FieldDeclaration constantDeclaration">
			<Production><![CDATA[
				<%
					QualifiedIdentifier identifier;
					TypeReference typeReference = new TypeReference("System.Object", TextRange.Deleted);
					Expression initializer;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				"Identifier<@ out identifier @>"
				[
					'As'
					"TypeName<@ out typeReference, false @>"
				]
				'Equality'
				"Expression<@ out initializer @>"
				<%
					VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, identifier, true, false);
					variableDeclarator.Initializer = initializer;
					variableDeclarator.StartOffset = startOffset;
					variableDeclarator.EndOffset = this.Token.EndOffset;
					constantDeclaration.Variables.Add(variableDeclarator);
				%>
				"StatementTerminator<- ->"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: VariableMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: VariableModifier merged into Modifiers -->
		<!-- NOTE: VariableDeclarators merged into StructureMemberDeclaration -->
		<NonTerminal Key="VariableDeclarator" Parameters="IAstNodeList genericTypeArguments, IVariableDeclarationSection declaration">
			<Production><![CDATA[
				<%
					QualifiedIdentifier identifier;
					int[] arrayRanks = null;
					AstNodeList identifierList = new AstNodeList(null);
					TypeReference typeReference = new TypeReference("System.Object", TextRange.Deleted);
					Expression initializer = null;
					int startOffset = this.LookAheadToken.StartOffset;
					bool isNewExpression = false;
				%>
				"VariableIdentifier<@ out identifier, out arrayRanks @><+ identifierList.Add(identifier); +>"
				{ 
					'Comma' 
					"VariableIdentifier<@ out identifier, out arrayRanks @><+ identifierList.Add(identifier); +>"
				}
				[
					'As'
					(
						"ObjectCreationExpression<@ out initializer @><+ isNewExpression = true; +>"
						| "TypeName<@ out typeReference, false @><+ this.MarkGenericParameters(genericTypeArguments, typeReference, true); +>"
					)
				]
				[<? (!isNewExpression) && (this.TokenIs(this.LookAheadToken, VBTokenID.Equality)) ?>
					'Equality'
					"Expression<@ out initializer @>"
				]
				<%
					for (int index = 0; index < identifierList.Count; index++) {	
						bool isImplicitlyTyped = false;
						if ((initializer != null) && ((typeReference == null) || 
							((!typeReference.HasStartOffset) && (typeReference.Name == "System.Object")))) {
							
							// If in an implicitly typed declaration, try and locate the type reference
							isImplicitlyTyped = true;
							TypeReference implicitTypeReference = this.GetImplicitType(initializer, false);
							if (implicitTypeReference != null)
								typeReference = implicitTypeReference;
						}
						else if (typeReference != null)
							typeReference.ArrayRanks = arrayRanks;
					
						VariableDeclarator variableDeclarator = new VariableDeclarator(typeReference, (QualifiedIdentifier)identifierList[index], false, false);
						variableDeclarator.Initializer = initializer;
						variableDeclarator.IsImplicitlyTyped = isImplicitlyTyped;
						variableDeclarator.StartOffset = startOffset;
						variableDeclarator.EndOffset = this.Token.EndOffset;
						declaration.Variables.Add(variableDeclarator);
					}
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: VariableIdentifiers merged into VariableDeclarator -->
		<NonTerminal Key="VariableIdentifier" Parameters="out QualifiedIdentifier identifier, out int[] arrayRanks">
			<Production><![CDATA[
				<%
					arrayRanks = null;
				%>
				"Identifier<@ out identifier @>"
				[<? (this.TokenIs(this.LookAheadToken, VBTokenID.QuestionMark)) || (this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis)) ?>
					'QuestionMark'
					|<? this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis) ?> (
						<%
							bool isArrayTypeModifier = false;
						%>
						{<? this.IsArrayTypeModifier() ?> "ArrayTypeModifier<@ out arrayRanks @><+ isArrayTypeModifier = true; +>" }
						[<? !isArrayTypeModifier ?> "ArraySizeInitializationModifier<@ out arrayRanks @>" ]					
					)
				]
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ArraySizeInitializationModifier" Parameters="out int[] arrayRanks">
			<Production><![CDATA[
				<%
					arrayRanks = null;
					// NOTE: Expressions are ignored until further implementation
				%>
				{<? this.IsArrayTypeModifier() ?> "ArrayTypeModifier<@ out arrayRanks @><+ return true; +>" }
				'OpenParenthesis'
				<%
					Expression expression;
					if (this.AreNextTwo(VBTokenID.DecimalIntegerLiteral, VBTokenID.To)) {
				%>
						'DecimalIntegerLiteral'
						'To'
						"Expression<@ out expression @>"
				<%
					}
					else {
				%>
						"Expression<@ out expression @>"
						{
							'Comma'
							"Expression<@ out expression @>"
						}
				<%
					}
				%>
				'CloseParenthesis'
				{<? this.IsArrayTypeModifier() ?> "ArrayTypeModifier<@ out arrayRanks @>" }
			]]></Production>
		</NonTerminal>
		<!-- NOTE: BoundList merged into ArraySizeInitializationModifier -->
		<!-- NOTE: PropertyMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: RegularPropertyMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: MustOverridePropertyMemberDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: InterfacePropertyMemberDeclaration merged into InterfaceMemberDeclaration -->
		<!-- NOTE: PropertyModifier merged into Modifiers -->
		<!-- NOTE: MustOverridePropertyModifier merged into Modifiers -->
		<!-- NOTE: InterfacePropertyModifier merged into Modifiers -->
		<!-- NOTE: PropertyAccessorDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: PropertyGetDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: PropertySetDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: OperatorDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: OperatorModifier merged into Modifiers -->
		<NonTerminal Key="Operand" Parameters="out ParameterDeclaration parameter">
			<Production><![CDATA[
				<%
					parameter = null;
					TypeReference parameterTypeReference = new TypeReference("System.Object", TextRange.Deleted);
					string name = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>					
				[ 'ByVal' ]
				"SimpleIdentifier<+ name = this.TokenText; +>"
				[
					'As'
					"TypeName<@ out parameterTypeReference, false @>"
				]
				<%
					parameter = new ParameterDeclaration(ParameterModifiers.None, name);
					parameter.StartOffset = startOffset;
					parameter.EndOffset = this.Token.EndOffset;
					parameter.ParameterType = parameterTypeReference;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: UnaryOperatorDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: OverloadableUnaryOperator merged into StructureMemberDeclaration -->
		<!-- NOTE: BinaryOperatorDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: OverloadableBinaryOperator merged into StructureMemberDeclaration -->
		<!-- NOTE: ConversionOperatorDeclaration merged into StructureMemberDeclaration -->
		<!-- NOTE: ConversionOperatorDeclaration merged into Modifiers -->
			
		<!-- 13.3.5 Statements -->
		<NonTerminal Key="Statement" Parameters="out Statement statement">
			<AdditionalConditions>
				<ExpressionCondition>this.IsEndStatement()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					statement = null;

					// Skip over line terminators
					this.AdvancePastTerminators();
					
					int startOffset = this.LookAheadToken.StartOffset;
					
					if (this.IsEndStatement()) {
						// Process 'End' statements separately because their conditions conflict with normal End statements 
						this.Match(VBTokenID.End);
						this.MatchStatementTerminator();
						statement = new BranchStatement(BranchStatementType.End, new TextRange(startOffset, this.Token.EndOffset));
						return true;
					}
					
				%>
				(
					<%
						Expression expression;
					%>
					"LabelName<@ out expression @>"
					'Colon'
					<%
						statement = new LabeledStatement(expression, new EmptyStatement(new TextRange(this.Token.EndOffset)), new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<%
						Modifiers modifier = Modifiers.None;
						statement = new LocalVariableDeclaration();
						statement.StartOffset = this.LookAheadToken.StartOffset;
					%>
					(
						'Dim <+ modifier = Modifiers.Dim; +><- ->'
						| 'Static <+ modifier = Modifiers.Static; +><- ->'
						| 'Const <+ modifier = Modifiers.Default; +><- ->'
					)					
					<%
						((LocalVariableDeclaration)statement).Modifiers = modifier;
					%>
					"VariableDeclarator<@ null, (LocalVariableDeclaration)statement @>"
					{ 'Comma' "VariableDeclarator<@ null, (LocalVariableDeclaration)statement @>" }
					<%
						statement.EndOffset = this.Token.EndOffset;
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- WithStatement -->
					<%
						Expression expression;
						Statement embeddedStatement = null;
					%>
					'With'
					"Expression<@ out expression @><- this.AdvanceToNextEnd(VBTokenID.With, true); return false; ->"
					"StatementTerminator<- ->"
					[ "Block<@ out embeddedStatement @><- this.AdvanceToNextEnd(VBTokenID.With, true); return false; ->" ]
					<%
						this.AdvanceToNextEnd(VBTokenID.With, true);
						statement = new WithStatement(expression, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- SyncLockStatement -->
					<%
						Expression expression;
						Statement embeddedStatement = null;
					%>
					'SyncLock'
					"Expression<@ out expression @><- this.AdvanceToNextEnd(VBTokenID.SyncLock, true); return false; ->"
					"StatementTerminator<- ->"
					[ "Block<@ out embeddedStatement @><- this.AdvanceToNextEnd(VBTokenID.SyncLock, true); return false; ->" ]
					<%
						this.AdvanceToNextEnd(VBTokenID.SyncLock, true);
						statement = new LockStatement(expression, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- RaiseEventStatement via EventStatement -->
					<%
						QualifiedIdentifier identifier;
						AstNodeList argumentList = null;
					%>
					'RaiseEvent'
					"IdentifierOrKeyword<@ out identifier @>"
					[
						'OpenParenthesis'
						[ "ArgumentList<@ out argumentList @>" ]
						'CloseParenthesis'
					]
					<%
						statement = new RaiseEventStatement(identifier, argumentList, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- AddHandlerStatement via EventStatement -->
					<%
						Expression @event;
						Expression eventHandler;
					%>
					'AddHandler'
					"Expression<@ out @event @>"
					'Comma'
					"Expression<@ out eventHandler @>"
					<%
						statement = new ModifyEventHandlerStatement(ModifyEventHandlerStatementType.Add, @event, eventHandler, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- RemoveHandlerStatement via EventStatement -->
					<%
						Expression @event;
						Expression eventHandler;
					%>
					'RemoveHandler'
					"Expression<@ out @event @>"
					'Comma'
					"Expression<@ out eventHandler @>"
					<%
						statement = new ModifyEventHandlerStatement(ModifyEventHandlerStatementType.Remove, @event, eventHandler, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| <? this.AreNextTwo(VBTokenID.Mid, VBTokenID.OpenParenthesis ) ?> (
					<!-- MidAssignmentStatement -->
					<%
						Expression leftExpression, startIndexExpression, lengthExpression = null, rightExpression;
					%>
					'Mid'
					<!-- NOTE: Should allow $ -->
					'OpenParenthesis'
					"Expression<@ out leftExpression @>"
					'Comma'
					"Expression<@ out startIndexExpression @>"
					[
						'Comma'
						"Expression<@ out lengthExpression @>"
					]
					'CloseParenthesis'
					'Equality'
					"Expression<@ out rightExpression @>"
					<%
						AssignmentExpression assignmentExpression = new AssignmentExpression(OperatorType.Mid, leftExpression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
						assignmentExpression.StartIndexExpression = startIndexExpression;
						assignmentExpression.LengthExpression = lengthExpression;
						statement = new StatementExpression(assignmentExpression);						
					%>					
					"StatementTerminator<- ->"
				)
				| (
					<!-- RegularAssignmentStatement / CompoundAssignmentStatement / InvocationStatement (handled partly in PrimaryExpression) -->
					<%
						Expression leftExpression, rightExpression;
						OperatorType operatorType = OperatorType.None;
					%>
					[ 'Call' ]
					"PrimaryExpression<@ true, out leftExpression @>"
					(
						(
							'Equality'
							| 'AdditionAssignment<+ operatorType = OperatorType.Addition; +>'
							| 'SubtractionAssignment<+ operatorType = OperatorType.Subtraction; +>'
							| 'MultiplicationAssignment<+ operatorType = OperatorType.Multiply; +>'
							| 'FloatingPointDivisionAssignment<+ operatorType = OperatorType.Division; +>'
							| 'IntegerDivisionAssignment<+ operatorType = OperatorType.IntegerDivision; +>'
							| 'StringConcatenationAssignment<+ operatorType = OperatorType.StringConcatenation; +>'
							| 'ExponentiationAssignment<+ operatorType = OperatorType.Exponentiation; +>'
							| 'LeftShiftAssignment<+ operatorType = OperatorType.LeftShift; +>'
							| 'RightShiftAssignment<+ operatorType = OperatorType.RightShift; +>'
						)
						[ 'LineTerminator<- ->' ]
						"Expression<@ out rightExpression @><- 
							this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_ExpressionExpected"));
							->"
						<%
							statement = new StatementExpression(new AssignmentExpression(operatorType, leftExpression, rightExpression, new TextRange(startOffset, this.Token.EndOffset)));
						%>
						"StatementTerminator<- ->"
					)
					| <? leftExpression is InvocationExpression ?> (
						<%
							// InvocationStatement
							statement = new StatementExpression(leftExpression, new TextRange(startOffset, this.Token.EndOffset));
						%>
					) 
					| <? true ?> (
						<%
							// Error recovery: Go to the next statement terminator
							this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
							return false;
						%>
					)					
				)
				| (
					<!-- BlockIfStatement/LineIfThenStatement via ConditionalStatement/IfStatement -->
					<%
						Expression condition;
						Statement trueStatement = null;
						Statement falseStatement = null;
						AstNodeList elseIfSections = new AstNodeList(null);
						bool hasThen = false;
					%>
					'If'
					"Expression<@ out condition @><- this.AdvanceToNextEnd(VBTokenID.If, true); return false; ->"
					[ 'Then<+ hasThen = true; +>' ]
					<%
						if (hasThen) {
					%>
							[
								"Statements<@ out trueStatement @>"
								[ 'Else' "Statements<@ out falseStatement @>" ]
								<%
									statement = new IfStatement(condition, trueStatement, falseStatement, new TextRange(startOffset, this.Token.EndOffset));
									return true;
								%>
							]
					<%
						}
					%>
					"StatementTerminator<- ->"
					[ "Block<@ out trueStatement @><- this.AdvanceToNextEnd(VBTokenID.If, true); return false; ->" ]
					{<? (this.TokenIs(this.LookAheadToken, VBTokenID.ElseIf)) || (this.AreNextTwo(VBTokenID.Else, VBTokenID.If)) ?>
						<%
							Expression elseIfCondition;
							Statement elseIfStatement = null;
							int elseIfStartOffset = this.LookAheadToken.StartOffset;
						%>
						(
							'ElseIf'
							| ( 'Else' 'If' )
						)
						"Expression<@ out elseIfCondition @><- this.AdvanceToNextEnd(VBTokenID.If, true); return false; ->"
						[ 'Then' ]
						"StatementTerminator<- ->"
						[ "Block<@ out elseIfStatement @><- this.AdvanceToNextEnd(VBTokenID.If, true); return false; ->" ]
						<%
							elseIfSections.Add(new ElseIfSection(elseIfCondition, elseIfStatement, new TextRange(elseIfStartOffset, this.Token.EndOffset)));
						%>
					}
					[ 
						'Else'
						"StatementTerminator<- ->"
						[ "Block<@ out falseStatement @><- this.AdvanceToNextEnd(VBTokenID.If, true); return false; ->" ]
					]
					<%
						this.AdvanceToNextEnd(VBTokenID.If, true);
						statement = new IfStatement(condition, trueStatement, falseStatement, new TextRange(startOffset, this.Token.EndOffset));
						if (elseIfSections.Count > 0)
							((IfStatement)statement).ElseIfSections.AddRange(elseIfSections.ToArray());					
					%>
				)
				| (
					<!-- SelectStatement via ConditionalStatement -->
					<%
						Expression expression;
						AstNodeList sections = new AstNodeList(null);
					%>
					'Select'
					[ 'Case' ]
					"Expression<@ out expression @><- this.AdvanceToNextEnd(VBTokenID.Select, true); return false; ->"
					"StatementTerminator<- ->"
					{ <? (this.TokenIs(this.LookAheadToken, VBTokenID.Case)) && (!this.TokenIs(this.GetLookAheadToken(2), VBTokenID.Else)) ?>
						<%
							SwitchSection switchSection = new SwitchSection();
							switchSection.StartOffset = this.LookAheadToken.StartOffset;
							Statement embeddedStatement;
						%>
						'Case'
						"CaseClause<@ switchSection @>"
						{ 'Comma' "CaseClause<@ switchSection @>" }
						"StatementTerminator<- ->"
						[ "Block<@ out embeddedStatement @><+ switchSection.Statements.Add(embeddedStatement); +><- this.AdvanceToNextEnd(VBTokenID.Select, true); return false; ->" ]
						<%
							switchSection.EndOffset = this.Token.EndOffset;
							sections.Add(switchSection);

							// Reap comments
							this.ReapComments(switchSection.Comments, false);
						%>
					}
					[ <? this.AreNextTwo(VBTokenID.Case, VBTokenID.Else) ?>
						<%
							SwitchSection switchSection = new SwitchSection();
							switchSection.StartOffset = this.LookAheadToken.StartOffset;
							Statement embeddedStatement;
						%>
						'Case'
						'Else'
						"StatementTerminator<- ->"
						[ "Block<@ out embeddedStatement @><+ switchSection.Statements.Add(embeddedStatement); +><- this.AdvanceToNextEnd(VBTokenID.Select, true); return false; ->" ]
						<%
							switchSection.EndOffset = this.Token.EndOffset;
							sections.Add(switchSection);

							// Reap comments
							this.ReapComments(switchSection.Comments, false);
						%>
					]
					<%
						this.AdvanceToNextEnd(VBTokenID.Select, true);
						statement = new SwitchStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
						((SwitchStatement)statement).Sections.AddRange(sections.ToArray());					
					%>
				)
				| (
					<!-- WhileStatement via LoopStatement -->
					<%
						Expression expression;
						Statement embeddedStatement = null;
					%>
					'While'
					"Expression<@ out expression @><- this.AdvanceToNextEnd(VBTokenID.While, true); return false; ->"
					"StatementTerminator<- ->"
					[ "Block<@ out embeddedStatement @><- this.AdvanceToNextEnd(VBTokenID.While, true); return false; ->" ]
					<%
						this.AdvanceToNextEnd(VBTokenID.While, true);
						statement = new WhileStatement(expression, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- DoTopLoopStatement/DoBottomLoopStatement via LoopStatement/DoLoopStatement -->
					<%
						Expression expression = null;
						Statement embeddedStatement = null;
						bool isTopLoop = false;
						// bool isBottomLoop = false;	// NOTE: This variable determines whether the end result is a top or bottom loop
					%>
					'Do'
					[ 
						<%
							isTopLoop = true;
						%>
						(
							'While'
							| 'Until'
						)
						"Expression<@ out expression @>"
					]
					"StatementTerminator<- ->"
					[ "Block<@ out embeddedStatement @>" ]
					'Loop'
					<%
						if (!isTopLoop) {
					%>
							[
								<%
									// isBottomLoop = true;
								%>
								(
									'While'
									| 'Until'
								)
								"Expression<@ out expression @>"
							]
					<%
						}
					%>					
					<%
						statement = new DoStatement(embeddedStatement, expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- ForStatement/ForEachStatement via LoopStatement -->
					<%
						IAstNode initializer;
						Statement embeddedStatement = null;
						bool isForEach = false;
						
					%>
					'For'
					[ 'Each<+ isForEach = true; +>' ]
					(
						(
							<%
								initializer = new LocalVariableDeclaration();
								initializer.StartOffset = this.LookAheadToken.StartOffset;
								QualifiedIdentifier name;
								int[] arrayRanks = null;
								TypeReference typeReference = new TypeReference("System.Object", TextRange.Deleted);
							%>
							"Identifier<@ out name @>"
							[
								(
									'QuestionMark'
								)
								|<? this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis) ?> (
									<%
										bool isArrayTypeModifier = false;
									%>
									{<? this.IsArrayTypeModifier() ?> "ArrayTypeModifier<@ out arrayRanks @><+ isArrayTypeModifier = true; +>" }
									[<? !isArrayTypeModifier ?> "ArraySizeInitializationModifier<@ out arrayRanks @>" ]					
								)
							]
							<!-- NOTE: If Expression is later allowed before, this should not be optional -->
							[
								'As'
								"TypeName<@ out typeReference, false @><+ typeReference.ArrayRanks = arrayRanks;  +>"
							]
							<%
								initializer.EndOffset = this.Token.EndOffset;
								if (typeReference != null)
									((LocalVariableDeclaration)initializer).Variables.Add(new VariableDeclarator(typeReference, name, false, true));
								else
									initializer = new SimpleName(name.Text, name.TextRange);
							%>
						)
						<!-- NOTE: This is currently left out due to Identifier ambiguity with the above
						| (
							<%
								Expression expression;
							%>
							"Expression<@ out expression @><+ initializer = expression; +>"
						)
						-->
					)
					<%
						if (isForEach) {
							Expression variableDeclaration;
							Expression expression;
					%>
							'In'
							"Expression<@ out variableDeclaration @>"
							"StatementTerminator<- ->"
							[ "Block<@ out embeddedStatement @>" ]
							'Next'
							{ "Expression<@ out expression @>" }
					<%
							statement = new ForEachStatement(initializer, variableDeclaration, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
							"StatementTerminator<- ->"
					<%
						}
						else {
							statement = new ForStatement();
							statement.StartOffset = startOffset;
							((ForStatement)statement).Initializers.Add(initializer);
							Expression expression;
					%>
							'Equality'
							"Expression<@ out expression @><+
									if (initializer is LocalVariableDeclaration)
										((VariableDeclarator)((LocalVariableDeclaration)initializer).Variables[0]).Initializer = expression;
								+>"
							'To'
							"Expression<@ out expression @><+ ((ForStatement)statement).Condition = expression; +>"
							[ 'Step' "Expression<@ out expression @><+ ((ForStatement)statement).Iterators.Add(expression); +>" ]
							"StatementTerminator<- ->"
							[ "Block<@ out embeddedStatement @><+ ((ForStatement)statement).Statement = embeddedStatement; +>" ]
							'Next'
							[ 
								"Expression<@ out expression @>"
								{ 'Comma' "Expression<@ out expression @>" }
							]
							<%
								statement.EndOffset = this.Token.EndOffset;
							%>
							"StatementTerminator<- ->"
							<%
						}
					%>
				)
				| (
					<!-- ThrowStatement via ErrorHandlingStatement/StructuredErrorStatement -->
					<%
						Expression expression = null;
					%>
					'Throw'
					[ "Expression<@ out expression @>" ]
					<%
						statement = new ThrowStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- TryStatement via ErrorHandlingStatement/StructuredErrorStatement -->
					<%
						Statement tryBlock = null;
						Statement finallyBlock = null;
						AstNodeList catchClauses = new AstNodeList(null);
					%>
					'Try'
					"StatementTerminator<- ->"
					[ "Block<@ out tryBlock @>" ]
					{
						<%
							VariableDeclarator variableDeclarator = null;
							QualifiedIdentifier variableName = null;
							TypeReference typeReference = new TypeReference("System.Object", TextRange.Deleted);
							Expression evaluationExpression = null;
							Statement catchBlock = null;
							int catchStartOffset = this.LookAheadToken.StartOffset;
						%>
						'Catch'
						[
							<%
								int variableStartOffset = this.LookAheadToken.StartOffset;
							%>
							"Identifier<@ out variableName @>"
							[
								'As'
								"NonArrayTypeName<@ out typeReference, false @>"
							]
							<%
								variableDeclarator = new VariableDeclarator(typeReference, variableName, false, true);
								variableDeclarator.TextRange = new TextRange(variableStartOffset, this.Token.EndOffset);
							%>
						]
						[
							'When'
							"Expression<@ out evaluationExpression @>"
						]
						"StatementTerminator<- ->"
						[ "Block<@ out catchBlock @>" ]
						<%
							CatchClause catchClause = new CatchClause(variableDeclarator, (BlockStatement)catchBlock, new TextRange(catchStartOffset, this.Token.EndOffset));
							catchClause.EvaluationExpression = evaluationExpression;
							catchClauses.Add(catchClause);
						%>
					}
					[
						'Finally'
						"StatementTerminator<- ->"
						[ "Block<@ out finallyBlock @>" ]
					]
					<%
						this.AdvanceToNextEnd(VBTokenID.Try, true);
						statement = new TryStatement(tryBlock, finallyBlock, new TextRange(startOffset, this.Token.EndOffset));
						if (catchClauses.Count > 0)
							((TryStatement)statement).CatchClauses.AddRange(catchClauses.ToArray());					
					%>
				)
				| (
					<!-- ErrorStatement via ErrorHandlingStatement/UnstructuredErrorStatement -->
					<%
						Expression expression = null;
					%>
					'Error'
					"Expression<@ out expression @>"
					<%
						statement = new UnstructuredErrorErrorStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- OnErrorStatement via ErrorHandlingStatement/UnstructuredErrorStatement -->
					<%
						Expression expression = null;
						UnstructuredErrorOnErrorStatementType actionType = UnstructuredErrorOnErrorStatementType.EstablishResumeNext;
					%>
					'On'
					'Error'
					(
						(
							'GoTo'
							(
								( 'Subtraction' 'DecimalIntegerLiteral<+ actionType = UnstructuredErrorOnErrorStatementType.ResetException; +>' )
								| <? this.TokenIs(this.LookAheadToken, VBTokenID.DecimalIntegerLiteral) ?> ( 'DecimalIntegerLiteral<+ actionType = UnstructuredErrorOnErrorStatementType.ResetExceptionHandlerLocation; +>' ) 
								| ( "LabelName<@ out expression @><+ actionType = UnstructuredErrorOnErrorStatementType.EstablishHandlerLocation; +>" )
							)
						)
						| ( 'Resume' 'Next' )
					)
					<%
						statement = new UnstructuredErrorOnErrorStatement(actionType, expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- ResumeStatement via ErrorHandlingStatement/UnstructuredErrorStatement -->
					<%
						Expression expression = null;
					%>
					'Resume'
					[ 'Next' "LabelName<@ out expression @>" ]
					<%
						statement = new UnstructuredErrorResumeNextStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- GotoStatement -->
					<%
						Expression expression;
					%>
					'GoTo'
					"LabelName<@ out expression @>"
					<%
						statement = new GotoStatement(null, expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- ExitStatement -->
					'Exit'
					(
						'Do'
						| 'For'
						| 'While'
						| 'Select'
						| 'Sub'
						| 'Function'
						| 'Property'
						| 'Try'
					)
					<%
						statement = new ExitStatement(new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- ContinueStatement -->
					'Continue'
					(
						'Do'
						| 'For'
						| 'While'
					)
					<%
						statement = new ContinueStatement(new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- StopStatement -->
					'Stop'
					<%
						statement = new BranchStatement(BranchStatementType.Stop, new TextRange(startOffset, this.Token.EndOffset));
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- ReturnStatement -->
					<%
						Expression expression = null;
					%>
					'Return'
					[ "Expression<@ out expression @>" ]
					<%
						statement = new ReturnStatement(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- ReDimStatement (via ArrayHandlingStatement) -->
					<%
						statement = new ArrayRedimStatement();
						statement.StartOffset = startOffset;
						ArrayRedimClause redimClause;
					%>
					'ReDim'
					[<? (this.TokenIs(this.LookAheadToken, VBTokenID.Identifier)) && (this.LookAheadTokenText.ToLower() == "preserve") ?> "SimpleIdentifier" ]
					"RedimClause<@ out redimClause @><+ ((ArrayRedimStatement)statement).Clauses.Add(redimClause); +>"
					{ 'Comma' "RedimClause<@ out redimClause @><+ ((ArrayRedimStatement)statement).Clauses.Add(redimClause); +>" }
					<%
						statement.EndOffset = this.Token.EndOffset;						
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- EraseStatement (via ArrayHandlingStatement) -->
					'Erase'
					<%
						statement = new ArrayEraseStatement();
						statement.StartOffset = startOffset;
						Expression expression;
					%>
					"Expression<@ out expression @><+ ((ArrayEraseStatement)statement).Expressions.Add(expression); +>"
					{ 'Comma' "Expression<@ out expression @><+ ((ArrayEraseStatement)statement).Expressions.Add(expression); +>" }
					<%
						statement.EndOffset = this.Token.EndOffset;						
					%>
					"StatementTerminator<- ->"
				)
				| (
					<!-- UsingStatement -->
					<%
						Statement embeddedStatement = null;
						Expression expression = null;
						AstNodeList resourceAcquisitions = new AstNodeList(null);
					%>
					'Using'
					<%
						LocalVariableDeclaration declaration = new LocalVariableDeclaration();
						declaration.StartOffset = this.LookAheadToken.StartOffset;
						if (this.IsVariableDeclarator()) {
					%>
							"VariableDeclarator<@ null, declaration @>"
							{ 'Comma' "VariableDeclarator<@ null, declaration @>" }
						<%
							declaration.EndOffset = this.Token.EndOffset;
							resourceAcquisitions.Add(declaration);
						}
						else {
					%>
							"Expression<@ out expression @><+ resourceAcquisitions.Add(expression); +>"
					<%
						}
				%>
					"StatementTerminator<- ->"
					[ "Block<@ out embeddedStatement @>" ]
					<%
						this.AdvanceToNextEnd(VBTokenID.Using, true);
						statement = new UsingStatement(resourceAcquisitions, embeddedStatement, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Block" Parameters="out Statement block">
			<Production><![CDATA[
				<%
					block = new BlockStatement();
					block.StartOffset = this.LookAheadToken.StartOffset;
					Statement statement;
					
					bool errorReported = false;
					while (!this.IsAtEnd) {
						if (this.IsBlockTerminator())
							break;
						else if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
							// Skip over line terminators
							this.AdvancePastTerminators();
						}
						else if (IsNonTerminal("Statements")) {
							errorReported = false;
					%>
							{ "Statements<@ out statement @><+ 
									((BlockStatement)block).Statements.Add(statement); 
								+>
								<- 
									// Error recovery:  Advance to the next statement terminator since nothing was matched or quit if at a block terminator
									if (!this.IsBlockTerminator()) 
										this.AdvanceToNextStatementTerminator(); 
									else 
										break; 
								->" }
					<%
						}
						else {
							// Error recovery:  Advance to the next statement terminator since nothing was matched
							if (!errorReported) {
								this.ReportSyntaxError(AssemblyInfo.Instance.Resources.GetString("SemanticParserError_StatementExpected"));
								errorReported = true;
							}
							this.AdvanceToNextStatementTerminator(); 
						}
					}

					// Reap comments
					this.ReapComments(((BlockStatement)block).Comments, false);
					
					block.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: LabelDeclarationStatement merged into Statement -->
		<NonTerminal Key="LabelName" Parameters="out Expression expression">
			<AdditionalConditions>
				<ClearFirstSet />
				<ExpressionCondition>(this.AreNextTwoIdentifierAnd(VBTokenID.Colon)) || (this.AreNextTwo(VBTokenID.DecimalIntegerLiteral, VBTokenID.Colon))</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					expression = null;
				%>
				"SimpleIdentifier<+ expression = new SimpleName(this.TokenText, this.Token.TextRange); +>"
				| 'DecimalIntegerLiteral<+ expression = new LiteralExpression(LiteralType.DecimalInteger, this.TokenText, this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="Statements" Parameters="out Statement statement">
			<Production><![CDATA[
				"Statement<@ out statement @>"
				{ 
					<%
						Statement otherStatement;
					%>
					'Colon' "Statement<@ out otherStatement @>" 
					<%
						BlockStatement blockStatement = statement as BlockStatement;
						if (blockStatement == null) {
							blockStatement = new BlockStatement();
							blockStatement.StartOffset = statement.StartOffset;
							blockStatement.Statements.Add(statement);							
						}
						blockStatement.Statements.Add(otherStatement);
						blockStatement.EndOffset = otherStatement.EndOffset;
					%>
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: LocalDeclarationStatement merged into Statement -->
		<!-- NOTE: LocalModifier merged into Modifiers -->
		<!-- NOTE: WithStatement merged into Modifiers -->
		<!-- NOTE: SyncLockStatement merged into Modifiers -->
		<!-- NOTE: EventStatement merged into Modifiers -->
		<!-- NOTE: RaiseEventStatement merged into Modifiers -->
		<!-- NOTE: AddHandlerStatement merged into Modifiers -->
		<!-- NOTE: RemoveHandlerStatement merged into Modifiers -->
		<!-- NOTE: AssignmentStatement merged into Statement -->
		<!-- NOTE: RegularAssignmentStatement merged into Statement -->
		<!-- NOTE: CompoundAssignmentStatement merged into Statement -->
		<!-- NOTE: CompoundBinaryOperator merged into Statement -->
		<!-- NOTE: MidAssignmentStatement merged into Statement -->
		<!-- NOTE: InvocationStatement merged into Statement -->
		<!-- NOTE: ConditionalStatement merged into Statement -->
		<!-- NOTE: IfStatement merged into Statement -->
		<!-- NOTE: BlockIfStatement merged into Statement -->
		<!-- NOTE: ElseIfStatement merged into Statement -->
		<!-- NOTE: ElseStatement merged into Statement -->
		<!-- NOTE: LineIfThenStatement merged into Statement -->
		<!-- NOTE: SelectStatement merged into Statement -->
		<!-- NOTE: CaseStatement merged into Statement -->
		<!-- NOTE: CaseClauses merged into Statement -->
		<NonTerminal Key="CaseClause" Parameters="SwitchSection switchSection">
			<Production><![CDATA[
				<%
					Expression expression;
					int startOffset = this.LookAheadToken.StartOffset;
					OperatorType operatorType = OperatorType.None;
				%>
				(
					[ 'Is' ]
					(
						'Equality<+ operatorType = OperatorType.Equality; +>'
						| 'Inequality<+ operatorType = OperatorType.Inequality; +>'
						| 'GreaterThan<+ operatorType = OperatorType.GreaterThan; +>'
						| 'LessThan<+ operatorType = OperatorType.LessThan; +>'
						| 'GreaterThanOrEqual<+ operatorType = OperatorType.GreaterThanOrEqual; +>'
						| 'LessThanOrEqual<+ operatorType = OperatorType.LessThanOrEqual; +>'				
					)
					"Expression<@ out expression @><+ expression = new UnaryExpression(operatorType, expression); +>"
				)
				| (
					"Expression<@ out expression @>"
					[ 
						<%
							Expression rightExpression;
						%>
						'To' 
						"Expression<@ out rightExpression @><+ expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(expression.StartOffset, this.Token.EndOffset)); +>" 
					]
				)
				<%
					switchSection.Labels.Add(new SwitchLabel(expression, new TextRange(startOffset, this.Token.EndOffset)));
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ComparisonOperator merged into CaseClause -->
		<!-- NOTE: CaseElseStatement merged into Statement -->
		<!-- NOTE: LoopStatement merged into Statement -->
		<!-- NOTE: WhileStatement merged into Statement -->
		<!-- NOTE: DoLoopStatement merged into Statement -->
		<!-- NOTE: DoTopLoopStatement merged into Statement -->
		<!-- NOTE: DoBottomLoopStatement merged into Statement -->
		<!-- NOTE: WhileOrUntil merged into Statement -->
		<!-- NOTE: ForStatement merged into Statement -->
		<!-- NOTE: LoopControlVariable merged into Statement -->
		<!-- NOTE: NextExpressionList merged into Statement -->
		<!-- NOTE: ForEachStatement merged into Statement -->
		<!-- NOTE: ErrorHandlingStatement merged into Statement -->
		<!-- NOTE: StructuredErrorStatement merged into Statement -->
		<!-- NOTE: TryStatement merged into Statement -->
		<!-- NOTE: FinallyStatement merged into Statement -->
		<!-- NOTE: CatchStatement merged into Statement -->
		<!-- NOTE: ThrowStatement merged into Statement -->
		<!-- NOTE: UnstructuredErrorStatement merged into Statement -->
		<!-- NOTE: ErrorStatement merged into Statement -->
		<!-- NOTE: OnErrorStatement merged into Statement -->
		<!-- NOTE: ErrorClause merged into Statement -->
		<!-- NOTE: ResumeStatement merged into Statement -->
		<!-- NOTE: ResumeClause merged into Statement -->
		<!-- NOTE: BranchStatement merged into Statement -->
		<!-- NOTE: GotoStatement merged into Statement -->
		<!-- NOTE: ExitStatement merged into Statement -->
		<!-- NOTE: ExitKind merged into Statement -->
		<!-- NOTE: ContinueStatement merged into Statement -->
		<!-- NOTE: ContinueKind merged into Statement -->
		<!-- NOTE: StopStatement merged into Statement -->
		<!-- NOTE: EndStatement merged into Statement -->
		<!-- NOTE: ReturnStatement merged into Statement -->
		<!-- NOTE: ArrayHandlingStatement merged into Statement -->
		<!-- NOTE: RedimStatement merged into Statement -->
		<!-- NOTE: RedimClauses merged into Statement -->
		<NonTerminal Key="RedimClause" Parameters="out ArrayRedimClause redimClause">
			<Production><![CDATA[
				<%
					redimClause = null;
					int startOffset = this.LookAheadToken.StartOffset;
					Expression expression;
					int[] arrayRanks;
				%>
				"PrimaryExpression<@ false, out expression @>"
				"ArraySizeInitializationModifier<@ out arrayRanks @>"
				<%
					redimClause = new ArrayRedimClause(expression, arrayRanks, new TextRange(startOffset, this.Token.EndOffset));
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: EraseStatement merged into Statement -->
		<!-- NOTE: EraseExpressions merged into Statement -->
		<!-- NOTE: UsingStatement merged into Statement -->
		<!-- NOTE: UsingResources merged into Statement -->
			
		<!-- 13.3.6 Expressions -->
		<NonTerminal Key="Expression" Parameters="out Expression expression">
			<Production><![CDATA[
				"ExclusiveDisjunctionExpression<@ out expression @>"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ConstantExpression simply uses Expression since the code is really all the same -->
		<NonTerminal Key="PrimaryExpression" Parameters="bool allowParenMatchAtEnd, out Expression expression">
			<AdditionalConditions>
				<ExpressionCondition>this.IsDotIdentifierOrKeyword(true) || this.IsConditionalExpression()</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					expression = null;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				'True<+ expression = new LiteralExpression(LiteralType.True, null, this.Token.TextRange); +>'
				| 'False<+ expression = new LiteralExpression(LiteralType.False, null, this.Token.TextRange); +>'
				| 'DecimalIntegerLiteral<+ expression = new LiteralExpression(LiteralType.DecimalInteger, this.TokenText, this.Token.TextRange); +>'
				| 'HexadecimalIntegerLiteral<+ expression = new LiteralExpression(LiteralType.HexadecimalInteger, this.TokenText, this.Token.TextRange); +>'
				| 'OctalIntegerLiteral<+ expression = new LiteralExpression(LiteralType.OctalInteger, this.TokenText, this.Token.TextRange); +>'
				| 'FloatingPointLiteral<+ expression = new LiteralExpression(LiteralType.Real, this.TokenText, this.Token.TextRange); +>'
				| 'CharacterLiteral<+ expression = new LiteralExpression(LiteralType.Character, this.TokenText, this.Token.TextRange); +>'
				| 'StringLiteral<+ expression = new LiteralExpression(LiteralType.String, this.TokenText, this.Token.TextRange); +>'
				| 'DateLiteral<+ expression = new LiteralExpression(LiteralType.Date, this.TokenText, this.Token.TextRange); +>'
				| 'XmlLiteral<+ expression = new LiteralExpression(LiteralType.Xml, this.TokenText, this.Token.TextRange); +>'
				| 'Nothing<+ expression = new LiteralExpression(LiteralType.Null, null, this.Token.TextRange); +>'
				| "QueryExpression<@ out expression @>"
				| (
					<!-- ParenthesizedExpression -->
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'CloseParenthesis'
					<%
						expression = new ParenthesizedExpression(expression, new TextRange(startOffset, this.Token.EndOffset));
					%>					
				)
				| (
					<!-- InstanceExpression -->
					'Me<+ expression = new ThisAccess(this.Token.TextRange); +>'
				)
				| 'Mid<+ expression = new SimpleName(this.TokenText, this.Token.TextRange); +>'
				| (
					<!-- SimpleNameExpression -->
					"SimpleIdentifier<+ expression = new SimpleName(this.TokenText, this.Token.TextRange); +>"
					[<? this.AreNextTwo(VBTokenID.OpenParenthesis, VBTokenID.Of) ?>
						'OpenParenthesis'
						'Of'
						<%
							AstNodeList typeArgumentList;
						%>
						"TypeArgumentList<@ out typeArgumentList @><+ 
							if (typeArgumentList != null)
								expression.GenericTypeArguments.AddRange(typeArgumentList.ToArray());					
							+>"
						'CloseParenthesis'
					]
					<%
						// This occurs when there is a call like this without parens:  MyMethod
						if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
							expression = new InvocationExpression(expression);
							expression.TextRange = ((InvocationExpression)expression).Expression.TextRange;
						}
					%>
				)
				| (
					<!-- AddressOfExpression -->
					'AddressOf'
					"Expression<@ out expression @><+ expression = new AddressOfExpression(expression, new TextRange(startOffset, this.Token.EndOffset)); +>"
				)
				| (
					<!-- GetTypeExpression -->
					<%
						TypeReference typeReference = null;
					%>
					'GetTypeKeyword'
					'OpenParenthesis'
					"TypeName<@ out typeReference, true @>"
					<!-- TODO:
					| (
						<%
							QualifiedIdentifier identifier;
							AstNodeList typeArgumentList = null;
						%>
						"QualifiedIdentifier<@ out identifier @>"
						'OpenParenthesis'
						'Of'
						[ 
					-->
						
							<!-- TypeArityList -->
					<!--							
							[ "TypeParameterList<@ out typeArgumentList @>" ]
							'Comma<+ typeArgumentList.Add(new TypeReference(null, TextRange.Deleted));  // Add a null type reference +>'
						]
						'CloseParenthesis'
						<%
							typeReference = new TypeReference(identifier.Text, new TextRange(identifier.StartOffset, this.Token.EndOffset));
							if (typeArgumentList != null)
								typeReference.GenericTypeArguments.AddRange(typeArgumentList.ToArray());
						%>
					)
					-->
					'CloseParenthesis'
					<%
						expression = new TypeOfExpression(typeReference, new TextRange(startOffset, this.Token.EndOffset));
					%>					
				)
				| (
					<!-- TypeOfIsExpression -->
					<%
						TypeReference typeReference;
					%>
					'TypeOf'
					"PrimaryExpression<@ true, out expression @>"
					'Is'
					"TypeName<@ out typeReference, false @>"
					<%
						expression = new IsTypeOfExpression(expression, typeReference, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- GetXmlNamespaceExpression -->
					'GetXmlNamespace'
					'OpenParenthesis'
					<%
						string namespaceName = String.Empty;
						int nameStartOffset = this.LookAheadToken.StartOffset;
						while (this.IsIdentifier(this.LookAheadToken) || this.TokenIs(this.LookAheadToken, VBTokenID.Subtraction)) {
							namespaceName += this.LookAheadTokenText;
							this.AdvanceToNext();
						}
						int nameEndOffset = this.Token.EndOffset;
					%>
					'CloseParenthesis'
					<%
						expression = new GetXmlNamespaceExpression(new SimpleName(namespaceName, new TextRange(nameStartOffset, nameEndOffset)), new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- MemberAccessBase -->
					<%
						TypeReference typeReference;
					%>
					"BuiltInTypeName<@ out typeReference @><+ expression = new TypeReferenceExpression(typeReference); +>"
				)
				| (
					<!-- MemberAccessBase -->
					'Global'
					'Dot'
					<%
						TypeReference typeReference;
					%>
					"TypeName<@ out typeReference, false @>"					
					<%
						expression = new TypeReferenceExpression(typeReference);
						expression.StartOffset = startOffset;  // Update the start offset to include the Global.
					%>
				)
				| (
					<!-- MemberAccessBase -->
					'MyBase<+ expression = new BaseAccess(this.Token.TextRange); +>'
				)
				| (
					<!-- MemberAccessBase -->
					'MyClass<+ expression = new ClassAccess(this.Token.TextRange); +>'
				)
				| "NewExpression<@ out expression @>"
				| (
					<!-- CastExpression -->
					<%
						TypeReference typeReference;
					%>
					( 'DirectCast' | 'CType' )
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'Comma'
					"TypeName<@ out typeReference, false @>"
					'CloseParenthesis'
					<%
						expression = new CastExpression(typeReference, expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- CastExpression -->
					<%
						TypeReference typeReference;
					%>
					'TryCast'
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'Comma'
					"TypeName<@ out typeReference, false @>"
					'CloseParenthesis'
					<%
						expression = new TryCastExpression(expression, typeReference, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- CastExpression -->
					<%
						TypeReference typeReference;
					%>
					"CastTarget<@ out typeReference @>"
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'CloseParenthesis'
					<%
						expression = new CastExpression(typeReference, expression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				|<? this.IsConditionalExpression() ?> (
					<%
						Expression trueExpression;
						Expression falseExpression = null;
					%>
					'If'
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'Comma'
					"Expression<@ out trueExpression @>"
					[
						'Comma'
						"Expression<@ out falseExpression @>"
					]
					'CloseParenthesis'
					<%
						if (falseExpression != null)
							expression = new ConditionalExpression(expression, trueExpression, falseExpression, new TextRange(startOffset, this.Token.EndOffset));
						else
							expression = new BinaryExpression(OperatorType.NullCoalescing, expression, trueExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| (
					<!-- IIfExpression (NOTE: Not really part of grammar but is a recognized function) -->
					<%
						Expression trueExpression;
						Expression falseExpression;
					%>
					'IIf'
					'OpenParenthesis'
					"Expression<@ out expression @>"
					'Comma'
					"Expression<@ out trueExpression @>"
					'Comma'
					"Expression<@ out falseExpression @>"
					'CloseParenthesis'
					<%
						expression = new ConditionalExpression(expression, trueExpression, falseExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				)
				| "LambdaExpression<@ out expression @>"
				| <? this.IsDotIdentifierOrKeyword(true) ?> (
					<%
						// If there is a .Identifier, then this is probably within a With statement block...
						//   this code will create a MemberAccessExpression below with a null target
						// NOTE: In the future, perhaps pass along what context we are in to ensure there is a valid With statement above
					%>
				)

				{
					( 
						<!-- MemberAccessExpression -->
						<%
							QualifiedIdentifier memberName;
						%>
						'Dot' 
						(
							( 'XmlLiteral<- ->' | 'XmlAttribute<- ->' )
							<%
								memberName = new QualifiedIdentifier(this.TokenText, this.Token.TextRange);
								expression = new MemberAccess(expression, memberName, new TextRange(startOffset, this.Token.EndOffset));
							%>
						)
						| (
							"IdentifierOrKeyword<@ out memberName @>" 
							<%
								expression = new MemberAccess(expression, memberName, new TextRange(startOffset, this.Token.EndOffset));
								AstNodeList typeArgumentList = null;
							%>
							[<? this.AreNextTwo(VBTokenID.OpenParenthesis, VBTokenID.Of) ?>					
								'OpenParenthesis'
								'Of'
								[ "TypeArgumentList<@ out typeArgumentList @>" ]
								'CloseParenthesis'
							]
							<%
								if (typeArgumentList != null)
									expression.GenericTypeArguments.AddRange(typeArgumentList.ToArray());
									
								// This occurs when there is a call like this without parens:  MyBase.New
								if (this.TokenIs(this.LookAheadToken, VBTokenID.LineTerminator)) {
									expression = new InvocationExpression(expression);
									expression.TextRange = ((InvocationExpression)expression).Expression.TextRange;
								}
							%>
						)
					)
					| ( 
						<!-- MemberAccessExpression (XML attribute) -->
						<%
							QualifiedIdentifier memberName;
						%>
						'DotAt' 
						( 'XmlLiteral<- ->' | 'XmlAttribute<- ->' )
						<%
							memberName = new QualifiedIdentifier(this.TokenText, this.Token.TextRange);
							expression = new MemberAccess(expression, memberName, new TextRange(startOffset, this.Token.EndOffset));
							((MemberAccess)expression).MemberAccessType = MemberAccessType.XmlAttribute;
						%>
					)
					| ( 
						<!-- MemberAccessExpression (XML descendent) -->
						<%
							QualifiedIdentifier memberName;
						%>
						'TripleDot' 
						'XmlLiteral'
						<%
							memberName = new QualifiedIdentifier(this.TokenText, this.Token.TextRange);
							expression = new MemberAccess(expression, memberName, new TextRange(startOffset, this.Token.EndOffset));
							((MemberAccess)expression).MemberAccessType = MemberAccessType.XmlDescendent;
						%>
					)
					| (
						<!-- DictionaryAccessExpression  -->
						<%
							if (!allowParenMatchAtEnd)
								return true;
							QualifiedIdentifier key;
						%>
						'ExclamationPoint'
						"IdentifierOrKeyword<@ out key @>"
						<%
							expression = new MemberAccess(expression, key, new TextRange(startOffset, this.Token.EndOffset));
						%>					
					)
					| (
						<%
							if (!allowParenMatchAtEnd)
								return true;
						%>
						"InvocationExpression<@ ref expression @>"
					)
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: SimpleExpression merged into PrimaryExpression -->
		<!-- NOTE: LiteralExpression merged into PrimaryExpression -->
		<!-- NOTE: ParenthesizedExpression merged into PrimaryExpression -->
		<!-- NOTE: InstanceExpression merged into PrimaryExpression -->
		<!-- NOTE: SimpleNameExpression merged into PrimaryExpression -->
		<!-- NOTE: AddressOfExpression merged into PrimaryExpression -->
		<!-- NOTE: TypeExpression merged into PrimaryExpression -->
		<!-- NOTE: GetTypeExpression merged into PrimaryExpression -->
		<!-- NOTE: GetTypeTypeName merged into PrimaryExpression -->
		<!-- NOTE: TypeArityList merged into NonArrayTypeName -->
		<!-- NOTE: TypeOfIsExpression merged into PrimaryExpression -->
		<!-- NOTE: IsExpression merged into ComparisonExpression -->
		<!-- NOTE: MemberAccessExpression merged into ComparisonExpression -->
		<!-- NOTE: MemberAccessBase merged into PrimaryExpression -->
		<!-- NOTE: DictionaryAccessExpression merged into PrimaryExpression -->
		<NonTerminal Key="InvocationExpression" Parameters="ref Expression expression">
			<Production><![CDATA[
				<%
					// NOTE: The real invocation expression parses an Expression first but it is up to the caller to supply that
					int startOffset = expression.StartOffset;
					expression = new InvocationExpression(expression);
					expression.StartOffset = startOffset;
					AstNodeList argumentList = null;
				%>
				'OpenParenthesis'
				[ "ArgumentList<@ out argumentList @>" ] 						
				'CloseParenthesis'
				<%
					if (argumentList != null)
						((InvocationExpression)expression).Arguments.AddRange(argumentList.ToArray());
					expression.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ArgumentList" Parameters="out AstNodeList argumentList">
			<Production><![CDATA[
				<%
					argumentList = new AstNodeList(null);
					int startOffset = this.LookAheadToken.StartOffset;
					QualifiedIdentifier name = null;
					Expression expression;
					
				%>
				[<? ((this.TokenIs(this.LookAheadToken, VBTokenID.Identifier)) || (this.IsKeyword())) && (this.TokenIs(this.GetLookAheadToken(2), VBTokenID.ColonEquals)) ?>
					"IdentifierOrKeyword<@ out name @>"
					'ColonEquals'
				]
				"Expression<@ out expression @><+ argumentList.Add(new ArgumentExpression(ParameterModifiers.None, name, expression, new TextRange(startOffset, this.Token.EndOffset))); +>"
				{
					<%
						startOffset = this.LookAheadToken.StartOffset;
						name = null;
					%>
					'Comma'
					[<? ((this.TokenIs(this.LookAheadToken, VBTokenID.Identifier)) || (this.IsKeyword())) && (this.TokenIs(this.GetLookAheadToken(2), VBTokenID.ColonEquals)) ?>
						"IdentifierOrKeyword<@ out name @>"
						'ColonEquals'
					]
					"Expression<@ out expression @><+ argumentList.Add(new ArgumentExpression(ParameterModifiers.None, name, expression, new TextRange(startOffset, this.Token.EndOffset))); +>"
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: PositionalArgumentList merged into ArgumentList -->
		<!-- NOTE: NamedArgumentList merged into ArgumentList -->
		<!-- NOTE: IndexExpression merged into PrimaryExpression -->
		<NonTerminal Key="NewExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
				%>
				<!-- AnonymousArrayCreationExpression -->
				"CollectionInitializer<@ out expression @>"
				| (
					<%
						int startOffset = this.LookAheadToken.StartOffset;
						TypeReference typeReference = null;
						AstNodeList argumentList = null;
						Expression fieldInitializer = null;
						bool isArrayCreation = false;
					%>
					'New'
					(
						<!-- AnonymousObjectCreationExpression -->
						"ObjectMemberInitializer<@ out fieldInitializer @><+ typeReference = new TypeReference(TypeReference.AnonymousTypeName, fieldInitializer.TextRange); +>"
						| (
							"NonArrayTypeName<@ out typeReference, false @>"
							<%
								isArrayCreation = this.IsArrayCreationExpression();
							%>
							[<? (!isArrayCreation) && (this.TokenIs(this.LookAheadToken, VBTokenID.OpenParenthesis)) ?>
								'OpenParenthesis'
								[ "ArgumentList<@ out argumentList @>" ]
								'CloseParenthesis'
							]
							<%
								// If this is an ArrayCreationExpression...
								if ((isArrayCreation) && (typeReference != null)) {
									int[] arrayRanks = null;
									Expression initializer = null;
								%>
									[
										"ArraySizeInitializationModifier<@ out arrayRanks @>"
										"CollectionInitializer<@ out initializer @>"
										<%
											expression = new ObjectCreationExpression(typeReference, new TextRange(startOffset, this.Token.EndOffset));
											((ObjectCreationExpression)expression).IsArray = true;
											typeReference.ArrayRanks = arrayRanks;
											((ObjectCreationExpression)expression).Initializer = (ObjectCollectionInitializerExpression)initializer;
											return true;							
										%>
									]
							<% 
								}
								
								// ObjectCreationExpression  
							%>
							[
								"ObjectMemberInitializer<@ out fieldInitializer @>"
								| "ObjectCollectionInitializer<@ out fieldInitializer @>"
							]
						)
						<%
							expression = new ObjectCreationExpression(typeReference, new TextRange(startOffset, this.Token.EndOffset));
							if (argumentList != null)
								((ObjectCreationExpression)expression).Arguments.AddRange(argumentList.ToArray());					
							((ObjectCreationExpression)expression).Initializer = fieldInitializer as ObjectCollectionInitializerExpression;
						%>
					)
				)
			]]></Production>
		</NonTerminal>		
		<!-- NOTE: ObjectCreationExpression merged into NewExpression but also defined separately for variable declarations -->
		<NonTerminal Key="ObjectCreationExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					int startOffset = this.LookAheadToken.StartOffset;
					TypeReference typeReference = null;
					AstNodeList argumentList = null;
					Expression fieldInitializer = null;
				%>
				'New'
				"NonArrayTypeName<@ out typeReference, false @>"
				[
					'OpenParenthesis'
					[ "ArgumentList<@ out argumentList @>" ]
					'CloseParenthesis'
				]
				[
					"ObjectMemberInitializer<@ out fieldInitializer @>"
					| "ObjectCollectionInitializer<@ out fieldInitializer @>"
				]
				<%
					expression = new ObjectCreationExpression(typeReference, new TextRange(startOffset, this.Token.EndOffset));
					if (argumentList != null)
						((ObjectCreationExpression)expression).Arguments.AddRange(argumentList.ToArray());					
					((ObjectCreationExpression)expression).Initializer = fieldInitializer as ObjectCollectionInitializerExpression;
				%>
			]]></Production>
		</NonTerminal>	
		<!-- NOTE: ObjectCreationExpressionInitializer merged into callers of ObjectMemberInitializer/ObjectCollectionInitializer -->
		<NonTerminal Key="ObjectMemberInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					Expression initializer;
					AstNodeList initializerList = new AstNodeList(null);
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				'With'
				'OpenCurlyBrace'
				"FieldInitializer<@ out initializer @><+ initializerList.Add(initializer); +>"
				{ 'Comma' "FieldInitializer<@ out initializer @><+ initializerList.Add(initializer); +>" }
				'CloseCurlyBrace'
				<%
					expression = new ObjectCollectionInitializerExpression(new TextRange(startOffset, this.Token.EndOffset));
					((ObjectCollectionInitializerExpression)expression).Initializers.AddRange(initializerList.ToArray());
				%>
			]]></Production>
		</NonTerminal>	
		<!-- NOTE: FieldInitializerList merged into callers of FieldInitializer -->
		<NonTerminal Key="FieldInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					QualifiedIdentifier identifier;
					SimpleName memberName;				
					Expression valueExpression = null;
					int startOffset = this.LookAheadToken.StartOffset;
					
					if (this.AreNextTwoIdentifierAnd(VBTokenID.Dot)) {
						// Skip over Key
						this.AdvanceToNext();
					}			
				%>
				[ 'Dot' ]
				"IdentifierOrKeyword<@ out identifier @><+ memberName = new SimpleName(identifier.Text, identifier.TextRange); +>"
				[
					'Equality'
					"Expression<@ out valueExpression @>"
				]
				<%
					if (valueExpression != null)
						expression = new AssignmentExpression(OperatorType.None, memberName, valueExpression, new TextRange(startOffset, this.Token.EndOffset));
					else
						expression = memberName;
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ObjectCollectionInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
				%>
				'From'
				[ 'LineTerminator<- ->' ]
				"CollectionInitializer<@ out expression @>"
			]]></Production>
		</NonTerminal>	
		<!-- NOTE: ArrayCreationExpression merged into NewExpression -->
		<!-- NOTE: AnonymousObjectCreationExpression merged into NewExpression -->
		<!-- NOTE: AnonymousArrayCreationExpression merged into NewExpression -->
		<NonTerminal Key="CollectionInitializer" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = new ObjectCollectionInitializerExpression();
					expression.StartOffset = this.LookAheadToken.StartOffset;
					Expression initializer;
					AstNodeList initializerList = new AstNodeList(null);
				%>
				'OpenCurlyBrace'
				[
					"Expression<@ out initializer @><+ ((ObjectCollectionInitializerExpression)expression).Initializers.Add(initializer); +>"
					{ 'Comma' "Expression<@ out initializer @><+ ((ObjectCollectionInitializerExpression)expression).Initializers.Add(initializer); +>" }
				]
				'CloseCurlyBrace<- ->'
				<%
					expression.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: CollectionElementList merged into CollectionInitializer -->
		<!-- NOTE: CastExpression merged into PrimaryExpression -->
		<NonTerminal Key="CastTarget" Parameters="out TypeReference typeReference">
			<Production><![CDATA[
				<%
					typeReference = null;
				%>
				'CBool<+ typeReference = new TypeReference("System.Boolean", this.Token.TextRange); +>'
				| 'CByte<+ typeReference = new TypeReference("System.Byte", this.Token.TextRange); +>'
				| 'CChar<+ typeReference = new TypeReference("System.Char", this.Token.TextRange); +>'
				| 'CDate<+ typeReference = new TypeReference("System.DateTime", this.Token.TextRange); +>'
				| 'CDec<+ typeReference = new TypeReference("System.Decimal", this.Token.TextRange); +>'
				| 'CDbl<+ typeReference = new TypeReference("System.Double", this.Token.TextRange); +>'
				| 'CInt<+ typeReference = new TypeReference("System.Int32", this.Token.TextRange); +>'
				| 'CLng<+ typeReference = new TypeReference("System.Int64", this.Token.TextRange); +>'
				| 'CObj<+ typeReference = new TypeReference("System.Object", this.Token.TextRange); +>'
				| 'CSByte<+ typeReference = new TypeReference("System.SByte", this.Token.TextRange); +>'
				| 'CShort<+ typeReference = new TypeReference("System.Int16", this.Token.TextRange); +>'
				| 'CSng<+ typeReference = new TypeReference("System.Single", this.Token.TextRange); +>'
				| 'CStr<+ typeReference = new TypeReference("System.String", this.Token.TextRange); +>'
				| 'CUInt<+ typeReference = new TypeReference("System.UInt32", this.Token.TextRange); +>'
				| 'CULng<+ typeReference = new TypeReference("System.UInt64", this.Token.TextRange); +>'
				| 'CUShort<+ typeReference = new TypeReference("System.UInt16", this.Token.TextRange); +>'
			]]></Production>
		</NonTerminal>
		<!-- NOTE: OperatorExpression merged into Expression -->
		<!-- NOTE: ArithmeticOperatorExpression merged into Expression -->
		<!-- NOTE: UnaryPlusExpression merged into UnaryExpression -->
		<!-- NOTE: UnaryMinusExpression merged into UnaryExpression -->
		<NonTerminal Key="UnaryExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					OperatorType operatorType = OperatorType.None;
					expression = null;
				%>
				[
					'Addition<+ operatorType = OperatorType.Addition; +>'
					| 'Subtraction<+ operatorType = OperatorType.Subtraction; +>'
				]
				"ExponentOperatorExpression<@ out expression @>"
				<%
					if (operatorType != OperatorType.None)
						expression = new UnaryExpression(operatorType, expression); 
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: AdditionOperatorExpression merged into AdditiveExpression -->
		<!-- NOTE: SubtractionOperatorExpression merged into AdditiveExpression -->
		<NonTerminal Key="AdditiveExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"ModuloOperatorExpression<@ out expression @>"
				{
					<%
						OperatorType operatorType = OperatorType.None;
					%>
					(
						'Addition<+ operatorType = OperatorType.Addition; +>'
						| 'Subtraction<+ operatorType = OperatorType.Subtraction; +>'
					)
					[ 'LineTerminator<- ->' ]
					"AdditiveExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: MultiplicationOperatorExpression merged into MultiplicativeExpression -->
		<!-- NOTE: DivisionOperatorExpression merged into Expression -->
		<!-- NOTE: FPDivisionOperatorExpression merged into MultiplicativeExpression -->
		<NonTerminal Key="MultiplicativeExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"UnaryExpression<@ out expression @>"
				{
					<%
						OperatorType operatorType = OperatorType.None;
					%>
					(
						'Multiplication<+ operatorType = OperatorType.Multiply; +>'
						| 'FloatingPointDivision<+ operatorType = OperatorType.Division; +>'
					)
					[ 'LineTerminator<- ->' ]
					"MultiplicativeExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="IntegerDivisionOperatorExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"MultiplicativeExpression<@ out expression @>"
				{
					'IntegerDivision'
					[ 'LineTerminator<- ->' ]
					"IntegerDivisionOperatorExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.IntegerDivision, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ModuloOperatorExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"IntegerDivisionOperatorExpression<@ out expression @>"
				{
					'Mod'
					[ 'LineTerminator<- ->' ]
					"ModuloOperatorExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.Modulus, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="XmlDescendantExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
				%>
				"PrimaryExpression<@ true, out expression @>"
				[
					<%
						Expression targetExpression;
					%>
					'TripleDot'
					[ 'LineTerminator<- ->' ]
					"XmlDescendantExpression<@ out targetExpression @><+
						expression = new BinaryExpression(OperatorType.XmlDescendant, expression, targetExpression, new TextRange(expression.StartOffset, this.Token.EndOffset));
						+>"
				]
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ExponentOperatorExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"XmlDescendantExpression<@ out expression @>"
				{
					'Exponentiation'
					[ 'LineTerminator<- ->' ]
					"ExponentOperatorExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.Exponentiation, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: RelationalOperatorExpression merged into ComparisonExpression -->
		<!-- NOTE: LikeOperatorExpression merged into ComparisonExpression -->
		<NonTerminal Key="ConcatenationOperatorExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"AdditiveExpression<@ out expression @>"
				{
					'StringConcatenation'
					[ 'LineTerminator<- ->' ]
					"ConcatenationOperatorExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.StringConcatenation, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ComparisonExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"ShiftOperatorExpression<@ out expression @>"
				{
					(
						<%
							OperatorType operatorType = OperatorType.None;
						%>
						(
							'Equality<+ operatorType = OperatorType.Equality; +>'
							| 'Inequality<+ operatorType = OperatorType.Inequality; +>'
							| 'LessThan<+ operatorType = OperatorType.LessThan; +>'
							| 'GreaterThan<+ operatorType = OperatorType.GreaterThan; +>'
							| 'LessThanOrEqual<+ operatorType = OperatorType.LessThanOrEqual; +>'
							| 'GreaterThanOrEqual<+ operatorType = OperatorType.GreaterThanOrEqual; +>'
							| 'Is<+ operatorType = OperatorType.ReferenceEquality; +>'
							| 'IsNot<+ operatorType = OperatorType.ReferenceInequality; +>'
							| 'Like<+ operatorType = OperatorType.Like; +>'
						)
						[ 'LineTerminator<- ->' ]
						"ComparisonExpression<@ out rightExpression @>"
						<%
							expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
						%>
					)
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: LogicalOperatorExpression merged into NegationExpression, ConjunctionExpression, InclusiveDisjunctionExpression, and ExclusiveDisjunctionExpression -->
		<NonTerminal Key="NegationExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					OperatorType operatorType = OperatorType.None;
				%>
				{ 
					'Not<+ operatorType = OperatorType.Negation; +><- ->' 
					[ 'LineTerminator<- ->' ]
				}
				"ComparisonExpression<@ out expression @>"
				<%
					if (operatorType != OperatorType.None)
						expression = new UnaryExpression(operatorType, expression); 
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="ConjunctionExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"NegationExpression<@ out expression @>"
				{
					('And' | 'AndAlso')  
					[ 'LineTerminator<- ->' ]
					"ConjunctionExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.ConditionalAnd, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="InclusiveDisjunctionExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"ConjunctionExpression<@ out expression @>"
				{
					('Or' | 'OrElse') 
					[ 'LineTerminator<- ->' ]
					"InclusiveDisjunctionExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.ConditionalOr, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>				
		<NonTerminal Key="ExclusiveDisjunctionExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"InclusiveDisjunctionExpression<@ out expression @>"
				{
					'Xor'
					[ 'LineTerminator<- ->' ]
					"ExclusiveDisjunctionExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(OperatorType.ExclusiveOr, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ShortCircuitLogicalOperatorExpression merged into ConjunctionExpression and InclusiveDisjunctionExpression -->
		<NonTerminal Key="ShiftOperatorExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					int startOffset = this.LookAheadToken.StartOffset;
					Expression rightExpression;
				%>
				"ConcatenationOperatorExpression<@ out expression @>"
				{
					<%
						OperatorType operatorType = OperatorType.None;
					%>
					(
						'LeftShift<+ operatorType = OperatorType.LeftShift; +>'
						| 'RightShift<+ operatorType = OperatorType.RightShift; +>'
					)
					[ 'LineTerminator<- ->' ]
					"ShiftOperatorExpression<@ out rightExpression @>"
					<%
						expression = new BinaryExpression(operatorType, expression, rightExpression, new TextRange(startOffset, this.Token.EndOffset));
					%>
				}
			]]></Production>
		</NonTerminal>		
		<!-- NOTE: BooleanExpression simply uses Expression since the code is really all the same -->
	
		<!-- Lambda Expressions -->
		<NonTerminal Key="LambdaExpression" Parameters="out Expression expression">
			<Production><![CDATA[
				<%
					expression = null;
					int startOffset = this.LookAheadToken.StartOffset;
					AstNodeList parameterList = null;					
					Expression childExpression;
					bool isFunction = false;
					TypeReference typeReference = null;
				%>
				(
					'Sub'
					| 'Function<+ isFunction = true; +>'
				)
				[
					'OpenParenthesis'
					[ "ParameterList<@ null, out parameterList @>" ]
					'CloseParenthesis'
				]
				(
					<%
						// Multi-line
						Statement statement;
					%>
					[ 'As' "TypeName<@ out typeReference, false @>" ]
					'LineTerminator<- ->'
					"Block<@ out statement @>"
					'End'
					[<? !isFunction ?> 'Sub' ]
					[<? isFunction ?> 'Function' ]
					<%
						expression = new LambdaExpression(statement, new TextRange(startOffset, this.Token.EndOffset));
						if (parameterList != null)
							((LambdaExpression)expression).Parameters.AddRange(parameterList.ToArray());
					%>
				)
				| (
					"Expression<@ out childExpression @>"
					<%
						// In-line
						expression = new LambdaExpression(new StatementExpression(childExpression), new TextRange(startOffset, this.Token.EndOffset));
						if (parameterList != null)
							((LambdaExpression)expression).Parameters.AddRange(parameterList.ToArray());
					%>
				)
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ExpressionLambda/StatementLambda/FunctionStatementLambda/SubStatementLambda merged into LambdaExpression -->

		<!-- Query Expressions -->
		<NonTerminal Key="QueryExpression" Parameters="out Expression expression">
			<AdditionalConditions>
				<ClearFirstSet />
				<ExpressionCondition>(this.TokenIs(this.LookAheadToken, new int[] { VBTokenID.Aggregate, VBTokenID.From })) &amp;&amp; (!this.TokenIs(this.GetLookAheadToken(2), new int[] { VBTokenID.Comma, VBTokenID.CloseParenthesis }))</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					expression = new QueryExpression();
					expression.StartOffset = this.LookAheadToken.StartOffset;
					
					AstNode queryOperator;
				%>
				(
					"FromQueryOperator<@ out queryOperator @><+ ((QueryExpression)expression).QueryOperators.Add(queryOperator); +>"
					| "AggregateQueryOperator<@ out queryOperator @><+ ((QueryExpression)expression).QueryOperators.Add(queryOperator); +>"
				)
				
				[ 'LineTerminator<- ->' ]				
				"QueryOperator<@ out queryOperator @><+ ((QueryExpression)expression).QueryOperators.Add(queryOperator); +>"
				
				[ 'LineTerminator<- ->' ]
				{ 
					"QueryOperator<@ out queryOperator @><+ ((QueryExpression)expression).QueryOperators.Add(queryOperator); +>" 
					<% if (this.AreNextTwo(VBTokenID.LineTerminator, VBTokenID.From, VBTokenID.Aggregate, VBTokenID.Select, VBTokenID.Distinct, VBTokenID.Where, VBTokenID.Order, VBTokenID.Skip, VBTokenID.Take, VBTokenID.Let, VBTokenID.Group, VBTokenID.Join)) { %>
						[ 'LineTerminator<- ->' ]
					<% } %>
				}
				<%
					expression.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: FromOrAggregateQueryOperator merged into QueryExpression -->
		<NonTerminal Key="QueryOperator" Parameters="out AstNode queryOperator">
			<Production><![CDATA[
				<%
					queryOperator = null;
				%>
				"FromQueryOperator<@ out queryOperator @>"
				| "AggregateQueryOperator<@ out queryOperator @>"
				| "SelectQueryOperator<@ out queryOperator @>"
				| "DistinctQueryOperator<@ out queryOperator @>"
				| "WhereQueryOperator<@ out queryOperator @>"
				| "OrderByQueryOperator<@ out queryOperator @>"
				| "PartitionQueryOperator<@ out queryOperator @>"
				| "LetQueryOperator<@ out queryOperator @>"
				| "GroupByQueryOperator<@ out queryOperator @>"
				| "JoinQueryOperator<@ out queryOperator @>"
				| "GroupJoinQueryOperator<@ out queryOperator @>"
			]]></Production>
		</NonTerminal>
		<!-- NOTE: CollectionRangeVariableDeclarationList merged into callers -->
		<NonTerminal Key="CollectionRangeVariableDeclaration" Parameters="out CollectionRangeVariableDeclaration variableDeclaration">
			<Production><![CDATA[
				<%
					variableDeclaration = new CollectionRangeVariableDeclaration();
					variableDeclaration.StartOffset = this.LookAheadToken.StartOffset;

					QualifiedIdentifier variableName;
					TypeReference typeReference = new TypeReference(TypeReference.AnonymousTypeName, new TextRange(this.LookAheadToken.StartOffset));
					Expression source;
				%>
				"NonQueryIdentifier<@ out variableName @>"
				[
					'As'
					"TypeName<@ out typeReference, false @>"
				]
				<%
					variableDeclaration.VariableDeclarator = new VariableDeclarator(typeReference, variableName, false, true);
				%>
				'In'
				[ 'LineTerminator<- ->' ]
				"Expression<@ out source @><+ variableDeclaration.Source = source; +>"
				<%
					variableDeclaration.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<!-- NOTE: ExpressionRangeVariableDeclarationList merged into callers -->
		<NonTerminal Key="ExpressionRangeVariableDeclaration" Parameters="out VariableDeclarator variableDeclarator">
			<Production><![CDATA[
				<%
					variableDeclarator = null;

					QualifiedIdentifier variableName = null;
					TypeReference typeReference = new TypeReference(TypeReference.AnonymousTypeName, new TextRange(this.LookAheadToken.StartOffset));
					Expression initializer;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				[<? (this.AreNextTwoIdentifierAnd(VBTokenID.As)) || (this.AreNextTwoIdentifierAnd(VBTokenID.Equality)) ?>
					"NonQueryIdentifier<@ out variableName @>"
					[
						'As'
						"TypeName<@ out typeReference, false @>"
					]
					'Equality'
				]
				<%
					variableDeclarator = new VariableDeclarator(typeReference, variableName, false, true);
					variableDeclarator.StartOffset = startOffset;
				%>
				"Expression<@ out initializer @><+ variableDeclarator.Initializer = initializer; +>"
				<%
					variableDeclarator.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="FromQueryOperator" Parameters="out AstNode fromQueryOperator">
			<Production><![CDATA[
				<%
					fromQueryOperator = new FromQueryOperator();
					fromQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					CollectionRangeVariableDeclaration variableDeclaration = null;
				%>
				'From'
				[ 'LineTerminator<- ->' ]
				"CollectionRangeVariableDeclaration<@ out variableDeclaration @><+ ((FromQueryOperator)fromQueryOperator).CollectionRangeVariableDeclarations.Add(variableDeclaration); +>"
				{ 'Comma' "CollectionRangeVariableDeclaration<@ out variableDeclaration @><+ ((FromQueryOperator)fromQueryOperator).CollectionRangeVariableDeclarations.Add(variableDeclaration); +>" }
				<%
					fromQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="JoinQueryOperator" Parameters="out AstNode joinQueryOperator">
			<Production><![CDATA[
				<%
					joinQueryOperator = new JoinQueryOperator();
					joinQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					CollectionRangeVariableDeclaration variableDeclaration = null;
					AstNode childJoinQueryOperator;
					JoinCondition condition;
				%>
				'Join'
				[ 'LineTerminator<- ->' ]
				"CollectionRangeVariableDeclaration<@ out variableDeclaration @><+ ((JoinQueryOperator)joinQueryOperator).CollectionRangeVariableDeclaration = variableDeclaration; +>"
				
				[ "JoinQueryOperator<@ out childJoinQueryOperator @><+ ((JoinQueryOperator)joinQueryOperator).ChildJoin = (JoinQueryOperator)childJoinQueryOperator; +>" ]
				
				[ 'LineTerminator<- ->' ]
				'On'
				[ 'LineTerminator<- ->' ]
				"JoinCondition<@ out condition @><+ ((JoinQueryOperator)joinQueryOperator).Conditions.Add(condition); +>"
				{
					'And'
					[ 'LineTerminator<- ->' ]
					"JoinCondition<@ out condition @><+ ((JoinQueryOperator)joinQueryOperator).Conditions.Add(condition); +>"
				}
				<%
					joinQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: JoinConditionList merged into JoinQueryOperator -->
		<NonTerminal Key="JoinCondition" Parameters="out JoinCondition condition">
			<Production><![CDATA[
				<%
					condition = new JoinCondition();
					condition.StartOffset = this.LookAheadToken.StartOffset;
					
					Expression expression;
				%>
				"Expression<@ out expression @><+ condition.LeftConditionExpression = expression; +>"
				'Equals'
				[ 'LineTerminator<- ->' ]
				"Expression<@ out expression @><+ condition.RightConditionExpression = expression; +>"
				<%
					condition.EndOffset = this.Token.EndOffset;
				%>
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="LetQueryOperator" Parameters="out AstNode letQueryOperator">
			<Production><![CDATA[
				<%
					letQueryOperator = new LetQueryOperator();
					letQueryOperator.StartOffset = this.LookAheadToken.StartOffset;

					VariableDeclarator variableDeclarator;
				%>
				'Let'
				[ 'LineTerminator<- ->' ]
				"ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((LetQueryOperator)letQueryOperator).VariableDeclarators.Add(variableDeclarator); +>"
				{ 'Comma' "ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((LetQueryOperator)letQueryOperator).VariableDeclarators.Add(variableDeclarator); +>" }
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="SelectQueryOperator" Parameters="out AstNode selectQueryOperator">
			<Production><![CDATA[
				<%
					selectQueryOperator = new SelectQueryOperator();
					selectQueryOperator.StartOffset = this.LookAheadToken.StartOffset;

					VariableDeclarator variableDeclarator;
				%>
				'Select'
				[ 'LineTerminator<- ->' ]
				"ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((SelectQueryOperator)selectQueryOperator).VariableDeclarators.Add(variableDeclarator); +>"
				{ 'Comma' "ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((SelectQueryOperator)selectQueryOperator).VariableDeclarators.Add(variableDeclarator); +>" }
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="DistinctQueryOperator" Parameters="out AstNode distinctQueryOperator">
			<Production><![CDATA[
				<%
					distinctQueryOperator = new DistinctQueryOperator();
					distinctQueryOperator.TextRange = new TextRange(this.LookAheadToken.StartOffset);
				%>
				'Distinct'
				[ 'LineTerminator<- ->' ]
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="WhereQueryOperator" Parameters="out AstNode whereQueryOperator">
			<Production><![CDATA[
				<%
					whereQueryOperator = new WhereQueryOperator();
					whereQueryOperator.StartOffset = this.LookAheadToken.StartOffset;

					Expression condition;
				%>
				'Where'
				[ 'LineTerminator<- ->' ]
				"Expression<@ out condition @><+ ((WhereQueryOperator)whereQueryOperator).Condition = condition; +>"
				<%	
					whereQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="PartitionQueryOperator" Parameters="out AstNode partitionQueryOperator">
			<Production><![CDATA[
				<%
					partitionQueryOperator = null;
					bool hasWhile = false;
					Expression expression;
					int startOffset = this.LookAheadToken.StartOffset;
				%>
				(
					'Skip'
					[ 'While<+ hasWhile = true; +>' ]
					[ 'LineTerminator<- ->' ]
					"Expression<@ out expression @>"
					<%
						if (hasWhile) {
							partitionQueryOperator = new SkipWhileQueryOperator();
							((SkipWhileQueryOperator)partitionQueryOperator).Expression = expression;
						}
						else {
							partitionQueryOperator = new SkipQueryOperator();
							((SkipQueryOperator)partitionQueryOperator).Expression = expression;
						}
					%>
				)
				| (
					'Take'
					[ 'While<+ hasWhile = true; +>' ]
					[ 'LineTerminator<- ->' ]
					"Expression<@ out expression @>"
					<%
						if (hasWhile) {
							partitionQueryOperator = new TakeWhileQueryOperator();
							((TakeWhileQueryOperator)partitionQueryOperator).Expression = expression;
						}
						else {
							partitionQueryOperator = new TakeQueryOperator();
							((TakeQueryOperator)partitionQueryOperator).Expression = expression;
						}
					%>
				)
				<%	
					if (partitionQueryOperator != null)
						partitionQueryOperator.TextRange = new TextRange(startOffset, this.Token.EndOffset);
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="OrderByQueryOperator" Parameters="out AstNode orderByQueryOperator">
			<Production><![CDATA[
				<%
					orderByQueryOperator = new OrderByQueryOperator();
					orderByQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					Ordering ordering;
				%>

				'Order'
				'By'
				[ 'LineTerminator<- ->' ]
				"OrderExpression<@ out ordering @><+ ((OrderByQueryOperator)orderByQueryOperator).Orderings.Add(ordering); +>"
				{ 
					'Comma'
					"OrderExpression<@ out ordering @><+ ((OrderByQueryOperator)orderByQueryOperator).Orderings.Add(ordering); +>"
				}
				<%	
					orderByQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: OrderExpressionList merged into OrderByQueryOperator -->
		<NonTerminal Key="OrderExpression" Parameters="out Ordering ordering">
			<Production><![CDATA[
				<%
					ordering = new Ordering();
					ordering.StartOffset = this.LookAheadToken.StartOffset;
					
					Expression expression;
				%>
				"Expression<@ out expression @><+ ordering.Expression = expression; +>"
				[
					'Ascending<+ ordering.Direction = OrderingDirection.Ascending; +>'
					| 'Descending<+ ordering.Direction = OrderingDirection.Descending; +>'
				]
				<%	
					ordering.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<!-- NOTE: Ordering merged into OrderExpression -->
		<NonTerminal Key="GroupByQueryOperator" Parameters="out AstNode groupQueryOperator">
			<Production><![CDATA[
				<%
					groupQueryOperator = new GroupQueryOperator();
					groupQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					VariableDeclarator variableDeclarator;
				%>
				'Group'
				[ 'LineTerminator<- ->' ]
				<% if (!this.TokenIs(this.LookAheadToken, VBTokenID.By)) { %>
					"ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((GroupQueryOperator)groupQueryOperator).Groupings.Add(variableDeclarator); +>"
					{ 'Comma' "ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((GroupQueryOperator)groupQueryOperator).Groupings.Add(variableDeclarator); +>" }
				<% } %>

				[ 'LineTerminator<- ->' ]
				'By'
				[ 'LineTerminator<- ->' ]
				"ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((GroupQueryOperator)groupQueryOperator).GroupBys.Add(variableDeclarator); +>"
				{ 'Comma' "ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((GroupQueryOperator)groupQueryOperator).GroupBys.Add(variableDeclarator); +>" }

				[ 'LineTerminator<- ->' ]
				'Into'
				[ 'LineTerminator<- ->' ]
				"ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((GroupQueryOperator)groupQueryOperator).TargetExpressions.Add(variableDeclarator); +>"
				{ 'Comma' "ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((GroupQueryOperator)groupQueryOperator).TargetExpressions.Add(variableDeclarator); +>" }
				<%	
					groupQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="AggregateQueryOperator" Parameters="out AstNode aggregateQueryOperator">
			<Production><![CDATA[
				<%
					aggregateQueryOperator = new AggregateQueryOperator();
					aggregateQueryOperator.StartOffset = this.LookAheadToken.StartOffset;
					
					CollectionRangeVariableDeclaration variableDeclaration = null;
					AstNode queryOperator;
					VariableDeclarator variableDeclarator;
				%>
				'Aggregate'
				[ 'LineTerminator<- ->' ]
				"CollectionRangeVariableDeclaration<@ out variableDeclaration @><+ ((AggregateQueryOperator)aggregateQueryOperator).CollectionRangeVariableDeclarations.Add(variableDeclaration); +>"
				{ 'Comma' "CollectionRangeVariableDeclaration<@ out variableDeclaration @><+ ((AggregateQueryOperator)aggregateQueryOperator).CollectionRangeVariableDeclarations.Add(variableDeclaration); +>" }
				
				[ 'LineTerminator<- ->' ]
				{ 					
					"QueryOperator<@ out queryOperator @><+ ((AggregateQueryOperator)aggregateQueryOperator).QueryOperators.Add(queryOperator); +>" 
					[ 'LineTerminator<- ->' ]
				}
				
				'Into'
				[ 'LineTerminator<- ->' ]
				"ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((AggregateQueryOperator)aggregateQueryOperator).TargetExpressions.Add(variableDeclarator); +>"
				{ 'Comma' "ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((AggregateQueryOperator)aggregateQueryOperator).TargetExpressions.Add(variableDeclarator); +>" }
				<%
					aggregateQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		<NonTerminal Key="GroupJoinQueryOperator" Parameters="out AstNode joinQueryOperator">
			<AdditionalConditions>
				<ClearFirstSet />
				<ExpressionCondition>this.AreNextTwo(VBTokenID.Group, VBTokenID.Join)</ExpressionCondition>
			</AdditionalConditions>
			<Production><![CDATA[
				<%
					joinQueryOperator = null;
					int startOffset = this.LookAheadToken.StartOffset;
					VariableDeclarator variableDeclarator;
				%>
				'Group'
				"JoinQueryOperator<@ out joinQueryOperator @><+ joinQueryOperator.StartOffset = startOffset; +>"
				
				[ 'LineTerminator<- ->' ]
				'Into'
				[ 'LineTerminator<- ->' ]
				"ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((JoinQueryOperator)joinQueryOperator).TargetExpressions.Add(variableDeclarator); +>"
				{ 'Comma' "ExpressionRangeVariableDeclaration<@ out variableDeclarator @><+ ((JoinQueryOperator)joinQueryOperator).TargetExpressions.Add(variableDeclarator); +>" }
				<%
					joinQueryOperator.EndOffset = this.Token.EndOffset;
				%>				
			]]></Production>
		</NonTerminal>
		
	</NonTerminals>
</Grammar>
	